apply plugin: 'wrapper'

allprojects {
  // We want to see all test results.  This is equivalatent to setting --continue
  // on the command line.
  gradle.startParameter.continueOnFailure = true
  
  repositories {
    mavenLocal()
    mavenCentral()
    maven { url "http://repo.spring.io/release" }
    maven { url "http://repo.spring.io/milestone" }
    maven { url "http://repo.spring.io/snapshot" }
    maven { url "http://repo.spring.io/libs-release" }
    maven { url "http://repo.spring.io/ext-release-local" }
    maven { url "http://dist.gemstone.com/maven/release" }
  }

  group = "io.pivotal.gemfire"

  apply plugin: 'idea'
  apply plugin: 'eclipse'
  
  buildRoot = buildRoot.trim()
  if (!buildRoot.isEmpty()) {
    buildDir = buildRoot + project.path.replace(":", "/") + "/build"
  }
}

def testResultsDir(def parent, def name) {
  new File(parent, name)
}

def writeTestProperties(def parent, def name) {
  def availablePortFinder = AvailablePortFinder.createPrivate()
  
  def props = new Properties()
  props.setProperty('mcast-port', Integer.toString(availablePortFinder.nextAvailable))
  props.setProperty('log-level', 'config')
  def propsFile = new File(testResultsDir(parent, name), 'gemfire.properties')
  def writer = propsFile.newWriter()
  props.store(writer, 'Autogenerated Gemfire properties')

}

subprojects {
  apply plugin: 'java'

  // apply compiler options
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(JavaCompile).each { javac ->
      javac.configure {
        sourceCompatibility '1.7'
        targetCompatibility '1.7'
        options.encoding = 'UTF-8'
      }
    }
  })
  
  // apply default manifest
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Jar).each { jar ->
      jar.doFirst {
        manifest {
          attributes(
            "Manifest-Version"  : "1.0",
            "Created-By"        : System.getProperty("user.name"),
            "Title"             : rootProject.name,
            "Version"           : version,
            "Vendor"            : "Pivotal Software, Inc."
          )
        }
      }
    }
  })

  configurations {
    provided {
      description 'a dependency that is provided externally at runtime'
      visible true
    }
    
    testOutput {
      extendsFrom testCompile
      description  'a dependency that exposes test artifacts'
    }
  }

  // Here we want to disable all transitive dependencies on external artifacts.  This
  // allows us to lock down library versions.  However, we want project dependencies to
  // be transitive such that the libraries of a dependent project are automatically included.
  configurations.all {
    dependencies.all { dep ->
      if (dep instanceof ModuleDependency && !(dep instanceof ProjectDependency)) {
        dep.transitive = false
      }
    }
  }
  
  eclipse {
    classpath {
      defaultOutputDir = file('build-eclipse')
      downloadSources = true
      plusConfigurations += [ configurations.provided ]     
    }
    // Several files have UTF-8 encoding and Eclipse running on Windows
    // will have trouble unless we tell it to use UTF-8 encoding.
    // This setting needs to go into the core.resources.prefs file,
    // which the JDT script isn't set up to configure
    eclipseJdt << {
      File f = file('.settings/org.eclipse.core.resources.prefs')
      f.write('eclipse.preferences.version=1\n')
      f.append('encoding/<project>=utf-8')
    }
  }
  
  cleanEclipse << {
    delete '.settings/org.eclipse.core.resources.prefs'
  }

  idea {
    module {
      downloadSources = true
      scopes.PROVIDED.plus += [ configurations.provided ]
    }
  }
    
  task jarTest (type: Jar, dependsOn: testClasses) {
    description 'Assembles a jar archive of test classes.'
    from sourceSets.test.output
    classifier 'test'
  }

  artifacts {
    testOutput jarTest
  }

  sourceSets {
    main.compileClasspath += configurations.provided
    main.runtimeClasspath -= configurations.provided
    test.compileClasspath += configurations.provided
    test.runtimeClasspath += configurations.provided
  }

  javadoc.classpath += configurations.provided
  
  dependencies {
    compile 'org.springframework:spring-aop:3.2.12.RELEASE'
    compile 'org.springframework:spring-beans:3.2.12.RELEASE'
    compile 'org.springframework:spring-context:3.2.12.RELEASE'
    compile 'org.springframework:spring-context-support:3.2.12.RELEASE'
    compile 'org.springframework:spring-core:3.2.12.RELEASE'
    compile 'org.springframework:spring-expression:3.2.12.RELEASE'
    compile 'org.springframework:spring-web:3.2.12.RELEASE'
    compile 'org.springframework:spring-webmvc:3.2.12.RELEASE'
    
    testCompile 'junit:junit:4.11'
    testCompile 'org.hamcrest:hamcrest-core:1.1'
    testCompile 'org.hamcrest:hamcrest-library:1.1'
    testCompile 'org.jmock:jmock:2.5.1'
    testCompile 'org.jmock:jmock-legacy:2.5.1'
    testCompile 'edu.umd.cs.mtc:multithreadedtc:1.01'
    testRuntime 'cglib:cglib-nodep:2.1_3'
    testRuntime 'org.objenesis:objenesis:1.0'
  }

  test {
    include '**/*JUnitTest.class'
    useJUnit {
      includeCategories 'com.gemstone.junit.UnitTest'
      excludeCategories 'com.gemstone.junit.IntegrationTest'
      excludeCategories 'com.gemstone.junit.DistributedTest'
    }    
    
    // run each test in its own vm to avoid interference issues if a test doesn't clean up
    // state
    //forkEvery 1
    
    doFirst {
      writeTestProperties(buildDir, name)
    }
  }

  task integrationTest(type:Test) {
    include '**/*JUnitTest.class'
    useJUnit {
      excludeCategories 'com.gemstone.junit.UnitTest'
      includeCategories 'com.gemstone.junit.IntegrationTest'
      excludeCategories 'com.gemstone.junit.DistributedTest'
    }    

    forkEvery 1

    doFirst {
      writeTestProperties(buildDir, name)
    }
  }
  
  task distributedTest(type:Test) {
    include '**/*DUnitTest.class'
    
// TODO add @Category(DistributedTest.class) to dunit tests
//    useJUnit {
//      excludeCategories 'com.gemstone.junit.UnitTest'
//      excludeCategories 'com.gemstone.junit.IntegrationTest'
//      includeCategories 'com.gemstone.junit.DistributedTest'
//    }    
    
    //I'm hoping this might deal with SOME OOMEs I've seen
    forkEvery 30
  }

  // apply common test configuration
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Test).each { test ->
      check.dependsOn test
      test.configure {
        onlyIf { ! Boolean.getBoolean('skip.tests') }
    
        def resultsDir = testResultsDir(buildDir, test.name)
        workingDir resultsDir.absolutePath
        
        reports.html.destination = file "$buildDir/reports/$name"
        testLogging {
          exceptionFormat = 'full'
        }
        
        maxHeapSize '768m'
        jvmArgs = ['-XX:+HeapDumpOnOutOfMemoryError', '-XX:MaxPermSize=256M', '-ea']

        systemProperties = [
          'gemfire.DEFAULT_MAX_OPLOG_SIZE' : '10',
          'gemfire.disallowMcastDefaults'  : 'true',
          'jline.terminal'                 : 'jline.UnsupportedTerminal',
        ]

        def eol = System.getProperty('line.separator')
        def progress = new File(resultsDir, "$test.name-progress.txt")
        beforeTest { desc ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Starting test $desc.className $desc.name$eol"
        }
        afterTest { desc, result ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Completed test $desc.className $desc.name with result: ${result.resultType}$eol"
        }
        
        doFirst {
          resultsDir.deleteDir()
          resultsDir.mkdirs()
        }
      }
    }
  })
  
  check.dependsOn integrationTest
  check.dependsOn distributedTest
}

task combineReports(type: TestReport) {
  description 'Combines the test reports.'
  destinationDir = file "$buildDir/reports/combined"
}

gradle.taskGraph.whenReady({ graph ->
  tasks.getByName('combineReports').reportOn rootProject.subprojects.collect{ it.tasks.withType(Test) }.flatten()
})

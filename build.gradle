apply plugin: 'wrapper'


// Load all properties in dependency-version.properties as project properties, so all projects can read them
Properties dependencyVersions = new Properties()
dependencyVersions.load(new FileInputStream("${project.projectDir}/gradle/dependency-versions.properties"))
dependencyVersions.keys().each{ k -> project.ext[k] = dependencyVersions[k]}

allprojects {
  version = versionNumber + '-' + releaseType
  // We want to see all test results.  This is equivalatent to setting --continue
  // on the command line.
  gradle.startParameter.continueOnFailure = true
  
  repositories {
    mavenLocal()
    mavenCentral()
    maven { url "http://repo.spring.io/release" }
    maven { url "http://repo.spring.io/milestone" }
    maven { url "http://repo.spring.io/snapshot" }
    maven { url "http://repo.spring.io/libs-release" }
    maven { url "http://repo.spring.io/ext-release-local" }
    maven { url "http://dist.gemstone.com/maven/release" }
  }

  group = "org.apache.geode"

  apply plugin: 'idea'
  apply plugin: 'eclipse'
  
  buildRoot = buildRoot.trim()
  if (!buildRoot.isEmpty()) {
    buildDir = buildRoot + project.path.replace(":", "/") + "/build"
  }

  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Tar).each { tar ->
      tar.compression = Compression.GZIP
      tar.extension = 'tar.gz'
    }
  })
}

task clean (type: Delete) {
  delete rootProject.buildDir
  if (!buildRoot.isEmpty()) {
    delete buildRoot
  }  
}

def testResultsDir(def parent, def name) {
  new File(parent, name)
}

def writeTestProperties(def parent, def name) {
  def availablePortFinder = AvailablePortFinder.createPrivate()
  
  def props = new Properties()
  props.setProperty('mcast-port', Integer.toString(availablePortFinder.nextAvailable))
  props.setProperty('log-level', 'config')
  def propsFile = new File(testResultsDir(parent, name), 'gemfire.properties')
  def writer = propsFile.newWriter()
  props.store(writer, 'Autogenerated Gemfire properties')

}

task combineReports(type: TestReport) {
  description 'Combines the test reports.'
  destinationDir = file "${rootProject.buildDir}/reports/combined"

  doLast {
    println "All test reports at ${rootProject.buildDir}/reports/combined"
  }
}

gradle.taskGraph.whenReady({ graph ->
  tasks.getByName('combineReports').reportOn rootProject.subprojects.collect{ it.tasks.withType(Test) }.flatten()
})

subprojects {
  apply plugin: 'java'

  // apply compiler options
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(JavaCompile).each { javac ->
      javac.configure {
        sourceCompatibility '1.8'
        targetCompatibility '1.8'
        options.encoding = 'UTF-8'
      }
    }
  })
  
  // apply default manifest
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Jar).each { jar ->
      jar.doFirst {
        manifest {
          attributes(
            "Manifest-Version"  : "1.0",
            "Created-By"        : System.getProperty("user.name"),
            "Title"             : rootProject.name,
            "Version"           : version,
            "Organization"      : "Apache Software Foundation (ASF)"
          )
        }
      }
    }
  })

  configurations {
    provided {
      description 'a dependency that is provided externally at runtime'
      visible true
    }
    
    testOutput {
      extendsFrom testCompile
      description  'a dependency that exposes test artifacts'
    }
  }

  // Here we want to disable all transitive dependencies on external artifacts.  This
  // allows us to lock down library versions.  However, we want project dependencies to
  // be transitive such that the libraries of a dependent project are automatically included.
  configurations.all {
    dependencies.all { dep ->
      if (dep instanceof ModuleDependency && !(dep instanceof ProjectDependency)) {
        dep.transitive = false
      }
    }
  }
 
  // Configuration for Checkstyle, FindBugs
  if (project.hasProperty("staticAnalysis")) {
    apply plugin: 'checkstyle'

    //Checkstyle configuration
    configurations.checkstyle {
      dependencies.all { dep ->
        dep.transitive = true
      }
    }
    
    //Findbugs configuration
    apply plugin: 'findbugs'
 
    configurations.findbugs {
      dependencies.all { dep ->
        dep.transitive = true
      }
    }

    // Switch default Findbugs report to HTML for developers
    def findbugsXmlEnabled = false
    def findbugsHtmlEnabled = true

    // Provide ability to change report type to XML for ingesting into other ap
    if ( project.hasProperty("findbugsXmlReport") ) {
      findbugsXmlEnabled = true
      findbugsHtmlEnabled = false
    }

    configurations.findbugs {
      dependencies.all { dep ->
        dep.transitive = true
      }
      findbugs.effort = 'max'
      findbugs.reportLevel = 'low'
    }
 
    tasks.withType(FindBugs) {
      reports {
        xml.enabled = findbugsXmlEnabled
        html.enabled = findbugsHtmlEnabled
      }
    }
  }

  // JaCoCo configuration
  if (project.hasProperty("codeCoverage")) {
    apply plugin: 'jacoco'
    
    configurations.jacocoAnt {
      dependencies.all { dep ->
          dep.transitive = true
      }
    }

    task mergeIntegrationTestCoverage (type: JacocoMerge) {
      description 'Merges Distributed and Integration test coverage results'

      destinationFile = file("${buildDir}/jacoco/mergedIntegrationTestCoverage.exec")
      executionData = fileTree(dir: 'build/jacoco', include: ['**/distributedTest.exec','**/integrationTest.exec'])

    }

    jacocoTestReport {
      reports { 
        csv.enabled false
        sourceSets project.sourceSets.main
        html.destination "${buildDir}/jacocoTestHtml"
      }
    }
    
    task jacocoIntegrationTestReport (type: JacocoReport) {
      reports { 
        csv.enabled false
        sourceSets project.sourceSets.main
        html.destination "${buildDir}/jacocoIntegrationTestHtml"
        executionData = fileTree(dir: 'build/jacoco', include: '**/integrationTest.exec')
      }
    }
    
    task jacocoDistributedTestReport (type: JacocoReport) {
      reports { 
        csv.enabled false
        sourceSets project.sourceSets.main
        html.destination "${buildDir}/jacocoDistributedTestHtml"
        executionData = fileTree(dir: 'build/jacoco', include: '**/distributedTest.exec')
      }
    }
    
    task jacocoOverallTestReport (type: JacocoReport) {
      reports { 
        csv.enabled false
        sourceSets project.sourceSets.main
        html.destination "${buildDir}/jacocoOverallTestHtml"
        executionData = fileTree(dir: 'build/jacoco', include: '**/*.exec')
      }
    }
  }
 
  eclipse {
    classpath {
      defaultOutputDir = file('build-eclipse')
      downloadSources = true
      plusConfigurations += [ configurations.provided ]     
    }
    // Several files have UTF-8 encoding and Eclipse running on Windows
    // will have trouble unless we tell it to use UTF-8 encoding.
    // This setting needs to go into the core.resources.prefs file,
    // which the JDT script isn't set up to configure
    eclipseJdt << {
      File f = file('.settings/org.eclipse.core.resources.prefs')
      f.write('eclipse.preferences.version=1\n')
      f.append('encoding/<project>=utf-8')
    }
  }
  
  cleanEclipse << {
    delete '.settings/org.eclipse.core.resources.prefs'
  }

  tasks.eclipse.dependsOn(cleanEclipse)

  idea {
    module {
      downloadSources = true
      scopes.PROVIDED.plus += [ configurations.provided ]
    }
  }
    
  task jarTest (type: Jar, dependsOn: testClasses) {
    description 'Assembles a jar archive of test classes.'
    from sourceSets.test.output
    classifier 'test'
  }

  artifacts {
    testOutput jarTest
  }

  sourceSets {
    main.compileClasspath += configurations.provided
    main.runtimeClasspath -= configurations.provided
    test.compileClasspath += configurations.provided
    test.runtimeClasspath += configurations.provided
  }

  javadoc.classpath += configurations.provided
  
  dependencies {
    compile 'org.springframework:spring-aop:' + project.'springframework.version'
    compile 'org.springframework:spring-beans:' + project.'springframework.version'
    compile 'org.springframework:spring-context:' + project.'springframework.version'
    compile 'org.springframework:spring-context-support:' + project.'springframework.version'
    compile 'org.springframework:spring-core:' + project.'springframework.version'
    compile 'org.springframework:spring-expression:' + project.'springframework.version'
    compile 'org.springframework:spring-web:' + project.'springframework.version'
    compile 'org.springframework:spring-webmvc:' + project.'springframework.version'

    testCompile 'com.jayway.awaitility:awaitility:' + project.'awaitility.version'
    testCompile 'com.github.stefanbirkner:system-rules:' + project.'system-rules.version'
    testCompile 'edu.umd.cs.mtc:multithreadedtc:' + project.'multithreadedtc.version'
    testCompile 'junit:junit:' + project.'junit.version'
    testCompile 'org.assertj:assertj-core:' + project.'assertj-core.version'
    testCompile 'org.mockito:mockito-core:' + project.'mockito-core.version'
    testCompile 'org.hamcrest:hamcrest-all:' + project.'hamcrest-all.version'
    testCompile 'org.jmock:jmock:' + project.'jmock.version'
    testCompile 'org.jmock:jmock-junit4:' + project.'jmock.version'
    testCompile 'org.jmock:jmock-legacy:' + project.'jmock.version'
    testCompile 'pl.pragmatists:JUnitParams:' + project.'JUnitParams.version'
    
    testRuntime 'cglib:cglib:' + project.'cglib.version'
    testRuntime 'org.objenesis:objenesis:' + project.'objenesis.version'
    testRuntime 'org.ow2.asm:asm:' + project.'asm.version'
  }

  test {
    include '**/*JUnitTest.class'
    useJUnit {
      includeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
    }    
    
    // run each test in its own vm to avoid interference issues if a test doesn't clean up
    // state
    //forkEvery 1
    
    doFirst {
      writeTestProperties(buildDir, name)
    }
  }

  //This target does not run any tests. Rather, it validates that there are no
  //tests that are missing a category annotation
  task checkMissedTests(type: Test) {
    include '**/*JUnitTest.class'
    useJUnit {
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
    }    

    beforeTest { descriptor ->
      throw new GradleException("The test " + descriptor.getClassName() + "." + descriptor.getName() + " does not include a junit category.");
    }
    
  }

  task integrationTest(type:Test) {
    include '**/*JUnitTest.class'
    useJUnit {
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      includeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
    }    

    forkEvery 1

    doFirst {
      writeTestProperties(buildDir, name)
    }
  }
  
  task distributedTest(type:Test) {
    include '**/*DUnitTest.class'
    
// TODO add @Category(DistributedTest.class) to dunit tests
//    useJUnit {
//      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
//      excludeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
//      includeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
//    }    
    
    //I'm hoping this might deal with SOME OOMEs I've seen
    forkEvery 30
  }
  
  // apply common test configuration
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Test).each { test ->
      check.dependsOn test
      test.configure {
        onlyIf { ! Boolean.getBoolean('skip.tests') }

        //force tests to be run every time by
        //saying the results are never up to date
        outputs.upToDateWhen { false }
    
        def resultsDir = testResultsDir(buildDir, test.name)
        workingDir resultsDir.absolutePath
        
        reports.html.destination = file "$buildDir/reports/$name"
        testLogging {
          exceptionFormat = 'full'
        }
        
        maxHeapSize '768m'
        jvmArgs = ['-XX:+HeapDumpOnOutOfMemoryError', '-ea']

        systemProperties = [
          'gemfire.DEFAULT_MAX_OPLOG_SIZE' : '10',
          'gemfire.disallowMcastDefaults'  : 'true',
          'jline.terminal'                 : 'jline.UnsupportedTerminal',
        ]

        def eol = System.getProperty('line.separator')
        def progress = new File(resultsDir, "$test.name-progress.txt")
        beforeTest { desc ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Starting test $desc.className $desc.name$eol"
        }
        afterTest { desc, result ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Completed test $desc.className $desc.name with result: ${result.resultType}$eol"
        }
        
        doFirst {
          resultsDir.deleteDir()
          resultsDir.mkdirs()
        }
      }
    }
  })

  // Make precheckin task run all validation tests for checking in code.
  task precheckin (dependsOn: [ build, integrationTest, distributedTest ]) {
    description 'Run this task before checking in code to validate changes. This task combines the following tasks: build, integrationTest, and distributedTest'
  }

  check.dependsOn checkMissedTests
  combineReports.mustRunAfter check, test, integrationTest, distributedTest, checkMissedTests
  build.finalizedBy combineReports
  check.finalizedBy combineReports
  test.finalizedBy combineReports
  integrationTest.finalizedBy combineReports
  distributedTest.finalizedBy combineReports
  checkMissedTests.finalizedBy combineReports

  // Make sure clean task for rootProject runs last
  clean.finalizedBy rootProject.clean
}


/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import groovy.xml.MarkupBuilder

apply from: "${rootDir}/${scriptDir}/module-descriptors-functions.gradle"

tasks.register('generateThirdPartyModuleXML') {
  inputs.files {
    rootProject.getTasksByName('generateModuleXml', true).each { it.outputs.files.files }.flatten()
  }

  outputs.dir {
    project(':geode-assembly').buildDir.toPath().resolve("moduleDescriptors")
  }

  doLast {
    def geodeAssemblyProj = project(":geode-assembly")
    def moduleDescriptorsRoot = "${geodeAssemblyProj.buildDir}/moduleDescriptors"

    def thirdPartyRoot = file(moduleDescriptorsRoot + "/thirdParty")
    Map<String, String> namesAndVersions = new TreeMap<>(new Comparator<String>() {
      @Override
      int compare(String o1, String o2) {
        if (o1 != null && o2 != null) {
          return o1.toLowerCase() <=> o2.toLowerCase()
        }
        return 0
      }
    })
    listFilesRecursively(thirdPartyRoot, thirdPartyRoot, namesAndVersions)

    mkdir("$moduleDescriptorsRoot/main/thirdParty/main")
    file("$moduleDescriptorsRoot/main/thirdParty/main/module.xml").withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

      xml.'module-alias'('xmlns': 'urn:jboss:module:1.9', 'name': "thirdParty", 'target-name': "thirdParty:$version")
    }

    def modulePath = "$moduleDescriptorsRoot/main/thirdParty/$version"
    mkdir(modulePath)
    file("$modulePath/module.xml").withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

      xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "thirdParty:$version") {
        xml.'dependencies' {
          namesAndVersions.each {
            xml.'module'(['name': "${it.key}:${it.value}", 'services': 'export', 'export': 'true'])
          }
        }
      }
    }
  }
}

tasks.register('generateDistributedTestThirdPartyModuleXML') {
  inputs.files {
    rootProject.getTasksByName('generateDistributedTestModuleXml', true).each { it.outputs.files.files }.flatten()
  }

  outputs.dir {
    project(':geode-assembly').buildDir.toPath().resolve('distributedTest').resolve("moduleDescriptors")
  }

  doLast {
    def geodeAssemblyProj = project(":geode-assembly")
    def moduleDescriptorsRoot = "${geodeAssemblyProj.buildDir}/distributedTest/moduleDescriptors"

    def thirdPartyRoot = file(moduleDescriptorsRoot + "/thirdParty")
    Map<String, String> namesAndVersions = new TreeMap<>(new Comparator<String>() {
      @Override
      int compare(String o1, String o2) {
        if (o1 != null && o2 != null) {
          return o1.toLowerCase() <=> o2.toLowerCase()
        }
        return 0
      }
    })
    listFilesRecursively(thirdPartyRoot, thirdPartyRoot, namesAndVersions)

    mkdir("$moduleDescriptorsRoot/main/thirdParty/main")
    file("$moduleDescriptorsRoot/main/thirdParty/main/module.xml").withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

      xml.'module-alias'('xmlns': 'urn:jboss:module:1.9', 'name': "thirdParty", 'target-name': "thirdParty:$version")
    }

    def modulePath = "$moduleDescriptorsRoot/main/thirdParty/$version"
    mkdir(modulePath)
    file("$modulePath/module.xml").withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

      xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "thirdParty:$version") {
        xml.'dependencies' {
          namesAndVersions.each {
            xml.'module'(['name': "${it.key}:${it.value}", 'services': 'export', 'export': 'true'])
          }
        }
      }
    }
  }
}

private List listFilesRecursively(File rootDirectory, File currentDirectory, namesAndVersions) {
  currentDirectory.listFiles().each {
    if (it.isDirectory()) {
      listFilesRecursively(rootDirectory, it, namesAndVersions)
    } else if (it.isFile() && it.name == "module.xml") {
      String moduleName = it.parentFile.parentFile.name
      File walkingFile = it.parentFile.parentFile.parentFile
      while (walkingFile.name != rootDirectory.name) {
        moduleName = "${walkingFile.name}.$moduleName"
        walkingFile = walkingFile.parentFile
      }
      def moduleVersion = it.parentFile.name
      namesAndVersions.put(moduleName, moduleVersion)
    }
  }
}

import org.apache.geode.gradle.TestPropertiesWriter
import org.apache.geode.gradle.RepeatTest
import org.apache.geode.gradle.plugins.DependencyConstraints

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

task combineReports(type: TestReport) {
  description 'Combines the test reports.'
  destinationDir = file "${rootProject.buildDir}/reports/combined"

  doLast {
    println "All test reports at ${rootProject.buildDir}/reports/combined"
  }
}

gradle.taskGraph.whenReady({ graph ->
  tasks.getByName('combineReports').reportOn rootProject.subprojects.collect {
    it.tasks.withType(Test)
  }.flatten()
})


subprojects { thisSubProject ->
  // This configuration might be safely removed once the CategoryWithParameterizedRunnerFactory
  // and associated classes are themselves removed, per GEODE-5606
  configurations {
    apt
  }

  compileTestJava {
    options.annotationProcessorPath = files(configurations['apt'])
  }

  test {
    doFirst {
      TestPropertiesWriter.writeTestProperties(buildDir, name)
    }
    if (thisSubProject.hasProperty('testMaxParallelForks')) {
      maxParallelForks = Integer.parseUnsignedInt(thisSubProject.testMaxParallelForks)
    } else {
      maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
    }
  }

  apply plugin: 'nebula.facet'
  facets {
    integrationTest {
      testTaskName = 'integrationTest'
      includeInCheckLifecycle = false
    }
    distributedTest {
      testTaskName = 'distributedTest'
      includeInCheckLifecycle = false
    }
    performanceTest {
      testTaskName = 'performanceTest'
      includeInCheckLifecycle = false
    }
    acceptanceTest {
      testTaskName = 'acceptanceTest'
      includeInCheckLifecycle = false
    }
    uiTest {
      testTaskName = 'uiTest'
      includeInCheckLifecycle = false
    }
    upgradeTest {
      testTaskName = 'upgradeTest'
      includeInCheckLifecycle = false
    }
  }

  configurations {
    testAnnotationProcessor.extendsFrom annotationProcessor
    integrationTestAnnotationProcessor.extendsFrom annotationProcessor
    distributedTestAnnotationProcessor.extendsFrom annotationProcessor
    performanceTestAnnotationProcessor.extendsFrom annotationProcessor
    acceptanceTestAnnotationProcessor.extendsFrom annotationProcessor
    uiTestAnnotationProcessor.extendsFrom annotationProcessor
    upgradeTestAnnotationProcessor.extendsFrom annotationProcessor
    // Facets does not extend the new runtimeOnly configurations
    integrationTestRuntimeOnly.extendsFrom(runtimeOnly)
    distributedTestRuntimeOnly.extendsFrom(runtimeOnly)
    performanceTestRuntimeOnly.extendsFrom(runtimeOnly)
    acceptanceTestRuntimeOnly.extendsFrom(runtimeOnly)
    uiTestRuntimeOnly.extendsFrom(runtimeOnly)
    upgradeTestRuntimeOnly.extendsFrom(runtimeOnly)
  }

  dependencies {
    // Do not add dependencies here that are not part of a custom configuration.
    // Dependencies should be explicit in the relevant build.gradle files to keep our modules
    //  as decoupled as possible.

    // This 'apt' configuration to be removed by GEODE-5606.
    apt files("${rootProject.projectDir}/buildSrc/build/libs/buildSrc.jar")
    apt('junit:junit:' + DependencyConstraints.get('junit.version')) {
      transitive = false
    }

    testRuntime('cglib:cglib:' + DependencyConstraints.get('cglib.version')) {
      exclude module: 'org.apache.ant'
    }
  }

  configure([integrationTest, distributedTest, performanceTest, acceptanceTest, uiTest,
             upgradeTest]) {
    forkEvery 1

    doFirst {
      TestPropertiesWriter.writeTestProperties(buildDir, name)
    }
    outputs.upToDateWhen { false }
  }

  configure([integrationTest, distributedTest, performanceTest]) {
    useJUnit {
      if (thisSubProject.hasProperty("testCategory")) {
        includeCategories += thisSubProject.testCategory
      }
    }
  }

  if (thisSubProject.hasProperty("forceTest")) {
    // All test facets already force rerun.  Only :test can be upToDate.
    test {
      outputs.upToDateWhen { false }
    }
  }

  task repeatDistributedTest(type: RepeatTest) {
    dependsOn { distributedTest.taskDependencies }
    classpath = thisSubProject.sourceSets.distributedTest.runtimeClasspath
    testClassesDirs = thisSubProject.sourceSets.distributedTest.output.classesDirs
  }

  task repeatIntegrationTest(type: RepeatTest) {
    dependsOn { integrationTest.taskDependencies }
    classpath = thisSubProject.sourceSets.integrationTest.runtimeClasspath
    testClassesDirs = thisSubProject.sourceSets.integrationTest.output.classesDirs
  }

  task repeatAcceptanceTest(type: RepeatTest) {
    dependsOn { acceptanceTest.taskDependencies }
    classpath = thisSubProject.sourceSets.acceptanceTest.runtimeClasspath
    testClassesDirs = thisSubProject.sourceSets.acceptanceTest.output.classesDirs
  }

  task repeatUpgradeTest(type: RepeatTest) {
    dependsOn { upgradeTest.taskDependencies }
    classpath = thisSubProject.sourceSets.upgradeTest.runtimeClasspath
    testClassesDirs = thisSubProject.sourceSets.upgradeTest.output.classesDirs
  }

  task repeatUnitTest(type: RepeatTest) {
    dependsOn { test.taskDependencies }
    // default classpath works for this one.
  }

  configure([integrationTest, distributedTest, performanceTest, acceptanceTest, uiTest, upgradeTest]) {
    if (thisSubProject.hasProperty('excludeTest')) {
      exclude thisSubProject.getProperty('excludeTest').split(',')
    }
  }

  configure([repeatDistributedTest, repeatIntegrationTest, repeatUpgradeTest, repeatUnitTest, repeatAcceptanceTest]) {
    times = Integer.parseInt(repeat)
    useJUnit {}
    outputs.upToDateWhen { false }

    if (thisSubProject.hasProperty("failOnNoMatchingTests")) {
      filter {
        setFailOnNoMatchingTests(Boolean.valueOf(thisSubProject.failOnNoMatchingTests))
      }
    }
  }

  // apply common test configuration
  gradle.taskGraph.whenReady({ graph ->
    tasks.withType(Test).each { test ->
      check.dependsOn test
      test.configure {
        onlyIf { !Boolean.getBoolean('skip.tests') }

        def resultsDir = TestPropertiesWriter.testResultsDir(buildDir, test.name)
        test.workingDir = resultsDir

        reports.html.destination = file "$buildDir/reports/$name"
        testLogging {
          exceptionFormat = 'full'
        }

        maxHeapSize '768m'
        jvmArgs = ['-XX:+HeapDumpOnOutOfMemoryError', '-ea']
        if (thisSubProject.hasProperty('testJVMVer') && testJVMVer.toInteger() >= 9) {
          jvmArgs += ["--add-opens", "java.xml/jdk.xml.internal=ALL-UNNAMED"]
          jvmArgs += ["--add-opens", "java.base/jdk.internal.module=ALL-UNNAMED"]
          jvmArgs += ["--add-opens", "java.base/java.lang.module=ALL-UNNAMED"]
        }
        if (thisSubProject.hasProperty('testJVM') && !testJVM.trim().isEmpty()) {
          executable = "${testJVM}/bin/java"
        }

        systemProperty 'gemfire.DEFAULT_MAX_OPLOG_SIZE', '10'
        systemProperty 'gemfire.disallowMcastDefaults', 'true'
        systemProperty 'jline.terminal', 'jline.UnsupportedTerminal'
        def logLevel = System.getProperty('log-level')
        if (logLevel != null) {
          systemProperty 'log-level', logLevel
        }
        def log4jLocation = System.getProperty('log4j.configurationFile')
        if (log4jLocation != null) {
          systemProperty 'log4j.configurationFile', log4jLocation
        }

        // The distributed tests seem to need to use /tmp directly,
        // so exclude them from using the supplied temp directory.
        if (!test.name.contains("distributed")) {
          systemProperty 'java.io.tmpdir', System.getProperty('java.io.tmpdir')
        }

        def eol = System.getProperty('line.separator')
        def progress = new File(resultsDir, "$test.name-progress.txt")
        beforeTest { desc ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Starting test $desc.className $desc.name$eol"
        }
        afterTest { desc, result ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Completed test $desc.className $desc.name with result: ${result.resultType}$eol"
        }

        doFirst {
          resultsDir.deleteDir()
          resultsDir.mkdirs()
        }
      }
    }
  })

  acceptanceTest {
    // Acceptance tests may reach out and run a gfsh command from the assembled gfsh.
    // If the test JVM version is specified, we must have the correct JAVA_HOME set for gfsh to use.
    // See also environment configuration for parallel testing in docker.gradle
    if (thisSubProject.hasProperty('testJVM') && !testJVM.trim().isEmpty()) {
      environment "JAVA_HOME", "${thisSubProject.testJVM}"
    }
  }


  // Make precheckin task run all validation tests for checking in code.
  task precheckin(dependsOn: [build, acceptanceTest, integrationTest, distributedTest, upgradeTest]) {
    description 'Run this task before checking in code to validate changes. It runs tests beyond unitTest'
  }

  tasks.withType(Test).plus([build, check]).each {
    it.finalizedBy combineReports
    combineReports.mustRunAfter it
  }

  rootProject.tasks.named('classes').configure {
    // This is a semi-lazy hook so that the target "assemble" also assembles our test sources.
    dependsOn([
      thisSubProject.tasks.named('compileTestJava'),
      thisSubProject.tasks.named('compileIntegrationTestJava'),
      thisSubProject.tasks.named('compileDistributedTestJava'),
      thisSubProject.tasks.named('compileAcceptanceTestJava'),
      thisSubProject.tasks.named('compileUiTestJava'),
      thisSubProject.tasks.named('compilePerformanceTestJava'),
      thisSubProject.tasks.named('compileUpgradeTestJava'),
    ])
  }
}

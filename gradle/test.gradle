/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
def testResultsDir(def parent, def name) {
  new File(parent, name)
}

def writeTestProperties(def parent, def name) {
  def availablePortFinder = AvailablePortFinder.createPrivate()
  
  def props = new Properties()
  props.setProperty('mcast-port', Integer.toString(availablePortFinder.nextAvailable))
  props.setProperty('log-level', 'config')
  def propsFile = new File(testResultsDir(parent, name), 'gemfire.properties')
  def writer = propsFile.newWriter()
  props.store(writer, 'Autogenerated Gemfire properties')

}

task combineReports(type: TestReport) {
  description 'Combines the test reports.'
  destinationDir = file "${rootProject.buildDir}/reports/combined"

  doLast {
    println "All test reports at ${rootProject.buildDir}/reports/combined"
  }
}

gradle.taskGraph.whenReady({ graph ->
  tasks.getByName('combineReports').reportOn rootProject.subprojects.collect{ it.tasks.withType(Test) }.flatten()
})


subprojects {
  dependencies {
    testCompile 'com.github.stefanbirkner:system-rules:' + project.'system-rules.version'
    testCompile 'com.google.code.tempus-fugit:tempus-fugit:' + project.'tempus-fugit.version'
    testCompile 'com.jayway.awaitility:awaitility:' + project.'awaitility.version'
    testCompile 'edu.umd.cs.mtc:multithreadedtc:' + project.'multithreadedtc.version'
    testCompile 'eu.codearte.catch-exception:catch-exception:' + project.'catch-exception.version'
    testCompile 'eu.codearte.catch-exception:catch-throwable:' + project.'catch-throwable.version'
    testCompile 'junit:junit:' + project.'junit.version'
    testCompile 'org.assertj:assertj-core:' + project.'assertj-core.version'
    testCompile 'org.mockito:mockito-core:' + project.'mockito-core.version'
    testCompile 'org.hamcrest:hamcrest-all:' + project.'hamcrest-all.version'
    testCompile 'org.jmock:jmock-junit4:' + project.'jmock.version'
    testCompile 'org.jmock:jmock-legacy:' + project.'jmock.version'
    testCompile 'pl.pragmatists:JUnitParams:' + project.'JUnitParams.version'
    
    testRuntime 'cglib:cglib:' + project.'cglib.version'
    testRuntime 'org.ow2.asm:asm:' + project.'asm.version'
  }
  
  //This target does not run any tests. Rather, it validates that there are no
  //tests that are missing a category annotation
  task checkMissedTests(type: Test) {
    include '**/*Test.class'
    useJUnit {
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.PerformanceTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.HydraTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.ContainerTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UITest'
    }

    beforeTest { descriptor ->
      throw new GradleException("The test " + descriptor.getClassName() + "." + descriptor.getName() + " does not include a junit category.");
    }
  }


  test {
    include '**/*Test.class'
    useJUnit {
      includeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.PerformanceTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.HydraTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.ContainerTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UITest'
    }
    
    // run each test in its own vm to avoid interference issues if a test doesn't clean up
    // state
    //forkEvery 1
    
    doFirst {
      writeTestProperties(buildDir, name)
    }
  }

  task integrationTest(type:Test) {
    include '**/*Test.class'
    exclude '**/*DUnitTest.class'
    useJUnit {
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      includeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.PerformanceTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.HydraTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.ContainerTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UITest'
    }

    forkEvery 1

    doFirst {
      writeTestProperties(buildDir, name)
    }
  }

  task uiTest(type:Test) {
    include '**/*Test.class'
    useJUnit {
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.PerformanceTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.HydraTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.ContainerTest'
      includeCategories 'com.gemstone.gemfire.test.junit.categories.UITest'
    }

    doFirst {
      writeTestProperties(buildDir, name)
    }
  }
  
  task distributedTest(type:Test) {
    include '**/*Test.class'
    
    // maxParallelForks = 2
    // maxParallelForks = Runtime.runtime.availableProcessors()
    
    useJUnit {
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UnitTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.IntegrationTest'
      includeCategories 'com.gemstone.gemfire.test.junit.categories.DistributedTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.PerformanceTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.HydraTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.ContainerTest'
      excludeCategories 'com.gemstone.gemfire.test.junit.categories.UITest'
    }
    
    //I'm hoping this might deal with SOME OOMEs I've seen
    forkEvery 30

  }

  // By proving a file with an arbitrary list of test classes, we can select only those
  // tests to run. Activated using -Dcustom.tests=<file> customTest
  def customTestList = []
  def customTestFile = System.getProperty('custom.tests')
  if (customTestFile != null) {
    new File(customTestFile).eachLine { customTestList << it }
  }

  task customTest(type:Test) {
    include { x ->
      (x.isDirectory() || customTestList.any { y -> x.getName().contains(y) } ) ? true : false
    }

    forkEvery 30
  }

  // apply common test configuration
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Test).each { test ->
      check.dependsOn test
      test.configure {
        onlyIf { ! Boolean.getBoolean('skip.tests') }

        //force tests to be run every time by
        //saying the results are never up to date
        outputs.upToDateWhen { false }
    
        def resultsDir = testResultsDir(buildDir, test.name)
        workingDir resultsDir.absolutePath
        
        reports.html.destination = file "$buildDir/reports/$name"
        testLogging {
          exceptionFormat = 'full'
        }
        
        maxHeapSize '768m'
        jvmArgs = ['-XX:+HeapDumpOnOutOfMemoryError', '-ea']

        systemProperty 'gemfire.DEFAULT_MAX_OPLOG_SIZE', '10'
        systemProperty 'gemfire.disallowMcastDefaults', 'true'
        systemProperty 'jline.terminal', 'jline.UnsupportedTerminal'

        def eol = System.getProperty('line.separator')
        def progress = new File(resultsDir, "$test.name-progress.txt")
        beforeTest { desc ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Starting test $desc.className $desc.name$eol"
        }
        afterTest { desc, result ->
          def now = new Date().format('yyyy-MM-dd HH:mm:ss.SSS Z')
          progress << "$now Completed test $desc.className $desc.name with result: ${result.resultType}$eol"
        }
        
        doFirst {
          resultsDir.deleteDir()
          resultsDir.mkdirs()
        }
      }
    }
  })

  // Make precheckin task run all validation tests for checking in code.
  task precheckin (dependsOn: [ build, integrationTest, distributedTest ]) {
    description 'Run this task before checking in code to validate changes. This task combines the following tasks: build, integrationTest, and distributedTest'
  }

  check.dependsOn checkMissedTests
  
  combineReports.mustRunAfter check, test, integrationTest, distributedTest, checkMissedTests
  build.finalizedBy combineReports
  check.finalizedBy combineReports
  test.finalizedBy combineReports
  integrationTest.finalizedBy combineReports
  distributedTest.finalizedBy combineReports
  checkMissedTests.finalizedBy combineReports
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Configuration for running (dunit) tests in parallel in Docker containers.
 * The container used must hava JAVA_HOME set in it's environment and must
 * have 'java' defined on the path. For example, the relevant Dockerfile
 * content could be:
 *
 *   ENV JAVA_HOME=/opt/jdk1.8.0_u101
 *   ENV PATH=$PATH:$JAVA_HOME/bin
 *
 * In addition, the container must have docker installed.
 *
 * The plugin can be activated with the Gradle property 'parallelDunit'.
 * Additional properties that can be set are:
 *
 *  dunitDockerImage   - The docker image used for running parallel dunits. The
 *                       default image is 'bellsoft/liberica-openjdk-debian:8'. The image is required to
 *                       have 'JAVA_HOME' set as an environment variable.
 *  dunitParallelForks - The number of parallel containers that will be
 *                       launched. The default is 8.
 *  dunitDockerUser    - The user used within the docker container to run tests.
 *                       The default is 'root'.
 *  dunitDockerVolumes - Docker volumes to mount in the docker container in addition to the
 *                       ones mounted by the plugin. The plugin always mounts the directory of the
 *                       top-level Geode project and the current user's Gradle home directory.
 */

apply plugin: 'geode-dockerized-test'

// TODO: Move all of this into the plugin?
project.ext.dockerConfig = {
    maxParallelForks = dunitParallelForks.toInteger()
    // If containerJVM is not set, try to use testJVM instead
    if (!project.hasProperty('containerJVM') && project.hasProperty('testJVM')) {
        project.ext.containerJVM = project.testJVM
    }

    dockerizedTest {
        prepareJavaCommand = { processBuilder ->
            def command = processBuilder.command()
            def environment = processBuilder.environment()

            if (environment['JAVA_HOME']) {
                environment['JAVA_HOME_REMOVED'] = environment['JAVA_HOME']
                environment.remove 'JAVA_HOME'
            }
            if (environment['PATH']) {
                environment['PATH_REMOVED'] = environment['PATH']
                environment.remove 'PATH'
            }

            if (project.hasProperty('containerJVM') && !project.containerJVM.trim().isEmpty()) {
                // Process builder command is just 'java'. Set it to the full path instead.
                environment['JAVA_HOME'] = project.containerJVM as String
                command.set(0, "${project.containerJVM}/bin/java" as String)
            }

            // Unfortunately this snippet of code is here and is required by dev-tools/docker/base/entrypoint.sh.
            // This allows preserving the outer user inside the running container. Required for Jenkins
            // and other environments. There doesn't seem to be a way to pass this environment variable
            // in from a Jenkins Gradle job.
            if (System.env['LOCAL_USER_ID'] == null) {
                def username = System.getProperty("user.name")
                def userID = ['id', '-u', username].execute().text.trim()
                environment['LOCAL_USER_ID'] = userID as String
            }

            def workerName = command.last()
            def workerID = (workerName =~ /\d+/).findAll().last()
            def workerDir = new File(processBuilder.directory(), "test-worker-$workerID").getAbsoluteFile()
            workerDir.mkdirs()

            def classPathFileIndex = command.findIndexOf { it =~ /^@.*gradle-worker-classpath.*txt$/ }
            if (classPathFileIndex > 0) {
                def workerClasspathFile = new File(workerDir, "gradle-worker-classpath.txt")
                if (!workerClasspathFile.exists()) {
                    def originalClasspathFile = new File(command[classPathFileIndex].substring(1))
                    workerClasspathFile.write(originalClasspathFile.text)
                }
                command[classPathFileIndex] = '@' + workerClasspathFile.toString()
            }
            processBuilder.directory(workerDir)
        }
    }
}

if (project.hasProperty('parallelDunit')) {
    uiTest.configure(project.ext.dockerConfig)
    repeatUnitTest.configure(project.ext.dockerConfig)

    integrationTest.configure(project.ext.dockerConfig)
    repeatIntegrationTest.configure(project.ext.dockerConfig)

    distributedTest.configure(project.ext.dockerConfig)
    repeatDistributedTest.configure(project.ext.dockerConfig)

    upgradeTest.configure(project.ext.dockerConfig)
    repeatUpgradeTest.configure(project.ext.dockerConfig)

    acceptanceTest.configure(project.ext.dockerConfig)
    repeatAcceptanceTest.configure(project.ext.dockerConfig)
}

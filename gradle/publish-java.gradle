/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

apply from: "${rootDir}/gradle/publish-common.gradle"
apply from: "${rootDir}/gradle/publish-artifacts.gradle"

publishing {
  publications {
    maven(MavenPublication) {
      from components.java
      // use the (possibly empty) Jar tasks above for sources and javadoc
      artifact sourcesJar
      artifact javadocJar
    }
  }
}

gradle.taskGraph.whenReady({ graph ->
  tasks.withType(Jar).each { jar ->
    jar.doFirst {
      def projectDependencies = []
      def runtimeList = []
      def allProjectDeps = []

      def confList = ['api', 'implementation', 'runtimeOnly']
      confList.each { conf ->
        allProjectDeps.addAll(project.configurations.getByName(conf).getDependencies())
      }

      // Iterate over runtime classpath dependencies and separate project dependencies from library
      // dependencies.
      allProjectDeps.each { dependency ->
        if ( dependency instanceof ProjectDependency )  {
          def platformAttribute = Attribute.of("org.gradle.category", org.gradle.api.attributes.Category.class)
          def foundAttribute = dependency.attributes.getAttribute(platformAttribute)
          if ( foundAttribute == null) {
            projectDependencies.add(dependency)
          } else if ('platform'.equals(foundAttribute)) {
            projectDependencies.add(dependency)
          }
        } else {
          project.configurations.runtimeClasspath.files(dependency).each { depJar ->
            runtimeList.add(depJar.name)
          }
        }
      }

      // Iterate over project (parent) dependencies and remove its runtime library dependencies from
      // the current project's runtime library dependencies.
      // Also removes all parent project's runtime project dependencies from the current project.
      // This returns a unique set of parent project and library dependencies that are not found
      // within it's parent's project dependencies.
      projectDependencies.clone().each { ProjectDependency projectDependency ->
        Project geodeProject = projectDependency.getDependencyProject()
        def collect = geodeProject.configurations.runtimeClasspath.collect { it.name }
        runtimeList.removeAll(collect)
//      projectDependencies.removeAll(collect.collect {it-".jar"})
      }

      manifest {
        attributes.put("Class-Path", runtimeList.join(' '))
        attributes.put("Dependent-Modules", projectDependencies.collect({ "${it.name}-${it.version}" }).join(' '))
        attributes.put("Module-Name", project.name)
      }
    }
  }
})

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

subprojects {
  apply plugin: "com.diffplug.gradle.spotless"
  spotless {
    lineEndings = 'unix'
    java {
      target project.fileTree(project.projectDir) {
        include '**/*.java'
        exclude '**/generated-src/**'
        exclude '**/build/**'
      }

      // As the method name suggests, bump this number if any of the below "custom" rules change.
      // Spotless will not run on unchanged files unless this number changes.
      bumpThisNumberIfACustomStepChanges(3)

      removeUnusedImports()

      custom 'Remove commented-out import statements', {
        it.replaceAll(/\n\/\/ import .*?;.*/, '')
      }
      custom 'Refuse wildcard imports', {
        // Wildcard imports can't be resolved by spotless itself.
        // This will require the developer themselves to adhere to best practices.
        if (it =~ /\nimport .*\*;/) {
          throw new AssertionError("Do not use wildcard imports.  'spotlessApply' cannot resolve this issue.");
        }
      }
      importOrderFile "${project(':geode-core').projectDir}/../etc/eclipseOrganizeImports.importorder"

      custom 'Remove unhelpful javadoc stubs', {
        // e.g., remove the following lines:
        // "* @param paramName"
        // "* @throws ExceptionType"
        // "* @return returnType"'
        // Multiline to allow anchors on newlines
        it.replaceAll(/(?m)^ *\* *@(?:param|throws|return) *\w* *\n/, '')
      }
      custom 'Remove any empty Javadocs and block comments', {
        // Matches any /** [...] */ or /* [...] */ that contains:
        // (a) only whitespace
        // (b) trivial information, such as "@param paramName" or @throws ExceptionType
        //     without any additional information.  This information is implicit in the signature.
        it.replaceAll(/\/\*+\s*\n(\s*\*\s*\n)*\s*\*+\/\s*\n/, '')
      }

      // Enforce style modifier order
      custom 'Modifier ordering', {
        def modifierRanking = [
                "public": 1,
                "protected": 2,
                "private": 3,
                "abstract": 4,
                "default": 5,
                "static": 6,
                "final": 7,
                "transient": 8,
                "volatile": 9,
                "synchronized": 10,
                "native": 11,
                "strictfp": 12]
        // Find any instance of multiple modifiers. Lead with a non-word character to avoid
        // accidental matching against for instance, "an alternative default value"
        it.replaceAll(/\W(?:public |protected |private |abstract |default |static |final |transient |volatile |synchronized |native |strictfp ){2,}/, {
          // Do not replace the leading non-word character.  Identify the modifiers
          it.replaceAll(/(?:public |protected |private |abstract |default |static |final |transient |volatile |synchronized |native |strictfp ){2,}/, {
            // Sort the modifiers according to the ranking above
            it.split().sort({ modifierRanking[it] }).join(' ') + ' '
          }
          )
        }
        )
      }


      // Notes on eclipse formatter version:
      // 4.6.3 is consistent with existing / previous behavior.
      // 4.7.1 works, but had different default whitespace rules, notably with mid-ternary linebreak.
      // 4.7.2 exists but is currently incompatible with our style file, raising NPEs.

      // The format file is relative to geode-core and not the root project as the root project would change
      // if Geode and submodules are included as part of a different gradle project.
      eclipse('4.6.3').configFile "${project(':geode-core').projectDir}/../etc/eclipse-java-google-style.xml"
      trimTrailingWhitespace()
      endWithNewline()
    }

    groovyGradle {
      target project.fileTree(project.projectDir) {
        include '**/*.gradle'
        exclude '**/generated-src/**'
        exclude '**/build/**'
      }

      // As the method name suggests, bump this number if any of the below "custom" rules change.
      // Spotless will not run on unchanged files unless this number changes.
//      bumpThisNumberIfACustomStepChanges(0)

      custom 'Use single-quote in project directives.', {
        it.replaceAll(/project\(":([^"]*)"\)/, 'project(\':$1\')')
      }

      custom 'Use parenthesis in single-line gradle dependency declarations.', {
        it.replaceAll(/\n(\s*\S*(?:[cC]ompile|[rR]untime)(?:Only)?) (?!\()([^{\n]*)\n/, { original, declaration, dep ->
          println("Got:")
          println("ori:" + original.trim())
          println("dec:" + declaration.trim())
          println("dep:" + dep.trim())
          "\n${declaration}(${dep})\n"
        })
      }

      indentWithSpaces(2)

      custom 'Sort declared dependencies.', { file_as_string ->
        // The sorting of dependency configuration lines will follow the following rules:
        // (a) Internal dependencies first (e.g., 'compile project(":geode-core")')
        // (b) Then sort by scope, as ranked below.
        // (c) Then sort by type, as ranked below.
        // (*) Some special cases exist and are given first-listing priority.
        //
        // Note the actual dependency configuration directive is a combination of scope and type
        // (e.g., 'integrationTestCompileOnly').  These are produced below the rankings.

        def dependency_scope_ranking = [
            ''               : 0,
            'test'           : 1,
            'integrationTest': 2,
            'distributedTest': 3,
            'acceptanceTest' : 4,
            'uiTest'         : 5,
            'upgradeTest'    : 6,
        ]
        def dependency_type_ranking = [
            'compile'        : 1,
            'compileOnly'    : 2,
            'runtime'        : 3,
            'runtimeOnly'    : 4,
        ]
        def dependency_keyword_ranking = dependency_scope_ranking.collectEntries {
          scope_key, scope_value ->
            dependency_type_ranking.collectEntries {
              type_key, type_value ->
                [(scope_key + type_key.capitalize()).uncapitalize(), scope_value * 100 + type_value * 10]
            }
        }
        // Some special cases:
        dependency_keyword_ranking['classesOutput'] = 1
        dependency_keyword_ranking['slf4jDeps'] = 2

        def rank_dependency_directive = { line ->
          // Given a line, return a sortable string.
          // We 'score' based on the dependency configuration directive, "penalizing" non-internal
          // dependencies.  We append the original string after this score to sort alphabetically
          // within a given directive.

          def first_word = line.trim().split(/[ \(]/)[0].trim()
          def order_score = dependency_keyword_ranking.getOrDefault(first_word, 0)
          if (order_score == 0){
            logger.warn("Missing rank for: '" + first_word + "' in custom Gradle spotless.")
          }
          def is_project_score = line.contains('project(') ? 0 : 1000
          String.format("%04d", is_project_score + order_score) + "_" + line.trim()
        }

        // Trying to match `dependencies { ... }`, anchored (but possibly space-padded) at line start.
        // Content may itself contain `{ exclude ... }` blocks, or others (such as whenMerged).
        // Groovy Regex does not permit recursion, so we explicitly detect `dependencies` blocks,
        // including nesting of up to three inner blocks.

        def block_matcher = /\{[^\{\}]*\}/
        def depth_two_block_matcher = /\{[^\{\}]*(?:${block_matcher})*[^\{\}]*\}/
        def not_delimited_depth_three_block_matcher = /[^\{\}]*(?:${depth_two_block_matcher})*[^\{\}]/
        def dependency_block_pattern = /(?smx)^((?: ))*dependencies\s*\{(${not_delimited_depth_three_block_matcher})\}/
        def spaces_per_tab = 2
        def make_new_dependency_block = { padding, ordered_dep_blocks ->
          ("dependencies {\n" +
              ordered_dep_blocks.withIndex().collect {
                element, index ->
                  // Add an extra newline if we're into a new keyword:
                  // Not the first line, this line is not "project(...", and the previous line was.
                  def extra_newline = index > 0 && !element.contains("project(") && (element.split(/[ \(]/)[0] != ordered_dep_blocks[index - 1].split(/[ \(]/)[0] || ordered_dep_blocks[index - 1].contains("project("))
                  
                  (extra_newline ? "\n" : "") + padding + " " * spaces_per_tab + element.trim()
              }.join("\n") + "\n" + padding + "}")
        }


        file_as_string.replaceAll(dependency_block_pattern, { original_string, space_padding, matched_deps ->
          space_padding = space_padding ? space_padding : ""
          // We want to break on lines, but keep blocks that are present.
          def dependency_with_blocks = matched_deps
              .findAll(/(?sm)^[^\n\{\}]*(?:${depth_two_block_matcher})?\n/) // Find each dependency
              *.trim()                                                      // trim whitespace
              .findAll { it.trim() }                                        // ignore empty lines
              .sort( {rank_dependency_directive(it) } )                     // and sort

          make_new_dependency_block(space_padding, dependency_with_blocks)
        })
      }
    }
  }

  // If we add more languages to Spotless, add them to 'compileXYZ' trigger below
  afterEvaluate {
    project.tasks['compileJava'].mustRunAfter(spotlessCheck)
    project.tasks['compileJava'].mustRunAfter(spotlessApply)
  }
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import groovy.xml.MarkupBuilder
import org.gradle.util.CollectionUtils


// Projects that do not need module.xml files generated for them. Mostly testing code, projects that
// do not generate jars, and geode-deployment-legacy.
ext.projectsToExclude = ["geode-pulse", "extensions", "geode-assembly", "geode-assembly-test", "geode-concurrency-test",
                         "geode-experimental-driver", "geode-jmh", "geode-lucene-test", "geode-modules-assembly",
                         "geode-modules-test", "geode-pulse-test", "pmd-rules",
                         "static-analysis", "geode-old-versions",
                         "geode-deployment-legacy", "geode-modules", "geode-modules-session",
                         "geode-modules-session-internal", "geode-modules-tomcat7",
                         "geode-modules-tomcat8", "geode-modules-tomcat9", "session-testing-war",
                         "geode-client-bom", "geode-web", "geode-web-management", "geode-web-api",
                         "geode-all-bom", "geode-jboss-extensions", "geode-dunit",
                         "geode-junit", 'geode-deployment-test', 'boms']

ext.testProjectsToInclude = ['geode-dunit', 'geode-junit', 'geode-web-management',
                             'geode-web', 'geode-modules', 'geode-modules-tomcat7',
                             'geode-modules-tomcat8', 'geode-modules-tomcat9', 'geode-modules-test',
                             'geode-modules-session', 'geode-modules-session-internal',
                             'geode-lucene-test', 'geode-assembly']

def thirdPartyDepsNotToGenerate = { String targetConfigurationPrefix ->
  def depsNotToGenerate = []
  def configurations = getTargetConfigurations(['api', 'implementation',
                                                'runtimeOnly', 'jbossModular'], targetConfigurationPrefix)
  rootProject.subprojects.each { project ->

    def dependencies = getDependentProjectsForConfiguration(project, configurations)
    depsNotToGenerate.addAll(dependencies
        .stream()
        .filter { it.ext.has('embed') }
        .map { it.name }.collect())
    dependencies
        .stream()
        .filter { it.ext.has('embed.children') }
        .map { it.ext.get('embed.children') }
        .forEach { children ->
          children.each { child ->
            depsNotToGenerate.add(child)
          }
        }
  }

  depsNotToGenerate
}

private static getTargetConfigurations(configurations, String targetConfigurationPrefix) {
  def processedConfigurations = []
  processedConfigurations.addAll(configurations)
  if (targetConfigurationPrefix.size() > 0)
    configurations.each {
      processedConfigurations.add((targetConfigurationPrefix + it))
    }

  return processedConfigurations
}

ext.generateModuleXmlForProject = { File jar, Project projectToUse, String targetConfigurationPrefix, projectsSeen ->
  def apiProjectDeps = getDependentProjectsForConfiguration(projectToUse, getTargetConfigurations(['api'], targetConfigurationPrefix))
  def allProjectDeps = getDependentProjectsForConfiguration(projectToUse, getTargetConfigurations(['implementation', 'runtimeOnly'], targetConfigurationPrefix))
  def jbossDeps = getDependentProjectsForConfiguration(projectToUse, getTargetConfigurations(['jbossModular'], targetConfigurationPrefix))

  allProjectDeps.addAll(apiProjectDeps)
  allProjectDeps.addAll(jbossDeps)
  // Iterate over runtime classpath dependencies and separate project dependencies from library
  // dependencies.
  def runtimeList = generateDependentProjects(projectToUse, targetConfigurationPrefix)

  //Maybe we will need this map... don't know... let's keep this logic just in case ;)
//  def dependenciesWithDirectChildrenMap = getDependenciesWithDirectChildren(projectToUse, getTargetConfigurations(['implementation', 'runtimeOnly', 'jbossModular', 'api'], targetConfigurationPrefix))

  def depsToNotGenerate = thirdPartyDepsNotToGenerate(targetConfigurationPrefix)

  def geodeAssemblyProj = project(":geode-assembly")
  def configurationTargetPath = targetConfigurationPrefix.size() == 0 ? '/' : "/${targetConfigurationPrefix}ing/"
  def moduleDescriptorsRoot = "${geodeAssemblyProj.buildDir}${configurationTargetPath}moduleDescriptors"
  def namesAndVersion = generateModuleNamesAndVersionsMap(allProjectDeps, runtimeList, depsToNotGenerate, moduleDescriptorsRoot, targetConfigurationPrefix)

  def moduleVersion = version
  allProjectDeps = CollectionUtils.sort(allProjectDeps, new Comparator<Object>() {
    @Override
    int compare(Object o1, Object o2) {
      if (o1 != null && o2 != null) {
        return o1.name.toLowerCase() <=> o2.name.toLowerCase()
      }
      return 0
    }
  })

  if (shouldGenerateModuleXML(projectToUse.name, targetConfigurationPrefix)) {
    def jarName = jar != null ? jar.name : null
    writeModuleXml(projectToUse, jarName, moduleVersion, moduleDescriptorsRoot, allProjectDeps, apiProjectDeps, namesAndVersion, targetConfigurationPrefix)
  }
}

private shouldGenerateModuleXML(moduleName, targetConfigurationPrefix) {
  return !projectsToExclude.contains(moduleName) || (targetConfigurationPrefix.size() > 0 && testProjectsToInclude.contains(moduleName))
}

private Map<String, String[]> generateModuleNamesAndVersionsMap(allProjectDeps, runtimeList, depsToNotGenerate, moduleDescriptorsRoot, targetConfigurationPrefix) {
  Map<String, String[]> namesAndVersion = new HashMap<>()
  runtimeList.each { ResolvedArtifact resolvedArtifact ->
    def moduleVersionIdentifier = resolvedArtifact.getModuleVersion().id
    def artifactName = moduleVersionIdentifier.name
    def artifactVersion = moduleVersionIdentifier.version
    def resource = resolvedArtifact.file.name
    namesAndVersion.put(artifactName, [artifactVersion, resource])
  }
  runtimeList.each { ResolvedArtifact resolvedArtifact ->
    def moduleVersionIdentifier = resolvedArtifact.getModuleVersion().id
    def artifactName = moduleVersionIdentifier.name
    def artifactVersion = moduleVersionIdentifier.version
    def resource = resolvedArtifact.file.name
    if (!depsToNotGenerate.contains(artifactName) && !artifactName.contains('geode-') && artifactName != 'jboss-modules') {
      writeThirdPartyModuleXml(allProjectDeps, namesAndVersion, artifactName, resource, artifactVersion, moduleDescriptorsRoot)
    }
  }
  namesAndVersion
}

static def generateDependentProjects(Project projectToUse, String targetConfigurationPrefix) {
  def runtimeList = []
  projectToUse.configurations.each {
    if (it.name.toLowerCase() == "${targetConfigurationPrefix}runtimeClasspath".toLowerCase() || it.name == "${targetConfigurationPrefix}jbossModular") {
      it.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        runtimeList.add(artifact)
      }
    }
  }
  return runtimeList
}

def static getDependenciesWithDirectChildren(Project projectToUse, List<String> configuration) {
  def depsWithChildren = new HashMap<String, List<ResolvedDependency>>();
  configuration.each { configName ->
    projectToUse.configurations.stream()
        .filter { it.canBeResolved }
        .forEach {
          def childDependencies = depsWithChildren[it.name]
          if (childDependencies == null) {
            childDependencies = []
          }
          childDependencies.addAll(it.getResolvedConfiguration().getFirstLevelModuleDependencies())
          depsWithChildren[it.name] = childDependencies
          createDepsWithChildrenMap(depsWithChildren, childDependencies)
        }
  }
  return depsWithChildren
}

def static getDependentProjectsForConfiguration(Project projectToUse, List<String> configuration) {
  def allProjectDeps = []

  configuration.each { configName ->
    projectToUse.configurations.each {
      if (it.name.toLowerCase() == configName.toLowerCase()) {
        allProjectDeps.addAll(it.getDependencies())
      }
    }
  }
  return allProjectDeps
}

def static createDepsWithChildrenMap(Map<String, List<ResolvedDependency>> depsWithChildren, List<ResolvedDependency> childDependencies) {
  childDependencies.each { childDep ->
    def children = depsWithChildren[childDep.name]
    if (children == null) {
      children = []
      children.addAll(childDep.getChildren())
      depsWithChildren[childDep.name] = children
      createDepsWithChildrenMap(depsWithChildren, children)
    }
  }
}

def writeModuleXml(Project projectToUse, moduleJar, moduleVersion, moduleXMLRootPath,
                   projectDependencies, apiProjectDeps, namesAndVersions,
                   targetConfigurationPrefix) {
  def projectName = projectToUse.name
  def moduleNamePath = projectName.replace('.', File.separator)

  generateAliasModuleXML(moduleXMLRootPath, moduleNamePath)

  def modulePath = "$moduleXMLRootPath/main/$moduleNamePath/$moduleVersion"
  mkdir(modulePath)
  def moduleFile = file("$modulePath/module.xml")
  if (!moduleFile.exists()) {
    moduleFile.withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')
      xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "$projectName:$moduleVersion") {
        xml.'resources' {
          addResourceRoots(projectToUse, moduleJar, moduleNamePath, xml, projectDependencies, namesAndVersions, targetConfigurationPrefix)
        }
        if (projectName == 'geode-core') {
          xml.'main-class'(['name': 'org.apache.geode.distributed.ServerLauncher'])
        } else if (projectName == 'geode-dunit') {
          xml.'main-class'(['name': 'org.apache.geode.test.dunit.internal.ChildVM'])
        }
        xml.'dependencies' {
          xml.'module'(['name': "java.se"])
          xml.'module'(['name': "jdk.unsupported"])
          xml.'module'(['name': "jdk.scripting.nashorn"])
          projectDependencies.each { proj ->
            addModuleDependency(proj, namesAndVersions, apiProjectDeps, xml)
          }
        }
      }
    }
  }
}

def writeThirdPartyModuleXml(List<Dependency> allProjectDeps, namesAndVersion, String moduleName, moduleJar, moduleVersion, moduleXMLRootPath) {
  def moduleNamePath = moduleName.replace('.', File.separator)
  def modulePath = "$moduleXMLRootPath/thirdParty/$moduleNamePath/$moduleVersion"
  mkdir(modulePath)
  def moduleFile = file("$modulePath/module.xml")
  if (!moduleFile.exists()) {
    moduleFile.withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      def optionalDependency = allProjectDeps
          .stream()
          .filter { it.name.equals(moduleName) }
          .findFirst()

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')
      xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "$moduleName:$moduleVersion") {
        xml.'resources' {
          if (moduleJar != null) {
            addResourceRootsForThirdParty(optionalDependency, namesAndVersion, moduleJar, moduleNamePath, xml)
          }
        }
        xml.'dependencies' {
          xml.'module'(['name': "thirdParty", 'services': 'export', 'export': 'true'])
        }
      }
    }
  }
}

private def addModuleDependency(projectToUse, namesAndVersions, apiProjectDeps, xmlBuilder) {
  def projectName = projectToUse.name
  if ((!projectsToExclude.contains(projectName) || testProjectsToInclude.contains(projectName))
      && !projectToUse.ext.has('embed') && projectName != 'jboss-modules') {

    String projectVersion = projectToUse.version
    if (projectVersion == null) {
      if (namesAndVersions[projectName] == null) {
        return
      }
      projectVersion = namesAndVersions[projectName][0]
    }
    def projectNameAndVersion = projectName.contains("geode-") ? projectName : "${projectName}:$projectVersion"
    def attributes = ['name': "${projectNameAndVersion.toString()}"]
    if (projectToUse.ext.has('optional')) {
      attributes.put('optional', projectToUse.ext.optional)
    }
    if (apiProjectDeps.contains(projectToUse)) {
      attributes.put('services', 'export')
      attributes.put('export', 'true')
    } else {
      attributes.put('services', 'import')
    }
    xmlBuilder.'module'(attributes)
  }
}

private def addResourceRoots(Project project, moduleJar, moduleNamePath, xmlBuilder, projectDependencies, namesAndVersions, targetConfigurationPrefix) {
  if (project != null) {
    def absolutePathPrefix = "../../../"
    for (int i = 0; i < moduleNamePath.split(File.separator).length; i++) {
      absolutePathPrefix = absolutePathPrefix.concat("../")
    }
    if (moduleJar != null) {
      String fileLocation = 'lib'
      if (moduleJar.endsWith('.war')) {
        fileLocation = 'tools/Extensions'
        xmlBuilder.'resource-root'(['path': absolutePathPrefix + "$fileLocation/$moduleJar"])
      } else {
        if (targetConfigurationPrefix.size() == 0) {
          xmlBuilder.'resource-root'(['path': absolutePathPrefix + "$fileLocation/$moduleJar"])
        }
      }
    }

    def moduleName = project.name
    if (moduleName.contains('geode-') && targetConfigurationPrefix.size() > 0) {
      addResourceRootsForConfiguration(project, targetConfigurationPrefix, xmlBuilder)
      addResourceRootsForConfiguration(project, 'commonTest', xmlBuilder)
    }
    projectDependencies.stream().filter { it.ext.has('embed') }.each { resource ->
      xmlBuilder.'resource-root'(['path': absolutePathPrefix + 'lib/' + namesAndVersions[resource.name][1]])
    }
  }
}

private addResourceRootsForThirdParty(java.util.Optional<Dependency> optionalDependency, namesAndVersion, moduleJar, moduleNamePath, xmlBuilder) {
  def absolutePathPrefix = "../../../"
  for (int i = 0; i < moduleNamePath.split(File.separator).length; i++) {
    absolutePathPrefix = absolutePathPrefix.concat("../")
  }
  xmlBuilder.'resource-root'(['path': absolutePathPrefix + "lib/$moduleJar"])
  if (optionalDependency.isPresent()) {
    if (optionalDependency.get().name.startsWith("fastutil")) {
    }
    if (optionalDependency.get().ext.has('embed.children')) {
      def embeddedChildren = optionalDependency.get().ext.get('embed.children')
      embeddedChildren.stream().forEach{ child ->
        xmlBuilder.'resource-root'(['path': absolutePathPrefix + "lib/" + namesAndVersion[child][1]])
      }
    }
  }
}

private void addResourceRootsForConfiguration(Project projectToUse, String targetConfigurationPrefix, xmlBuilder) {
  def mainJavaDirectory = projectToUse.projectDir.canonicalFile.toPath().resolve('src').resolve("main").resolve('java').toFile()
  def mainResourcesDirectory = projectToUse.projectDir.canonicalFile.toPath().resolve('src').resolve("main").resolve('resources').toFile()
  if (mainJavaDirectory.exists() && mainJavaDirectory.list().length > 0) {
    xmlBuilder.'resource-root'(['path': projectToUse.buildDir.toPath().resolve('classes').resolve('java').resolve("main").toString()])
  }
  if (mainResourcesDirectory.exists() && mainResourcesDirectory.list().length > 0) {
    xmlBuilder.'resource-root'(['path': projectToUse.buildDir.toPath().resolve('resources').resolve("main").toString()])
  }

  def distributedTestJavaDirectory = projectToUse.projectDir.canonicalFile.toPath().resolve('src').resolve(targetConfigurationPrefix).resolve('java').toFile()
  def distributedTestResourcesDirectory = projectToUse.projectDir.canonicalFile.toPath().resolve('src').resolve(targetConfigurationPrefix).resolve('resources').toFile()
  if (distributedTestJavaDirectory.exists() && distributedTestJavaDirectory.list().length > 0) {
    xmlBuilder.'resource-root'(['path': projectToUse.buildDir.toPath().resolve('classes').resolve('java').resolve(targetConfigurationPrefix).toString()])
  }
  if (distributedTestResourcesDirectory.exists() && distributedTestResourcesDirectory.list().length > 0) {
    xmlBuilder.'resource-root'(['path': projectToUse.buildDir.toPath().resolve('resources').resolve(targetConfigurationPrefix).toString()])
  }
}

private def generateAliasModuleXML(moduleXMLRootPath, moduleNamePath) {
  def aliasModulePath = "$moduleXMLRootPath/main/$moduleNamePath/main"
  mkdir(aliasModulePath)
  file("$aliasModulePath/module.xml").withWriter { writer ->
    // Create MarkupBuilder with 4 space indent
    def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

    xml.doubleQuotes = true
    xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

    xml.'module-alias'('xmlns': 'urn:jboss:module:1.9', 'name': "$moduleNamePath", 'target-name': "$moduleNamePath:$version")
  }
}

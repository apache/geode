/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import groovy.xml.MarkupBuilder
import org.gradle.util.CollectionUtils

// Projects that do not need module.xml files generated for them. Mostly testing code, projects that
// do not generate jars, and geode-deployment-legacy.
ext.projectsToExclude = ["geode-pulse", "extensions", "geode-assembly", "geode-assembly-test", "geode-concurrency-test",
                         "geode-experimental-driver", "geode-jmh", "geode-lucene-test", "geode-modules-assembly",
                         "geode-modules-test", "geode-protobuf-test", "geode-pulse-test", "pmd-rules",
                         "static-analysis", "geode-old-versions",
                         "geode-deployment-legacy", "geode-modules", "geode-modules-session",
                         "geode-modules-session-internal", "geode-modules-tomcat7",
                         "geode-modules-tomcat8", "geode-modules-tomcat9", "session-testing-war",
                         "geode-client-bom", "geode-web", "geode-web-management", "geode-web-api",
                         "geode-all-bom", "geode-jboss-extensions","geode-dunit", "geode-junit", 'geode-deployment-test']

ext.testProjectsToInclude = ['geode-dunit', 'geode-junit']

def thirdPartyDepsNotToGenerate = { String targetConfigurationPrefix ->
  def depsNotToGenerate = []
  def configurations = getTargetConfigurations(['api', 'implementation',
          'runtimeOnly', 'jbossModular'], targetConfigurationPrefix)
  rootProject.subprojects.each { project ->
    depsNotToGenerate.addAll(getDependentProjectsForConfiguration(project, configurations)
            .stream()
            .filter { it.ext.has('should-not-generate') }.map { it.name }.collect())
  }
  depsNotToGenerate
}

private static getTargetConfigurations(configurations, String targetConfigurationPrefix) {
  def processedConfigurations = []
  processedConfigurations.addAll(configurations)
  if(targetConfigurationPrefix.size() > 0)
  configurations.each {
    processedConfigurations.add((targetConfigurationPrefix + it))
  }

  return processedConfigurations
}

ext.generateModuleXmlForProject = { File jar, Project projectToUse, String targetConfigurationPrefix , projectsSeen ->
  def apiProjectDeps = getDependentProjectsForConfiguration(projectToUse, getTargetConfigurations(['api'], targetConfigurationPrefix))
  def allProjectDeps = getDependentProjectsForConfiguration(projectToUse, getTargetConfigurations(['implementation', 'runtimeOnly'], targetConfigurationPrefix))
  def jbossDeps = getDependentProjectsForConfiguration(projectToUse, ['jbossModular'])

  allProjectDeps.addAll(apiProjectDeps)
  allProjectDeps.addAll(jbossDeps)

  def geodeProjects = allProjectDeps.stream().filter{Dependency it -> it.name.startsWith('geode-') && !projectsToExclude.contains(it.name)}.collect()
  geodeProjects.each { Dependency it ->
    if(!projectsSeen.contains(it.name)) {
      projectsSeen.add(it.name)
      rootProject.subprojects.each { subProject ->
        if(subProject.name == it.name) {
          generateModuleXmlForProject(subProject.tasks.getByName('jar').outputs.files.singleFile, subProject, 'distributedTest',projectsSeen)
        }
      }
    }
  }

  // Iterate over runtime classpath dependencies and separate project dependencies from library
  // dependencies.
  def runtimeList = generateDependentProjects(projectToUse, targetConfigurationPrefix)

  def depsToNotGenerate = thirdPartyDepsNotToGenerate(targetConfigurationPrefix)

  def sourceJarPath = null
  if (jar != null && jar.name.endsWith(".jar")) {
    sourceJarPath = "lib/${jar.name}"
  }

  def geodeAssemblyProj = project(":geode-assembly")
  def configurationTargetPath = targetConfigurationPrefix.size() == 0? '/' : "/${targetConfigurationPrefix}ing/"
  def moduleDescriptorsRoot = "${geodeAssemblyProj.buildDir}${configurationTargetPath}moduleDescriptors"
  def namesAndVersion = generateModuleNamesAndVersionsMap(runtimeList, depsToNotGenerate, moduleDescriptorsRoot, targetConfigurationPrefix)

  def moduleName = projectToUse.name
  def moduleVersion = version
  allProjectDeps = CollectionUtils.sort(allProjectDeps, new Comparator<Object>() {
    @Override
    int compare(Object o1, Object o2) {
      if (o1 != null && o2 != null) {
        return o1.name.toLowerCase() <=> o2.name.toLowerCase()
      }
      return 0
    }
  })
  if (shouldGenerateModuleXML(moduleName, targetConfigurationPrefix)) {
    writeModuleXml(moduleName, moduleVersion, moduleDescriptorsRoot, "main", sourceJarPath, allProjectDeps, apiProjectDeps, namesAndVersion, targetConfigurationPrefix)
  }
}

private shouldGenerateModuleXML(moduleName, targetConfigurationPrefix) {
  return !projectsToExclude.contains(moduleName) || (targetConfigurationPrefix.size() > 0 && testProjectsToInclude.contains(moduleName))
}

private Map<String, String[]> generateModuleNamesAndVersionsMap(runtimeList, depsToNotGenerate, moduleDescriptorsRoot, targetConfigurationPrefix) {
  Map<String, String[]> namesAndVersion = new HashMap<>()
  runtimeList.each { ResolvedArtifact dependency ->
    def moduleVersionIdentifier = dependency.getModuleVersion().id
    def artifactName = moduleVersionIdentifier.name
    def artifactVersion = moduleVersionIdentifier.version
    def resource = dependency.file.name
    namesAndVersion.put(artifactName, [artifactVersion, resource])
    if (!depsToNotGenerate.contains(artifactName)) {
      writeModuleXml(artifactName, artifactVersion, moduleDescriptorsRoot, "thirdParty", "lib/$resource", [], [], null, targetConfigurationPrefix)
    }
  }
  namesAndVersion
}

def generateDependentProjects(Project projectToUse, String targetConfigurationPrefix) {
  def runtimeList = []
  projectToUse.configurations.each {
    if (it.name.toLowerCase() == "${targetConfigurationPrefix}runtimeClasspath".toLowerCase() || it.name == 'jbossModular') {
      it.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        def moduleVersionIdentifier = artifact.getModuleVersion().id
        if (!moduleVersionIdentifier.name.contains('geode-')) {
          runtimeList.add(artifact)
        }
      }
    }
  }
  return runtimeList
}

def static getDependentProjectsForConfiguration(Project projectToUse, List<String> configuration) {
  def allProjectDeps = []
  configuration.each { configName ->
    projectToUse.configurations.each {
      if (it.name.toLowerCase() == configName.toLowerCase()) {
        allProjectDeps.addAll(it.getDependencies())
      }
    }
  }
  return allProjectDeps
}

def writeModuleXml(moduleName, moduleVersion, moduleXMLRootPath,
                   moduleClassification, sourceJarPath, projectDependencies,
                   apiProjectDeps, namesAndVersions, targetConfigurationPrefix) {
  def moduleNamePath = moduleName.replace('.', File.separator)
  if (moduleClassification == "main") {
    generateAliasModuleXML(moduleXMLRootPath, moduleClassification, moduleNamePath)
  }
  def modulePath = "$moduleXMLRootPath/$moduleClassification/$moduleNamePath/$moduleVersion"
  mkdir(modulePath)

  file("$modulePath/module.xml").withWriter { writer ->
    // Create MarkupBuilder with 4 space indent
    def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

    xml.doubleQuotes = true
    xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')
    xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "$moduleName:$moduleVersion") {
      xml.'resources' {
        addResourceRoots(sourceJarPath, moduleNamePath, xml, projectDependencies, namesAndVersions, targetConfigurationPrefix)
      }
      if (moduleName == 'geode-core') {
        xml.'main-class'(['name': 'org.apache.geode.distributed.ServerLauncher'])
      } else if(moduleName == 'geode-dunit') {
        xml.'main-class'(['name': 'org.apache.geode.test.dunit.internal.ChildVM'])
      }
      xml.'dependencies' {
        xml.'module'(['name': "java.se"])
        if (moduleClassification == "thirdParty") {
          xml.'module'(['name': "thirdParty", 'services': 'export', 'export': 'true'])
        }
        projectDependencies.each { project ->
          addModuleDependency(project, namesAndVersions, apiProjectDeps, xml)
        }
      }
    }
  }
}

private def addModuleDependency(project, namesAndVersions, apiProjectDeps, xmlBuilder) {
  if (!projectsToExclude.contains(project.name) && !project.ext.has('should-not-generate')) {
    String projectVersion = project.version
    if (projectVersion == null) {
      if(namesAndVersions[project.name] == null) {
        return
      }
      projectVersion = namesAndVersions[project.name][0]
    }
    def projectNameAndVersion = project.name.contains("geode-") ? project.name : "$project.name:$projectVersion"
    def attributes = ['name': "${projectNameAndVersion.toString()}"]
    if (project.ext.has('optional')) {
      attributes.put('optional', project.ext.optional)
    }
    if (apiProjectDeps.contains(project)) {
      attributes.put('services', 'export')
      attributes.put('export', 'true')
    } else {
      attributes.put('services', 'import')
    }
    xmlBuilder.'module'(attributes)
  }
}

private def addResourceRoots(sourceJarPath, moduleNamePath, xmlBuilder, projectDependencies, namesAndVersions, targetConfigurationPrefix) {
  if (sourceJarPath != null) {
    def absolutePathPrefix = "../../../"
    for (int i = 0; i < moduleNamePath.split(File.separator).length; i++) {
      absolutePathPrefix = absolutePathPrefix.concat("../")
    }
    xmlBuilder.'resource-root'(['path': absolutePathPrefix + sourceJarPath])
    if (moduleNamePath.contains(project.name) && moduleNamePath.contains('geode-') && targetConfigurationPrefix.size() > 0) {
      addResourceRootsForConfiguration(targetConfigurationPrefix, xmlBuilder)
    }
    projectDependencies.stream().filter { it.ext.has('should-not-generate') }.each { resource ->
      xmlBuilder.'resource-root'(['path': absolutePathPrefix + 'lib/' + namesAndVersions[resource.name][1]])
    }
  }
}

private void addResourceRootsForConfiguration(String targetConfigurationPrefix, xmlBuilder) {
  def distributedTestJavaDirectory = project.projectDir.canonicalFile.toPath().resolve('src').resolve(targetConfigurationPrefix).resolve('java').toFile()
  def distributedTestResourcesDirectory = project.projectDir.canonicalFile.toPath().resolve('src').resolve(targetConfigurationPrefix).resolve('resources').toFile()
  if (distributedTestJavaDirectory.exists() && distributedTestJavaDirectory.list().length > 0) {
    xmlBuilder.'resource-root'(['path': project.buildDir.toPath().resolve('classes').resolve('java').resolve(targetConfigurationPrefix).toString()])
  }
  if (distributedTestResourcesDirectory.exists() && distributedTestResourcesDirectory.list().length > 0) {
    xmlBuilder.'resource-root'(['path': project.buildDir.toPath().resolve('resources').resolve(targetConfigurationPrefix).toString()])
  }
}

private def generateAliasModuleXML(moduleXMLRootPath, moduleClassification, moduleNamePath) {
  def aliasModulePath = "$moduleXMLRootPath/$moduleClassification/$moduleNamePath/main"
  mkdir(aliasModulePath)
  file("$aliasModulePath/module.xml").withWriter { writer ->
    // Create MarkupBuilder with 4 space indent
    def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

    xml.doubleQuotes = true
    xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

    xml.'module-alias'('xmlns': 'urn:jboss:module:1.9', 'name': "$moduleNamePath", 'target-name': "$moduleNamePath:$version")
  }
}

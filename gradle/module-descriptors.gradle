/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional information regarding
 * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

import groovy.xml.MarkupBuilder

ext.generateProjectRuntimeList = { jar ->
  def apiProjectDeps = ext.getDependentProjectsForConfiguration(['api'])
  def allProjectDeps = ext.getDependentProjectsForConfiguration(['implementation', 'runtimeOnly', 'compileOnly'])

  allProjectDeps.addAll(apiProjectDeps)
  // Iterate over runtime classpath dependencies and separate project dependencies from library
  // dependencies.
  def (projectDependencies, runtimeList) = ext.generateDependentProjects(allProjectDeps)

  if (jar.name.equals("jar")) {
    ext.createModuleXml(jar.archiveFileName.get(), projectDependencies, apiProjectDeps, runtimeList)
  }
  runtimeList
}

ext.generateDependentProjects = { allProjectDeps ->
  def runtimeList = []
  def projectDependencies = []
  allProjectDeps.each { dependency ->
    if (dependency instanceof ProjectDependency) {
      def platformAttribute = Attribute.of("org.gradle.category", Category.class)
      def foundAttribute = dependency.attributes.getAttribute(platformAttribute)
      if (foundAttribute == null) {
        projectDependencies.add(dependency)
      } else if ('platform'.equals(foundAttribute)) {
        projectDependencies.add(dependency)
      }
    } else {
      project.configurations.runtimeClasspath.files(dependency).each { depJar ->
        runtimeList.add(depJar.name)
      }
    }
  }

  [projectDependencies, runtimeList.unique().sort()]
}

ext.getDependentProjectsForConfiguration = { configuration ->
  def allProjectDeps = []
  configuration.each { conf ->
    allProjectDeps.addAll(project.configurations.getByName(conf).getDependencies())
  }
  allProjectDeps
}

// Projects that do not need module.xml files generated for them. Mostly, testing code and geode-deployment-legacy.
def projectsToExclude = ["geode-pulse", "extensions", "geode-assembly", "geode-assembly-test", "geode-concurrency-test",
                         "geode-experimental-driver", "geode-jmh", "geode-lucene-test", "geode-modules-assembly",
                         "geode-modules-test", "geode-protobuf-test", "geode-pulse-test", "pmd-rules",
                         "static-analysis", "geode-dunit", "geode-old-versions", "geode-junit", "geode-deployment-legacy"]

ext.createModuleXml = { sourceJar, projectDependencies, apiProjectDeps, resourceDependencies ->
  def geodeAssemblyProj = project(":geode-assembly")
  def moduleDescriptorsRoot = "${geodeAssemblyProj.buildDir}/moduleDescriptors"
  mkdir(moduleDescriptorsRoot)
  def moduleName = project.name
  if (!projectsToExclude.contains(moduleName)) {
    def modulePath = "$moduleDescriptorsRoot/$moduleName/$version"
    mkdir(modulePath)

    file("$modulePath/module.xml").withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

      xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "$moduleName:$version") {
        xml.'resources' {
          if (sourceJar != null) {
            xml.'resource-root'(['path': "../../../lib/$sourceJar"])
          }
          resourceDependencies.each { resource ->
            xml.'resource-root'(['path': "../../../lib/$resource"])
          }
        }
        if (moduleName == 'geode-core') {
          xml.'main-class'(['name': 'org.apache.geode.distributed.ServerLauncher'])
        }
        xml.'dependencies' {
          if(moduleName.equals('geode-core')) {
            xml.'module'(['name':'linking', 'services':'import']) {
            xml.'imports' {
              xml.'exclude-set' {
                xml.'path'('name': 'org.springframework')
              }
            }}
          }
          xml.'module'(['name': "java.se"])
          projectDependencies.each { ProjectDependency project ->

            def attributes = ['name': "$project.name:$project.version"]
            if (project.ext.has('optional')) {
              attributes.put('optional', project.ext.optional)
            }
            if (apiProjectDeps.contains(project)) {
              attributes.put('services', 'export')
              attributes.put('export', 'true')
            } else {
              attributes.put('services', 'import')
            }
            xml.'module'(attributes)
          }
        }
      }
    }
  }
}

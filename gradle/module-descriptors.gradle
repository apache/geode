/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional information regarding
 * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

import groovy.xml.MarkupBuilder

ext.generateThirdPartyModuleXML = { ->
  def geodeAssemblyProj = project(":geode-assembly")
  def moduleDescriptorsRoot = "${geodeAssemblyProj.buildDir}/moduleDescriptors"

  def thirdPartyRoot = file(moduleDescriptorsRoot + "/thirdParty")

  def modulePath = "$moduleDescriptorsRoot/thirdParty/$version"
  mkdir(modulePath)

  file("$modulePath/module.xml").withWriter { writer ->
    // Create MarkupBuilder with 4 space indent
    def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

    xml.doubleQuotes = true
    xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

    xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "thirdParty:$version") {
      xml.'dependencies' {
        thirdPartyRoot.listFiles().each {
          def moduleName
          def moduleVersion
          if (it.isDirectory()) {
            moduleName = it.name
            it.listFiles().each {
              moduleVersion = it.name
              xml.'module'(['name': "$moduleName:$moduleVersion", 'services': 'export', 'export': 'true'])
            }
          }
        }
      }
    }
  }
}

ext.generateProjectRuntimeList = { jar ->
  def apiProjectDeps = ext.getDependentProjectsForConfiguration(['api'])
  def allProjectDeps = ext.getDependentProjectsForConfiguration(['implementation', 'runtimeOnly', 'compileOnly'])

  allProjectDeps.addAll(apiProjectDeps)
  // Iterate over runtime classpath dependencies and separate project dependencies from library
  // dependencies.
  def (projectDependencies, runtimeList) = ext.generateDependentProjects(allProjectDeps)

  def sourceJarPath;
  if (jar.name.equals("jar")) {
    if (jar.archiveFileName.get() != null) {
      sourceJarPath = "../../../lib/${jar.archiveFileName.get()}"
    }
    ext.createModuleXml(sourceJarPath, projectDependencies, apiProjectDeps, runtimeList)
  }
  runtimeList
}

ext.generateDependentProjects = { allProjectDeps ->
  def runtimeList = []
  def projectDependencies = []
  allProjectDeps.each { dependency ->
    if (dependency instanceof ProjectDependency) {
      def platformAttribute = Attribute.of("org.gradle.category", Category.class)
      def foundAttribute = dependency.attributes.getAttribute(platformAttribute)
      if (foundAttribute == null) {
        projectDependencies.add(dependency)
      } else if ('platform'.equals(foundAttribute)) {
        projectDependencies.add(dependency)
      }
    } else {
      project.configurations.runtimeClasspath.files(dependency).each { depJar ->
        runtimeList.add(depJar.name)
      }
    }
  }

  [projectDependencies, runtimeList.unique().sort()]
}

ext.getDependentProjectsForConfiguration = { configuration ->
  def allProjectDeps = []
  configuration.each { conf ->
    allProjectDeps.addAll(project.configurations.getByName(conf).getDependencies())
  }
  allProjectDeps
}

// Projects that do not need module.xml files generated for them. Mostly, testing code and geode-deployment-legacy.
def projectsToExclude = ["geode-pulse", "extensions", "geode-assembly", "geode-assembly-test", "geode-concurrency-test",
                         "geode-experimental-driver", "geode-jmh", "geode-lucene-test", "geode-modules-assembly",
                         "geode-modules-test", "geode-protobuf-test", "geode-pulse-test", "pmd-rules",
                         "static-analysis", "geode-dunit", "geode-old-versions", "geode-junit",
                         "geode-deployment-legacy", "geode-modules", "geode-modules-session",
                         "geode-modules-session-internal", "geode-modules-tomcat7",
                         "geode-modules-tomcat8", "geode-modules-tomcat9"]

ext.createModuleXml = { sourceJarPath, projectDependencies, apiProjectDeps, resourceDependencies ->
  def moduleName = project.name
  def moduleVersion = version
  def geodeAssemblyProj = project(":geode-assembly")
  def moduleDescriptorsRoot = "${geodeAssemblyProj.buildDir}/moduleDescriptors"
  writeModuleXml(moduleName, moduleVersion, moduleDescriptorsRoot, sourceJarPath, projectDependencies, apiProjectDeps, resourceDependencies)
}

ext.writeModuleXml = { moduleName, moduleVersion, moduleXMLPath, sourceJarPath, projectDependencies, apiProjectDeps, resourceDependencies ->
  mkdir(moduleXMLPath)
  if (!projectsToExclude.contains(moduleName)) {
    def modulePath = "$moduleXMLPath/$moduleName/$moduleVersion"
    mkdir(modulePath)

    file("$modulePath/module.xml").withWriter { writer ->
      // Create MarkupBuilder with 4 space indent
      def xml = new MarkupBuilder(new IndentPrinter(writer, "    ", true))

      xml.doubleQuotes = true
      xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')

      xml.'module'('xmlns': 'urn:jboss:module:1.9', 'name': "$moduleName:$moduleVersion") {
        xml.'resources' {
          if (sourceJarPath != null) {
            xml.'resource-root'(['path': sourceJarPath])
          }
        }
        if (moduleName == 'geode-core') {
          xml.'main-class'(['name': 'org.apache.geode.distributed.ServerLauncher'])
        }
        xml.'dependencies' {
          if (moduleXMLPath.contains("thirdParty")) {
            xml.'module'(['name': 'thirdParty', 'services': 'export', 'export': 'true'])
          }
          if (moduleName.equals('geode-core')) {
            xml.'module'(['name': 'linking', 'services': 'import']) {
              xml.'imports' {
                xml.'exclude-set' {
                  xml.'path'('name': 'org.springframework')
                }
              }
            }
          }
          xml.'module'(['name': "java.se"])
          resourceDependencies.each { resource ->
            def endOfArtifactName = resource.lastIndexOf("-")
            def startOfExtension = resource.indexOf(".jar")
            def artifactName = resource.substring(0, endOfArtifactName)
            def artifactVersion = resource.substring(endOfArtifactName + 1, startOfExtension)
            def attributes = ['name': "$artifactName:$artifactVersion", 'services': 'import']
            xml.'module'(attributes)
            ext.writeModuleXml(artifactName, artifactVersion, moduleXMLPath + "/thirdParty", "../../../../lib/$resource", [], [], [])
          }
          projectDependencies.each { ProjectDependency project ->

            def attributes = ['name': "$project.name:$project.version"]
            if (project.ext.has('optional')) {
              attributes.put('optional', project.ext.optional)
            }
            if (apiProjectDeps.contains(project)) {
              attributes.put('services', 'export')
              attributes.put('export', 'true')
            } else {
              attributes.put('services', 'import')
            }
            xml.'module'(attributes)
          }
        }
      }
    }
  }
}

/*=========================================================================
 * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
 * This product is protected by U.S. and international copyright
 * and intellectual property laws. Pivotal products are covered by
 * more patents listed at http://www.pivotal.io/patents.
 *=========================================================================
 */

package com.gemstone.gemfire.internal.i18n;

import com.gemstone.gemfire.i18n.StringIdImpl;
import com.gemstone.org.jgroups.util.StringId;


/**
 * This interface defines all of the {@link StringId} that
 * are used for internationalization, aka i18n.
 *
 * <b>No code other than StringId creation belongs here</b>
 *
 * It is an interface so that classes that need to access a StringId
 * can simply add <code>implements LocalizedStrings</code> and then
 * access the StringIds directly
 * <code>
 * public class SomeClass implements LocalizedStrings {
 *   public logStuff() {
 *     getLogger().info(SomeClass_SOME_STRINGID);
 *  }
 * }
 * </code>
 *
 * @author kbanks
 * @since 6.0
 *
 */
public class LocalizedStrings extends ParentLocalizedStrings {
  public static final StringId DataSerializer_NO_INSTANTIATOR_HAS_BEEN_REGISTERED_FOR_CLASS_WITH_ID_0 = new StringIdImpl(3413, "No Instantiator has been registered for class with id  {0}");
  public static final StringId DataSerializer_COULD_NOT_INSTANTIATE_AN_INSTANCE_OF_0 = new StringIdImpl(3414, "Could not instantiate an instance of  {0}");
  public static final StringId DataSerializer_WHILE_INSTANTIATING_AN_INSTANCE_OF_0 = new StringIdImpl(3415, "While instantiating an instance of  {0}");
  public static final StringId Instantiator_CANNOT_REGISTER_A_NULL_CLASS = new StringIdImpl(3416, "Cannot register a null class.");
  public static final StringId AdminDistributedSystemImpl_WHILE_WAITING_FOR_FUTURE = new StringIdImpl(3417, "While waiting for Future");
  public static final StringId AdminDistributedSystemImpl_THIS_ADMINDISTRIBUTEDSYSTEM_IS_ALREADY_CONNECTED = new StringIdImpl(3418, "This AdminDistributedSystem is already connected.");
  public static final StringId AdminDistributedSystemImpl_ONLY_ONE_ADMINDISTRIBUTEDSYSTEM_CONNECTION_CAN_BE_MADE_AT_ONCE = new StringIdImpl(3419, "Only one AdminDistributedSystem connection can be made at once.");
  public static final StringId AdminDistributedSystemImpl_AN_ADMINEXCEPTION_WAS_THROWN_WHILE_GETTING_THE_GEMFIRE_HEALTH = new StringIdImpl(3420, "An AdminException was thrown while getting the GemFire health.");
  public static final StringId DistributedSystemConfigImpl_ENTITY_CONFIGURATION_XML_FILE_0_DOES_NOT_EXIST = new StringIdImpl(3421, "Entity configuration XML file \"{0}\" does not exist");
  public static final StringId ManagedEntityConfigXml_PUBLIC_ID_0_SYSTEM_ID_1 = new StringIdImpl(3422, "Public Id: \"{0}\" System Id: \"{1}\"");
  public static final StringId ManagedEntityConfigXmlGenerator_AN_ADMINEXCEPTION_WAS_THROWN_WHILE_GENERATING_XML = new StringIdImpl(3423, "An AdminException was thrown while generating XML.");
  public static final StringId ManagedEntityConfigXmlParser_WHILE_PARSING_XML = new StringIdImpl(3424, "While parsing XML");
  public static final StringId ManagedEntityConfigXmlParser_MALFORMED_INTEGER_0 = new StringIdImpl(3425, "Malformed integer \"{0}\"");
  public static final StringId SystemMemberBridgeServerImpl_UNEXPECTED_EXCEPTION_WHILE_REFRESHING = new StringIdImpl(3426, "Unexpected exception while refreshing");
  public static final StringId AgentImpl_WHILE_CREATING_OBJECTNAME_0 = new StringIdImpl(3427, "While creating ObjectName:  {0}");
  public static final StringId AgentImpl_COULD_NOT_OPEN_LOG_FILE_0 = new StringIdImpl(3428, "Could not open log file \"{0}\"");
  public static final StringId GemFireHealthJmxImpl_WHILE_GETTING_THE_DISTRIBUTEDSYSTEMHEALTHCONFIG = new StringIdImpl(3429, "While getting the DistributedSystemHealthConfig");
  public static final StringId GemFireHealthJmxImpl_WHILE_GETTING_THE_GEMFIREHEALTHCONFIG = new StringIdImpl(3430, "While getting the GemFireHealthConfig");
  public static final StringId AbstractDistributionConfig_INVALID_LOCATOR_0_THE_PORT_1_WAS_NOT_GREATER_THAN_ZERO_AND_LESS_THAN_65536 = new StringIdImpl(3431, "Invalid locator \"{0}\". The port {1} was not greater than zero and less than 65,536.");
  public static final StringId DistributionManager_INTERRUPTED_WHILE_WAITING_FOR_FIRST_STARTUPRESPONSEMESSAGE = new StringIdImpl(3432, "Interrupted while waiting for first StartupResponseMessage");
  public static final StringId DistributionManager_RECEIVED_NO_CONNECTION_ACKNOWLEDGMENTS_FROM_ANY_OF_THE_0_SENIOR_CACHE_MEMBERS_1 = new StringIdImpl(3433, "Received no connection acknowledgments from any of the  {0}  senior cache members:  {1}");
  public static final StringId MessageFactory_AN_INSTANTIATIONEXCEPTION_WAS_THROWN_WHILE_INSTANTIATING_A_0 = new StringIdImpl(3434, "An InstantiationException was thrown while instantiating a  {0}");
  public static final StringId MessageFactory_COULD_NOT_ACCESS_ZEROARG_CONSTRUCTOR_OF_0 = new StringIdImpl(3435, "Could not access zero-arg constructor of  {0}");
  public static final StringId JGroupMembershipManager_AN_IOEXCEPTION_WAS_THROWN_WHILE_OPENING_0 = new StringIdImpl(3436, "An IOException was thrown while opening \"{0}\"");
  public static final StringId JGroupMembershipManager_AN_EXCEPTION_WAS_THROWN_WHILE_READING_JGROUPS_CONFIG = new StringIdImpl(3437, "An Exception was thrown while reading JGroups config.");
  public static final StringId JGroupMembershipManager_AN_EXCEPTION_WAS_THROWN_WHILE_CONNECTING_TO_JGROUPS = new StringIdImpl(3438, "An Exception was thrown while connecting to Jgroups.");
  public static final StringId InternalInstantiator_CANNOT_UNREGISTER_A_NULL_CLASS = new StringIdImpl(3439, "Cannot unregister a null class");
  public static final StringId StatisticDescriptorImpl_THE_STATISTIC_0_WITH_ID_1_IS_OF_TYPE_2_AND_IT_WAS_EXPECTED_TO_BE_AN_INT = new StringIdImpl(3440, "The statistic  {0}  with id  {1}  is of type  {2}  and it was expected to be an int.");
  public static final StringId StatisticDescriptorImpl_THE_STATISTIC_0_WITH_ID_1_IS_OF_TYPE_2_AND_IT_WAS_EXPECTED_TO_BE_A_DOUBLE = new StringIdImpl(3441, "The statistic  {0}  with id  {1}  is of type  {2}  and it was expected to be a double.");
  public static final StringId StatisticsTypeXml_SAX_ERROR_WHILE_WORKING_WITH_XML = new StringIdImpl(3442, "SAX error while working with XML");
  public static final StringId StatisticsTypeXml_SAX_FATAL_ERROR_WHILE_WORKING_WITH_XML = new StringIdImpl(3443, "SAX fatal error while working with XML");
  public static final StringId AdminRequest_A_REPLYEXCEPTION_WAS_THROWN_WHILE_WAITING_FOR_A_REPLY = new StringIdImpl(3444, "A ReplyException was thrown while waiting for a reply.");
  public static final StringId AdminWaiters_ADMINISTRATION_REQUEST_0_SENT_TO_1_TIMED_OUT_AFTER_2_SECONDS = new StringIdImpl(3445, "Administration request  {0}  sent to  {1}  timed out after  {2}  seconds.");
  public static final StringId RemoteAlert_INVALIDATE_TIMESTAMP_0 = new StringIdImpl(3446, "Invalidate timestamp:  {0}");
  public static final StringId RemoteGemFireVM_AN_EXCEPTION_WAS_THROWN_WHILE_CREATING_VM_ROOT_REGION_0 = new StringIdImpl(3447, "An Exception was thrown while creating VM root region \"{0}\"");
  public static final StringId RemoteGemFireVM_WHILE_CREATING_SUBREGION_0_OF_1 = new StringIdImpl(3448, "While creating subregion \"{0}\" of \"{1}\"");
  public static final StringId RemoteGfManagerAgent_AN_EXCEPUTIONEXCEPTION_WAS_THROWN_WHILE_WAITING_FOR_FUTURE = new StringIdImpl(3449, "An ExceputionException was thrown while waiting for Future.");
  public static final StringId AbstractLRURegionMap_INCREMENT_TO_LRU_DELTA_WITHOUT_USE_OF_PRIOR_VALUE_PUT_AND_REPLACE_CALLS_MUST_BE_FOLLOWED_BY_A_CALL_TO_LRUUPDATECALLBACK_DELTA_IS_0 = new StringIdImpl(3450, "Increment to lru delta without use of prior value, put and replace calls must be followed by a call to lruUpdateCallback. (delta is  {0} ).");
  public static final StringId BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1_FOR_BUCKET_2 = new StringIdImpl(3451, "Cannot change from  {0}  to  {1}  for bucket  {2}");
  public static final StringId GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2 = new StringIdImpl(3452, "{0} : Exception during processing batch  {1}  on connection  {2}");
  public static final StringId GemFireCache_COULD_NOT_CONVERT_XML_FILE_0_TO_AN_URL = new StringIdImpl(3453, "Could not convert XML file \"{0}\" to an URL.");
  public static final StringId GemFireCache_WHILE_OPENING_CACHE_XML_0_THE_FOLLOWING_ERROR_OCCURRED_1 = new StringIdImpl(3454, "While opening Cache XML \"{0}\" the following error occurred \"{1}\"");
  public static final StringId Oplog_TRIED_TO_SEEK_TO_0_BUT_THE_FILE_LENGTH_IS_1_OPLOG_FILE_OBJECT_USED_FOR_READING_2 = new StringIdImpl(3455, "Tried to seek to {0}, but the file length is {1}. Oplog File object used for reading={2}");
  public static final StringId PartitionedRegion_ATTEMPT_TO_ACQUIRE_PRIMARY_NODE_FOR_WRITE_ON_BUCKET_0_TIMED_OUT_IN_1_MS_CURRENT_REDUNDANCY_2_DOES_NOT_SATISFY_MINIMUM_3 = new StringIdImpl(3456, "Attempt to acquire primary node for write on bucket  {0}  timed out in  {1}  ms. Current redundancy [ {2} ] does not satisfy minimum [ {3} ]");
  public static final StringId PartitionedRegion_ATTEMPT_TO_ACQUIRE_PRIMARY_NODE_FOR_READ_ON_BUCKET_0_TIMED_OUT_IN_1_MS_CURRENT_REDUNDANCY_2_DOES_NOT_SATISFY_MINIMUM_3 = new StringIdImpl(3457, "Attempt to acquire primary node for read on bucket  {0}  timed out in  {1}  ms. Current redundancy [ {2} ] does not satisfy minimum [ {3} ]");
  public static final StringId PartitionedRegion_ATTEMPT_TO_ACQUIRE_PRIMARY_NODE_FOR_READ_ON_BUCKET_0_TIMED_OUT_IN_1_MS = new StringIdImpl(3458, "Attempt to acquire primary node for read on bucket  {0}  timed out in  {1}  ms");

  public static final StringId RegionAttributesCreation_CONCURRENCYCHECKSENABLED_IS_NOT_THE_SAME = new StringIdImpl(3459, "ConcurrencyChecksEnabled is not the same");
  public static final StringId RegionAttributesCreation_ENABLE_OFF_HEAP_MEMORY_IS_NOT_THE_SAME = new StringIdImpl(3460, "EnableOffHeapMemory is not the same");

  public static final StringId ProxyRegionMap_NO_ENTRY_SUPPORT_ON_REGIONS_WITH_DATAPOLICY_0 = new StringIdImpl(3461, "No entry support on regions with DataPolicy  {0}");
  public static final StringId SearchLoadAndWriteProcessor_WHILE_INVOKING_A_REMOTE_NETLOAD_0 = new StringIdImpl(3462, "While invoking a remote netLoad:  {0}");
  public static final StringId SearchLoadAndWriteProcessor_WHILE_INVOKING_A_REMOTE_NETWRITE_0 = new StringIdImpl(3463, "While invoking a remote netWrite:  {0}");
  public static final StringId SearchLoadAndWriteProcessor_TIMED_OUT_WHILE_DOING_NETSEARCHNETLOADNETWRITE_PROCESSORID_0_KEY_IS_1 = new StringIdImpl(3464, "Timed out while doing netsearch/netload/netwrite processorId= {0}  Key is  {1}");
  public static final StringId SearchLoadAndWriteProcessor_TIMEOUT_DURING_NETSEARCHNETLOADNETWRITE_DETAILS_0 = new StringIdImpl(3465, "Timeout during netsearch/netload/netwrite. Details:  {0}");
  public static final StringId TXCommitMessage_THESE_REGIONS_EXPERIENCED_RELIABILITY_FAILURE_DURING_DISTRIBUTION_OF_THE_OPERATION_0 = new StringIdImpl(3466, "These regions experienced reliability failure during distribution of the operation:  {0}");
  public static final StringId TXCommitMessage_COMMIT_OPERATION_GENERATED_ONE_OR_MORE_EXCEPTIONS_FROM_0 = new StringIdImpl(3467, "Commit operation generated one or more exceptions from  {0}");
  public static final StringId BucketSizeMessage_BUCKETSIZERESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION_FORCING_REATTEMPT = new StringIdImpl(3468, "BucketSizeResponse got remote CacheClosedException; forcing reattempt.");
  public static final StringId BucketSizeMessage_BUCKETSIZERESPONSE_GOT_REMOTE_REGION_DESTROYED_FORCING_REATTEMPT = new StringIdImpl(3469, "BucketSizeResponse got remote Region destroyed; forcing reattempt.");
  public static final StringId ContainsKeyValueMessage_CONTAINSKEYVALUERESPONSE_GOT_REMOTE_CACHEEXCEPTION_FORCING_REATTEMPT = new StringIdImpl(3470, "ContainsKeyValueResponse got remote CacheException; forcing reattempt.");
  public static final StringId DumpB2NRegion_B2NRESPONSE_GOT_REMOTE_CACHEEXCEPTION_THROWING_FORCEREATTEMPTEXCEPTION = new StringIdImpl(3471, "B2NResponse got remote CacheException, throwing ForceReattemptException.");
  public static final StringId FetchEntriesMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CANCELLATION_FORCING_REATTEMPT = new StringIdImpl(3472, "FetchKeysResponse got remote cancellation; forcing reattempt.");
  public static final StringId FetchEntryMessage_FETCHENTRYRESPONSE_GOT_REMOTE_CACHEEXCEPTION_FORCING_REATTEMPT = new StringIdImpl(3473, "FetchEntryResponse got remote CacheException; forcing reattempt.");
  public static final StringId FetchKeysMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION_FORCING_REATTEMPT = new StringIdImpl(3474, "FetchKeysResponse got remote CacheClosedException; forcing reattempt.");
  public static final StringId GetMessage_UNABLE_TO_DESERIALIZE_VALUE_IOEXCEPTION = new StringIdImpl(3475, "Unable to deserialize value (IOException)");
  public static final StringId GetMessage_UNABLE_TO_DESERIALIZE_VALUE_CLASSNOTFOUNDEXCEPTION = new StringIdImpl(3476, "Unable to deserialize value (ClassNotFoundException)");
  public static final StringId RemoteOperationMessage_0_COULD_NOT_FIND_REGION_1 = new StringIdImpl(3477, "{0} : could not find region {1}");
  public static final StringId ManageBucketMessage_NODERESPONSE_GOT_REMOTE_CANCELLATION_THROWING_PARTITIONEDREGIONCOMMUNICATION_EXCEPTION = new StringIdImpl(3478, "NodeResponse got remote cancellation, throwing PartitionedRegionCommunication Exception.");
  public static final StringId ManageBucketMessage_NODERESPONSE_GOT_LOCAL_DESTROY_ON_THE_PARTITIONREGION_THROWING_FORCEREATTEMPTEXCEPTION = new StringIdImpl(3479, "NodeResponse got local destroy on the PartitionRegion , throwing ForceReattemptException.");
  public static final StringId PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION = new StringIdImpl(3480, "PartitionResponse got remote CacheClosedException");
  public static final StringId PrimaryRequestMessage_NODERESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION_THROWING_PARTITIONEDREGIONCOMMUNICATION_EXCEPTION = new StringIdImpl(3481, "NodeResponse got remote CacheClosedException, throwing PartitionedRegionCommunication Exception.");
  public static final StringId ConnectionImpl_INVALID_PING_REPLY_WITH_EXPECTED_TRANSACTION_0_AND_ACTUAL_TRANSACTION_1 = new StringIdImpl(3482, "Invalid ping reply with expected transaction  {0}  and actual transaction  {1}");
  public static final StringId ConnectionImpl_EXCEPTION_DURING_PING_WITH_TRANSACTION_0_DUE_TO_THE_FOLLOWING_SERVER_EXCEPTION = new StringIdImpl(3483, "Exception during ping with transaction  {0}  due to the following server exception:");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_GET = new StringIdImpl(3484, "{0} : While performing a remote get.");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_PUT = new StringIdImpl(3485, "{0} : While performing a remote put.");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_DESTROY = new StringIdImpl(3486, "{0} : While performing a remote destroy.");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_DESTROY_REGION = new StringIdImpl(3487, "{0} : While performing a remote destroy region.");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_CLEAR_REGION = new StringIdImpl(3488, "{0} : While performing a remote clear region");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_CREATE_REGION = new StringIdImpl(3489, "{0} : While performing a remote create region");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_UNREGISTERINTEREST = new StringIdImpl(3490, "{0} : While performing a remote unregisterInterest");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_CONTAINSKEY = new StringIdImpl(3491, "{0} : While performing a remote containsKey");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_PROCESSBATCH = new StringIdImpl(3492, "{0} : While performing a remote processBatch");
  public static final StringId ConnectionImpl_EXCEPTION_OCCURED_ON_SERVER_ERROR_0 = new StringIdImpl(3493, "Exception occurred on Server. Error : {0}.");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_REGISTERINTEREST = new StringIdImpl(3494, "{0} : While performing a remote registerInterest");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_REGISTERINTEREST_1 = new StringIdImpl(3495, "{0} : While performing a remote registerInterest:  {1}");
  public static final StringId LicenseInfo_EVAL_NAG = new StringIdImpl(3496, "NOTICE: use of GemFire with this license key is only permitted in a non-production environment and for the period, if any, limited by the license key.  Notwithstanding any other provision in the EULA, this Evaluation License of GemFire is provided AS-IS without support or warranty of any kind, expressed or implied.");
  public static final StringId ConnectionImpl_0_WHILE_DESERIALIZING_QUERY_RESULT = new StringIdImpl(3497, "{0} : While deserializing query result");
  public static final StringId TombstoneService_UNEXPECTED_EXCEPTION = new StringIdImpl(3498, "GemFire garbage collection service encountered an unexpected exception");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_KEYSET_1 = new StringIdImpl(3499, "{0} : While performing a remote keySet {1}");
  public static final StringId ConnectionImpl_0_WHILE_PERFORMING_A_REMOTE_KEYSET = new StringIdImpl(3500, "{0} : While performing a remote keySet");
  public static final StringId ConnectionImpl_0_WHILE_MAKE_PRIMARY = new StringIdImpl(3501, "{0} : While make primary");
  public static final StringId ConnectionImpl_CONNECTION_0_WHILE_SENDING_PERIODIC_ACK = new StringIdImpl(3502, "Connection ( {0} ): While sending periodic ack");
  public static final StringId Oplog_FAILED_READING_FROM_0_OPLOG_DETAILS_1_2_3_4_5_6 = new StringIdImpl(3503, "Failed reading from \"{0}\". \n oplogID = {1}\n Offset being read={2} Current Oplog Size={3}  Actual File Size ={4} IS ASYNCH MODE ={5} IS ASYNCH WRITER ALIVE={6}");
  public static final StringId EndpointImpl_0_CAN_NOT_REGISTER_INTEREST_IN_REGION_1_KEY_2_BECAUSE_THE_SERVER_IS_NOT_AVAILABLE = new StringIdImpl(3504, "{0} : Can not register interest in region  {1}  key  {2}  because the server is not available.");
  public static final StringId EndpointImpl_0_CAN_NOT_REGISTER_INSTANTIATORS_1_BECAUSE_THE_SERVER_IS_NOT_AVAILABLE = new StringIdImpl(3505, "{0} : Can not register instantiators   {1}  because the server is not available.");
  public static final StringId EndpointImpl_0_CANNOT_UNREGISTER_INTEREST_IN_REGION_1_KEY_2_BECAUSE_THE_SERVER_IS_NOT_AVAILABLE = new StringIdImpl(3506, "{0} : Cannot unregister interest in region  {1}  key  {2}  because the server is not available.");
  public static final StringId EndpointImpl_0_CAN_NOT_NOTIFY_SERVER_THAT_THIS_CLIENT_IS_READY_BECAUSE_THE_SERVER_IS_NOT_AVAILABLE = new StringIdImpl(3507, "{0} : Can not notify server that this client is ready because the server is not available.");
  public static final StringId CacheCreation_WHILE_STARTING_CACHE_SERVER_0 = new StringIdImpl(3508, "While starting cache server  {0}");
  public static final StringId CacheCreation_WHILE_STARTING_GATEWAY_HUB_0 = new StringIdImpl(3509, "While starting gateway hub  {0}");
  public static final StringId CacheXml_ERROR_WHILE_PARSING_XML = new StringIdImpl(3510, "Error while parsing XML");
  public static final StringId CacheXml_FATAL_ERROR_WHILE_PARSING_XML = new StringIdImpl(3511, "Fatal error while parsing XML");
  public static final StringId CacheXmlParser_WHILE_PARSING_XML = new StringIdImpl(3512, "While parsing XML");
  public static final StringId CacheXmlParser_MALFORMED_INTEGER_0 = new StringIdImpl(3513, "Malformed integer \"{0}\"");
  public static final StringId CacheXmlParser_MALFORMED_FLOAT_0 = new StringIdImpl(3514, "Malformed float \"{0}\"");
  public static final StringId CacheXmlParser_COULD_NOT_CREATE_GATEWAY_WITH_ID_0 = new StringIdImpl(3515, "Could not create gateway with id  {0}");
  public static final StringId CacheXmlParser_COULD_NOT_ADD_ENDPOINT_WITH_ID_0 = new StringIdImpl(3516, "Could not add endpoint with id  {0}");
  public static final StringId CacheXmlParser_COULD_NOT_LOAD_KEYCONSTRAINT_CLASS_0 = new StringIdImpl(3517, "Could not load key-constraint class:  {0}");
  public static final StringId CacheXmlParser_COULD_NOT_LOAD_VALUECONSTRAINT_CLASS_0 = new StringIdImpl(3518, "Could not load value-constraint class:  {0}");
  public static final StringId CacheXmlParser_WHILE_INSTANTIATING_A_0 = new StringIdImpl(3519, "While instantiating a  {0}");
  public static final StringId RegionCreation_GETTING_ENTRIES_RECURSIVELY_IS_NOT_SUPPORTED = new StringIdImpl(3520, "Getting entries recursively is not supported.");
  public static final StringId AbstractPoolCache_ABSTRACTPOOLEDCACHEGETPOOLEDCONNECTIONFROMPOOLINTERRUPTEDEXCEPTION_IN_WAITING_THREAD = new StringIdImpl(3521, "AbstractPooledCache::getPooledConnectionFromPool:InterruptedException in waiting thread");
  public static final StringId ConnectionPoolCacheImpl_CONNECTIONPOOLCACHEIMPLGENEWCONNECTION_EXCEPTION_IN_CREATING_NEW_POOLEDCONNECTION = new StringIdImpl(3522, "ConnectionPoolCacheImpl::getNewConnection: Exception in creating new PooledConnection");
  public static final StringId ConnectionPoolCacheImpl_CONNECTIONPOOLCACHEIMPLGENEWCONNECTION_CONNECTIONPOOLCACHE_NOT_INTIALIZED_WITH_CONNECTIONPOOLDATASOURCE = new StringIdImpl(3523, "ConnectionPoolCacheImpl::getNewConnection: ConnectionPoolCache not initialized with ConnectionPoolDatasource");
  public static final StringId FacetsJCAConnectionManagerImpl_FACETSJCACONNECTIONMANAGERIMPL_ALLOCATECONNECTION_IN_GETTING_CONNECTION_FROM_POOL_DUE_TO_0 = new StringIdImpl(3524, "FacetsJCAConnectionManagerImpl:: allocateConnection : in getting connection from pool due to  {0}");
  public static final StringId FacetsJCAConnectionManagerImpl_FACETSJCACONNECTIONMANAGERIMPL_ALLOCATECONNECTION_SYSTEM_EXCEPTION_DUE_TO_0 = new StringIdImpl(3525, "FacetsJCAConnectionManagerImpl:: allocateConnection :system exception due to  {0}");
  //public static final StringId GemFireBasicDataSource_GEMFIREBASICDATASOURCEGETCONNECTIONEXCEPTION_WHILE_TRYING_TO_LOAD_THE_DRIVER_DUE_TO_0 = new StringIdImpl(3526, "GemFireBasicDataSource::getConnection:Exception while trying to load the driver due to  {0}");
  public static final StringId JCAConnectionManagerImpl_JCACONNECTIONMANAGERIMPL_ALLOCATECONNECTION_IN_GETTING_CONNECTION_FROM_POOL_DUE_TO_0 = new StringIdImpl(3527, "JCAConnectionManagerImpl:: allocateConnection : in getting connection from pool due to  {0}");
  public static final StringId JCAConnectionManagerImpl_JCACONNECTIONMANAGERIMPL_ALLOCATECONNECTION_IN_TRANSACTION_DUE_TO_0 = new StringIdImpl(3528, "JCAConnectionManagerImpl:: allocateConnection : in transaction due to  {0}");
  public static final StringId JCAConnectionManagerImpl_JCACONNECTIONMANAGERIMPL_ALLOCATECONNECTION_SYSTEM_EXCEPTION_DUE_TO_0 = new StringIdImpl(3529, "JCAConnectionManagerImpl:: allocateConnection :system exception due to  {0}");
  public static final StringId ManagedPoolCacheImpl_MANAGEDPOOLCACHEIMPLGETNEWCONNECTION_EXCEPTION_IN_CREATING_NEW_MANAGED_POOLEDCONNECTION = new StringIdImpl(3530, "ManagedPoolCacheImpl::getNewConnection: Exception in creating new Managed PooledConnection");
  public static final StringId TranxPoolCacheImpl_TRANXPOOLCACHEIMPLGETNEWCONNECTION_EXCEPTION_IN_CREATING_NEW_TRANSACTION_POOLEDCONNECTION = new StringIdImpl(3531, "TranxPoolCacheImpl::getNewConnection: Exception in creating new transaction PooledConnection");
  public static final StringId TranxPoolCacheImpl_TRANXPOOLCACHEIMPLGETNEWCONNECTION_CONNECTIONPOOLCACHE_NOT_INTIALIZED_WITH_XADATASOURCE = new StringIdImpl(3532, "TranxPoolCacheImpl::getNewConnection: ConnectionPoolCache not intialized with XADatasource");
  public static final StringId ObjectXmlExporter_A_TRANFSFORMEREXCEPTION_WAS_THROWN_WHILE_GENERATING_XML_FOR_A_0 = new StringIdImpl(3533, "A TranfsformerException was thrown while generating XML for a  {0}");
  public static final StringId ObjectXmlExporter_AN_EXCEPTION_WAS_THROWN_WHILE_ACCESSING_FIELD_0_IN_CLASS_1 = new StringIdImpl(3534, "An Exception was thrown while accessing field  {0}  in class  {1}");
  public static final StringId ObjectXmlImporter_AN_IOEXCEPTION_WAS_THROWN_WHILE_PARSING_XML = new StringIdImpl(3535, "An IOException was thrown while parsing XML.");
  public static final StringId ObjectXmlImporter_A_PARSERCONFIGURATIONEXCEPTION_WAS_THROWN_WHILE_PARSING_XML = new StringIdImpl(3536, "A ParserConfigurationException was thrown While parsing XML.");
  public static final StringId ObjectXmlImporter_A_SAXEXCEPTION_WAS_THROWN_WHILE_PARSING_XML = new StringIdImpl(3537, "A SAXException was thrown While parsing XML.");
  public static final StringId ObjectXmlImporter_COULD_NOT_LOAD_CLASS_0 = new StringIdImpl(3538, "Could not load class  {0}");
  public static final StringId ObjectXmlImporter_AN_EXCEPTION_WAS_THROWN_WHILE_INSTANTIATING_0 = new StringIdImpl(3539, "An Exception was thrown while instantiating  {0}");
  public static final StringId ObjectXmlImporter_AN_EXCEPTION_WAS_THROWN_WHILE_LOCATING_FIELD_0_IN_CLASS_1 = new StringIdImpl(3540, "An Exception was thrown while locating field  {0}  in class  {1}");
  public static final StringId ObjectXmlImporter_A_CLASSNOTFOUNDEXCEPTION_AS_THROWN_WHILE_LOADING_ARRAY_ELEMENT_TYPE_0 = new StringIdImpl(3541, "A ClassNotFoundException was thrown while loading array element type:  {0}");

  public static final StringId DataSerializer_UNKNOWN_PRIMITIVE_TYPE_0 = new StringIdImpl(3542, "unknown primitive type:  {0}");
  public static final StringId DataSerializer_UNEXPECTED_TYPECODE_0 = new StringIdImpl(3543, "unexpected typeCode:  {0}");
  public static final StringId DataSerializer_CONFLICTING_NONPUBLIC_INTERFACE_CLASS_LOADERS = new StringIdImpl(3544, "Conflicting non-public interface class loaders");
  public static final StringId SystemFailure_0_MEMORY_HAS_REMAINED_CHRONICALLY_BELOW_1_BYTES_OUT_OF_A_MAXIMUM_OF_2_FOR_3_SEC = new StringIdImpl(3545, "{0} : memory has remained chronically below  {1}  bytes (out of a maximum of  {2} ) for  {3}  sec.");
  public static final StringId SystemFailure_JVM_CORRUPTION_HAS_BEEN_DETECTED = new StringIdImpl(3546, "JVM corruption has been detected");
  public static final StringId LonerDistributionManager_CANNOT_RESOLVE_LOCAL_HOST_NAME_TO_AN_IP_ADDRESS = new StringIdImpl(3547, "Cannot resolve local host name to an IP address");
  public static final StringId AbstractDistributionConfig_UNEXPECTED_PROBLEM_GETTING_INETADDRESS_0 = new StringIdImpl(3548, "Unexpected problem getting inetAddress: {0}");
  public static final StringId DistributionManager_UNKNOWN_MEMBER_TYPE_0 = new StringIdImpl(3549, "Unknown  member type:  {0}");
  public static final StringId DistributionManager_UNKNOWN_PROCESSOR_TYPE = new StringIdImpl(3550, "unknown processor type {0}");
  public static final StringId DLockRequestProcessor_UNKNOWN_RESPONSE_CODE_0 = new StringIdImpl(3551, "Unknown response code {0}");
  public static final StringId StreamingOperation_THIS_SHOULDNT_HAPPEN = new StringIdImpl(3552, "this should not happen");
  public static final StringId MemberAttributes_IOEXCEPTION_ON_A_BYTE_ARRAY_0 = new StringIdImpl(3553, "IOException on a byte array:  {0}");
  public static final StringId MemberAttributes_CLASSNOTFOUNDEXCEPTION_IN_DESERIALIZATION_0 = new StringIdImpl(3554, "ClassNotFoundException in deserialization:  {0}");
  public static final StringId JGroupMembershipManager_UNKNOWN_STARTUP_EVENT_0 = new StringIdImpl(3555, "unknown startup event:  {0}");
  public static final StringId JGroupMember_ATTEMPT_TO_EXTERNALIZE_NULL_IP_ADDRESS = new StringIdImpl(3556, "attempt to externalize null ip address");
  public static final StringId UpdateOperation_UNKNOWN_DESERIALIZATION_POLICY = new StringIdImpl(3557, "unknown deserialization policy");
  public static final StringId UpdateOperation_UNKNOWN_DESERIALIZATION_POLICY_0 = new StringIdImpl(3558, "unknown deserialization policy:  {0}");
  public static final StringId QueuedOperation_CACHEWRITER_SHOULD_NOT_BE_CALLED = new StringIdImpl(3559, "CacheWriter should not be called");
  public static final StringId QueuedOperation_DISTRIBUTEDLOCK_SHOULD_NOT_BE_ACQUIRED = new StringIdImpl(3560, "DistributedLock should not be acquired");
  public static final StringId InitialImageOperation_ALREADY_PROCESSED_LAST_CHUNK = new StringIdImpl(3561, "Already processed last chunk");
  public static final StringId PartitionedRegionQueryEvaluator_UNABLE_TO_GET_NODE_FOR_BUCKET_ID_0 = new StringIdImpl(3562, "unable to get node for bucket id  {0}");
  public static final StringId DiskEntry_WRITE_TO_DISK_SHOULD_NOT_HAVE_BEEN_INVOKED_IN_THE_ENTRY_INITIALIZATION_PHASE = new StringIdImpl(3563, "Write to disk should not have been invoked in the entry initialization phase");
  public static final StringId DistributedCacheOperation_SHOULD_NEVER_BE_CALLED = new StringIdImpl(3564, "should never be called");
  public static final StringId ExpiryTask_UNRECOGNIZED_EXPIRATION_ACTION_0 = new StringIdImpl(3565, "unrecognized expiration action:  {0}");
  public static final StringId LocalRegion_UNEXPECTED_EXCEPTION = new StringIdImpl(3566, "unexpected exception");
  public static final StringId LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_LOCALDESTROY = new StringIdImpl(3567, "Cache Writer should not have been called for localDestroy");
  public static final StringId LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_LOCALDESTROY = new StringIdImpl(3568, "No distributed lock should have been attempted for localDestroy");
  public static final StringId LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION = new StringIdImpl(3569, "CacheWriterException should not be thrown in localDestroyRegion");
  public static final StringId LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION = new StringIdImpl(3570, "TimeoutException should not be thrown in localDestroyRegion");
  public static final StringId LocalRegion_UNKNOWN_INTEREST_TYPE = new StringIdImpl(3571, "unknown interest type");
  public static final StringId LocalRegion_NOT_YET_SUPPORTED = new StringIdImpl(3572, "not yet supported");
  public static final StringId LocalRegion_GOT_REGIONEXISTSEXCEPTION_IN_REINITIALIZE_WHEN_HOLDING_DESTROY_LOCK = new StringIdImpl(3573, "Got RegionExistsException in reinitialize when holding destroy lock");
  public static final StringId LocalRegion_UNEXPECTED_THREADINITLEVELREQUIREMENT = new StringIdImpl(3574, "Unexpected threadInitLevelRequirement");
  public static final StringId LocalRegion_ENTRY_ALREADY_EXISTED_0 = new StringIdImpl(3575, "Entry already existed:  {0}");
  public static final StringId LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_EVICTDESTROY = new StringIdImpl(3576, "Cache Writer should not have been called for evictDestroy");
  public static final StringId LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_EVICTDESTROY = new StringIdImpl(3577, "No distributed lock should have been attempted for evictDestroy");
  public static final StringId LocalRegion_ENTRYNOTFOUNDEXCEPTION_SHOULD_BE_MASKED_FOR_EVICTDESTROY = new StringIdImpl(3578, "EntryNotFoundException should be masked for evictDestroy");
  public static final StringId LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_HERE = new StringIdImpl(3579, "CacheWriterException should not be thrown here");
  public static final StringId LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_HERE = new StringIdImpl(3580, "TimeoutException should not be thrown here");
  public static final StringId GemFireCache_CACHE_SHOULD_NOT_BE_CLOSED_YET = new StringIdImpl(3581, "cache should not be closed yet");
  public static final StringId GemFireCache_UNEXPECTED_EXCEPTION = new StringIdImpl(3582, "unexpected exception");
  public static final StringId EntryEvents_MUST_NOT_SERIALIZE_0_IN_THIS_CONTEXT = new StringIdImpl(3583, "Must not serialize {0} in this context.");
  public static final StringId DistributedRegion_IF_LOADING_A_SNAPSHOT_THEN_SHOULD_NOT_BE_RECOVERING_ISRECOVERING_0_SNAPSHOTSTREAM_1 = new StringIdImpl(3584, "if loading a snapshot, then should not be recovering; isRecovering= {0} ,snapshotStream= {1}");
  public static final StringId AbstractUpdateOperation_CACHEWRITER_SHOULD_NOT_BE_CALLED = new StringIdImpl(3585, "CacheWriter should not be called");
  public static final StringId AbstractUpdateOperation_DISTRIBUTEDLOCK_SHOULD_NOT_BE_ACQUIRED = new StringIdImpl(3586, "DistributedLock should not be acquired");
  public static final StringId RegionEventImpl_CLONE_IS_SUPPORTED = new StringIdImpl(3587, "clone IS supported");
  public static final StringId DestroyOperation_CACHEWRITER_SHOULD_NOT_BE_CALLED = new StringIdImpl(3588, "CacheWriter should not be called");
  public static final StringId DestroyOperation_DISTRIBUTEDLOCK_SHOULD_NOT_BE_ACQUIRED = new StringIdImpl(3589, "DistributedLock should not be acquired");
  public static final StringId StreamingPartitionOperation_UNEXPECTED_CONDITION = new StringIdImpl(3590, "unexpected condition");
  public static final StringId PartitionMessage_SORRY_USE_OPERATEONPARTITIONEDREGION_FOR_PR_MESSAGES = new StringIdImpl(3591, "Sorry, use operateOnPartitionedRegion for PR messages");
  public static final StringId FetchEntryMessage_FETCHENTRYMESSAGE_MESSAGE_SENT_TO_WRONG_MEMBER = new StringIdImpl(3592, "FetchEntryMessage message sent to wrong member");
  public static final StringId GetMessage_GET_MESSAGE_SENT_TO_WRONG_MEMBER = new StringIdImpl(3593, "Get message sent to wrong member");
  public static final StringId FetchEntriesMessage_ALREADY_PROCESSED_LAST_CHUNK = new StringIdImpl(3594, "Already processed last chunk");
  public static final StringId FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK = new StringIdImpl(3595, "Already processed last chunk");
  public static final StringId CacheClientProxy_UNKNOWN_INTEREST_TYPE = new StringIdImpl(3596, "Unknown interest type");
  public static final StringId CacheClientProxy_BAD_INTEREST_TYPE = new StringIdImpl(3597, "bad interest type");
  public static final StringId InternalDistributedSystem_PROBLEM_IN_INITIALIZING_KEYS_FOR_CLIENT_AUTHENTICATION = new StringIdImpl(3598, "Problem in initializing keys for client authentication");
  public static final StringId ConnectionImpl_UNKNOWN_MESSAGE_TYPE_0 = new StringIdImpl(3599, "Unknown message type {0}");
  public static final StringId ConnectionProxyImpl_UNKNOWN_INTERESTTYPE = new StringIdImpl(3600, "Unknown interestType");
  public static final StringId ConnectionProxyImpl_WEIRD_ENDPOINT_TYPE_0 = new StringIdImpl(3601, "Weird endpoint type  {0}");
  public static final StringId BaseCommand_NOT_YET_SUPPORTED = new StringIdImpl(3602, "not yet supported");
  public static final StringId BaseCommand_UNKNOWN_INTEREST_TYPE = new StringIdImpl(3603, "unknown interest type");
  public static final StringId SystemAdmin_REGION_OPTION_HELP = new StringIdImpl(3604, "Used to specify what region an operation is to be done on.");
  public static final StringId EntryNotFoundInRegion_THIS_CLASS_IS_DEPRECATED = new StringIdImpl(3605, "this class is deprecated");
  public static final StringId DynamicRegionFactory_UNEXPECTED_EXCEPTION = new StringIdImpl(3606, "unexpected exception");
  public static final StringId CqAttributesFactory_CLONENOTSUPPORTEDEXCEPTION_THROWN_IN_CLASS_THAT_IMPLEMENTS_CLONEABLE = new StringIdImpl(3607, "CloneNotSupportedException thrown in class that implements cloneable");
  public static final StringId Support_ERROR_ASSERTION_FAILED_0 = new StringIdImpl(3608, "ERROR: Assertion failed: '' {0} ''");
  public static final StringId TypeUtils_EXPECTED_INSTANCE_OF_0_BUT_WAS_1 = new StringIdImpl(3609, "expected instance of  {0}  but was  {1}");
  public static final StringId SystemFailure_SINCE_THIS_IS_A_DEDICATED_CACHE_SERVER_AND_THE_JVM_HAS_BEEN_CORRUPTED_THIS_PROCESS_WILL_NOW_TERMINATE_PERMISSION_TO_CALL_SYSTEM_EXIT_INT_WAS_GIVEN_IN_THE_FOLLOWING_CONTEXT = new StringIdImpl(3610, "Since this is a dedicated cache server and the JVM has been corrupted, this process will now terminate. Permission to call System#exit(int) was given in the following context.");
  public static final StringId GatewayImpl_0_DID_NOT_WAIT_FOR_FAILOVER_COMPLETION_DUE_TO_INTERRUPTION = new StringIdImpl(3611, "{0}: did not wait for failover completion due to interruption.");
  public static final StringId GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3 = new StringIdImpl(3612, "{0}: An Exception occurred while queueing {1} to perform operation {2} for {3}");
  public static final StringId GatewayImpl_THE_EVENT_QUEUE_SIZE_HAS_DROPPED_BELOW_THE_THRESHOLD_0 = new StringIdImpl(3613, "The event queue size has dropped below {0} events.");
  public static final StringId GatewayImpl_A_CACHECLOSEDEXCEPTION_OCCURRED_STOPPING_THE_DISPATCHER = new StringIdImpl(3614, "A CacheClosedException occurred. Stopping the dispatcher.");
  public static final StringId GatewayImpl_GATEWAY_FAILOVER_INITIATED_PROCESSING_0_UNPROCESSED_EVENTS = new StringIdImpl(3615, "Gateway Failover Initiated: Processing {0} unprocessed events.");
  public static final StringId GatewayImpl_A_BATCHEXCEPTION_OCCURRED_DURING_FAILOVER_PROCESSING_EVENT_0_THIS_MESSAGE_WILL_CONTINUE_TO_BE_PROCESSED = new StringIdImpl(3616, "A BatchException occurred during failover processing event {0}. This message will continue to be processed.");
  public static final StringId GatewayImpl_STOPPING_THE_DISPATCHER_BECAUSE_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_PROCESSING_A_BATCH = new StringIdImpl(3617, "Stopping the dispatcher because the following exception occurred while processing a batch:");
  public static final StringId GatewayImpl_AN_EXCEPTION_OCCURRED_THE_DISPATCHER_WILL_CONTINUE = new StringIdImpl(3618, "An Exception occurred. The dispatcher will continue.");
  public static final StringId GatewayImpl_0_THE_UNPROCESSED_EVENTS_MAP_ALREADY_CONTAINED_AN_EVENT_FROM_THE_HUB_1_SO_IGNORING_NEW_EVENT_2 = new StringIdImpl(3619, "{0}: The secondary map already contained an event from hub {1} so ignoring new event {2}.");
  public static final StringId GatewayImpl_EVENT_FAILED_TO_BE_INITIALIZED_0 = new StringIdImpl(3620, "Event failed to be initialized: {0}");
  public static final StringId GatewayImpl_STOPPING_THE_DISPATCHER_BECAUSE_THE_FOLLOWING_GATEWAY_EXCEPTION_OCCURRED = new StringIdImpl(3621, "Stopping the dispatcher because the following gateway exception occurred.");
  public static final StringId GatewayImpl_0_THE_EVENT_QUEUE_SIZE_HAS_REACHED_THE_THRESHOLD_1 = new StringIdImpl(3622, "{0}: The event queue has reached {1} events. Processing will continue.");
  public static final StringId GatewayImpl_AN_INTERRUPTEDEXCEPTION_OCCURRED_BUT_THE_DISPATCHER_IS_NOT_STOPPED = new StringIdImpl(3623, "An InterruptedException occurred, but the dispatcher is not stopped.");
  public static final StringId GatewayImpl_AN_INTERRUPTEDEXCEPTION_OCCURRED_THE_THREAD_WILL_EXIT = new StringIdImpl(3624, "An InterruptedException occurred. The thread will exit.");
  public static final StringId GatewayImpl_A_BATCHEXCEPTION_OCCURRED_PROCESSING_EVENT_0 = new StringIdImpl(3625, "A BatchException occurred processing event {0}.");
  public static final StringId GatewayImpl_A_THREADINTERRUPTEDEXCEPTION_OCCURRED_STOPPING_THE_DISPATCHER = new StringIdImpl(3626, "A ThreadInterruptedException occurred. Stopping the dispatcher.");
  public static final StringId GatewayImpl_THE_FOLLOWING_CACHEEXCEPTION_OCCURRED_WHILE_REMOVING_0_EVENTS = new StringIdImpl(3627, "The following CacheException occurred while removing {0} events.");
  public static final StringId GatewayImpl_EVENT_DROPPED_DURING_FAILOVER_0 = new StringIdImpl(3628, "Event dropped during failover: {0}");
  public static final StringId GatewayImpl_0_DISPATCHER_STILL_ALIVE_EVEN_AFTER_JOIN_OF_5_SECONDS = new StringIdImpl(3629, "{0}:Dispatcher still alive even after join of 5 seconds.");
  public static final StringId GatewayImpl_0_INTERRUPTEDEXCEPTION_IN_JOINING_WITH_DISPATCHER_THREAD = new StringIdImpl(3630, "{0}:InterruptedException in joining with dispatcher thread.");
  public static final StringId GatewayImpl_THE_EVENT_BEING_PROCESSED_WHEN_THE_BATCHEXCEPTION_OCCURRED_WAS_0 = new StringIdImpl(3631, "The event being processed when the BatchException occurred was: {0}");
  public static final StringId AdminConfig_THIS_FILE_IS_GENERATED_BY_ADMINCONSOLE_EDIT_AS_YOU_WISH_BUT_IT_WILL_BE_OVERWRITTEN_IF_IT_IS_MODIFIED_IN_ADMINCONSOLE = new StringIdImpl(3632, "This file is generated by AdminConsole. Edit as you wish but it will be overwritten if it is modified in AdminConsole.");
  public static final StringId AdminConfig_MODIFIED_0 = new StringIdImpl(3633, "Modified {0}");
  public static final StringId DLockService_DISCONNECT_LISTENER_FOR_DISTRIBUTEDLOCKSERVICE = new StringIdImpl(3634, "Disconnect listener for DistributedLockService");
  public static final StringId DLockService_DISTRIBUTED_LOCKING_THREADS = new StringIdImpl(3635, "Distributed Locking Threads");
  // public static final StringId Oplog_BACKUP = new StringIdImpl(3636, "BACKUP");
  // public static final StringId Oplog_OVERFLOW = new StringIdImpl(3637, "OVERFLOW");
  public static final StringId DiskRegion_DISK_WRITERS = new StringIdImpl(3638, "Disk Writers");
  public static final StringId DiskRegion_ASYNCHRONOUS_DISK_WRITER_0 = new StringIdImpl(3639, "Asynchronous disk writer for region {0}");
  public static final StringId PartitionedRegion_SHUTDOWN_LISTENER_FOR_PARTITIONEDREGION = new StringIdImpl(3640, "Shutdown listener for PartitionedRegion");
  public static final StringId ExecuteFunction_CANNOT_SPECIFY_0_FOR_ONREGIONS_FUNCTION = new StringIdImpl(3641, "Cannot specify {0} for multi region function");
  public static final StringId PartitionedRegion_AN_EXCEPTION_WAS_CAUGHT_WHILE_REGISTERING_PARTITIONEDREGION_0_DUMPPRID_1 = new StringIdImpl(3642, "An exception was caught while registering PartitionedRegion \"{0}\". dumpPRId: {1}");
  public static final StringId Connection_COULD_NOT_START_READER_THREAD = new StringIdImpl(3643, "could not start reader thread");
  public static final StringId Connection_IDLE_CONNECTION_TIMED_OUT = new StringIdImpl(3644, "idle connection timed out");
  public static final StringId Connection_UNKNOWN = new StringIdImpl(3645, "unknown");
  public static final StringId Connection_HANDSHAKE_TIMED_OUT = new StringIdImpl(3646, "handshake timed out");
  public static final StringId Connection_INTERRUPTED = new StringIdImpl(3647, "interrupted");
  public static final StringId Connection_FAILED_HANDSHAKE = new StringIdImpl(3648, "failed handshake");
  public static final StringId Connection_FAILED_CONSTRUCTION = new StringIdImpl(3649, "failed construction");
  public static final StringId Connection_RUNNIOREADER_CAUGHT_CLOSED_CHANNEL = new StringIdImpl(3650, "runNioReader caught closed channel");
  public static final StringId Connection_RUNNIOREADER_CAUGHT_SHUTDOWN = new StringIdImpl(3651, "runNioReader caught shutdown");
  public static final StringId Connection_SOCKETCHANNEL_READ_RETURNED_EOF = new StringIdImpl(3652, "SocketChannel.read returned EOF");
  public static final StringId Connection_THREADINTERRUPTED_IN_CHANNEL_READ_0 = new StringIdImpl(3653, "ThreadInterrupted in channel read: {0}");
  public static final StringId Connection_CACHECLOSED_IN_CHANNEL_READ_0 = new StringIdImpl(3654, "CacheClosed in channel read: {0}");
  public static final StringId Connection_IOEXCEPTION_IN_CHANNEL_READ_0 = new StringIdImpl(3655, "IOException in channel read: {0}");
  public static final StringId Connection_P2P_MESSAGE_READER_FOR_0 = new StringIdImpl(3656, "P2P message reader for {0} on port {1}");
  public static final StringId Connection_CLOSEDCHANNELEXCEPTION_IN_CHANNEL_READ_0 = new StringIdImpl(3657, "ClosedChannelException in channel read: {0}");
  public static final StringId Connection_IOEXCEPTION_RECEIVED_0 = new StringIdImpl(3658, "IOException received: {0}");
  public static final StringId Connection_STREAM_READ_RETURNED_NONPOSITIVE_LENGTH = new StringIdImpl(3659, "Stream read returned non-positive length");
  public static final StringId Connection_CURRENT_THREAD_INTERRUPTED = new StringIdImpl(3660, "Current thread interrupted");
  public static final StringId ExecuteFunction_RESULTS_NOT_COLLECTED_IN_TIME_PROVIDED = new StringIdImpl(3661, "All results not received in time provided");
  public static final StringId Connection_NO_DISTRIBUTION_MANAGER = new StringIdImpl(3662, "no distribution manager");
  public static final StringId Connection_COULD_NOT_SEND_FORCE_DISCONNECT = new StringIdImpl(3663, "Could not send force disconnect");
  public static final StringId Connection_FORCE_DISCONNECT_TIMED_OUT = new StringIdImpl(3664, "Force disconnect timed out");
  public static final StringId Connection_P2P_PUSHER_IO_EXCEPTION_FOR_0 = new StringIdImpl(3665, "P2P pusher io exception for {0}");
  public static final StringId Connection_P2P_PUSHER_0_CAUGHT_CACHECLOSEDEXCEPTION_1 = new StringIdImpl(3666, "P2P pusher {0} caught CacheClosedException: {1}");
  public static final StringId Connection_P2P_PUSHER_0_CAUGHT_INTERRUPT_1 = new StringIdImpl(3667, "P2P pusher {0} caught interrupt: {1}");
  public static final StringId Connection_NONPOSITIVE_RETURN_FROM_CHANNEL_READ_OF_ACK = new StringIdImpl(3668, "non-positive return from channel read of ack");
  public static final StringId Connection_ACK_READ_IO_EXCEPTION_FOR_0 = new StringIdImpl(3669, "ack read io exception for {0}");
  public static final StringId Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE = new StringIdImpl(3670, "ClassNotFound deserializing message");
  public static final StringId Connection_FAILED_SENDING_HANDSHAKE_REPLY = new StringIdImpl(3671, "Failed sending handshake reply");
  public static final StringId ConnectionProxyImpl_ASYNCHRONOUS_REDUNDANCY_SATISFIER_THREAD_INVOKED_FROM_ENDPOINTDIED = new StringIdImpl(3672, "Asynchronous redundancy satisfier thread invoked from endpointDied");
  public static final StringId ConnectionProxyImpl_AFTER_REDUNDANT_SELECTION_HERE_ARE_THE_ENDPOINTS_0 = new StringIdImpl(3673, "After redundant selection, here are the endpoints: {0}");
  public static final StringId ConnectionProxyImpl_AFTER_A_FAILURE_ON_THE_PRIMARY_HERE_ARE_THE_ENDPOINTS_0 = new StringIdImpl(3674, "After a failure on the primary endpoint, here are the endpoints: {0}");
  public static final StringId ConnectionProxyImpl_AFTER_ADDING_AN_ENDPOINT_HERE_ARE_THE_ENDPOINTS_0 = new StringIdImpl(3675, "After adding an endpoint, here are the endpoints: {0}");
  public static final StringId ConnectionProxyImpl_UNREGISTERED_INTEREST_IN_0_ON_REGION_1_OF_TYPE_2_WITH_POLICY_3_BECAUSE_OF_4 = new StringIdImpl(3677, "unregistered interest in {0} on region {1} of type {2} with policy {3} because of {4}");
  public static final StringId JGroupMembershipManager_TCPIP_CONNECTIONS_CLOSED = new StringIdImpl(3678, "tcp/ip connections closed");
  public static final StringId JGroupMembershipManager_THE_MEMBER_WITH_ID_0_IS_NO_LONGER_IN_MY_OWN_VIEW_1 = new StringIdImpl(3679, "The Member with id {0}, is no longer in my own view, {1}");
  public static final StringId LicenseInfo_LICENSE_IS_VALID_UNTIL_0 = new StringIdImpl(3680, "License is valid until \"{0}\".");
  public static final StringId LicenseInfo_LICENSE_NEVER_EXPIRES = new StringIdImpl(3681, "License never expires.");
  public static final StringId LicenseInfo_LICENSE_IS_LIMITED_TO_NODES_0 = new StringIdImpl(3682, "License is limited to node(s) \"{0}\".");
  public static final StringId LicenseInfo_LICENSE_IS_VALID_ON_ANY_NODE = new StringIdImpl(3683, "License is valid on any node.");
  public static final StringId LicenseInfo_LICENSE_IS_LIMITED_TO_THIS_NATIVE_NODE_0 = new StringIdImpl(3684, "License is limited to this native node \"{0}\".");
  public static final StringId LicenseInfo_LICENSE_HAD_NO_NATIVE_NODE_LIMITS = new StringIdImpl(3685, "License had no native node limits.");
  public static final StringId LicenseInfo_LICENSE_LIMITS_DISTRIBUTED_SYSTEM_TO_0_MEMBERS = new StringIdImpl(3686, "License limits distributed system to \"{0}\" members.");
  public static final StringId LicenseInfo_LICENSE_IS_LIMITED_TO_0_CPUS = new StringIdImpl(3687, "License is limited to {0} cpus.");
  public static final StringId LicenseInfo_LICENSE_ALLOWS_FOR_HYPERTHREADED_CPUS = new StringIdImpl(3688, "License allows for hyperthreaded cpus.");
  public static final StringId LicenseInfo_ACTUAL_NUMBER_OF_PURCHASED_CPUS_IS_0 = new StringIdImpl(3689, "Actual number of purchased cpus is \"{0}\".");
  public static final StringId LicenseInfo_LICENSE_ALLOWS_AN_UNLIMITED_NUMBER_OF_CPUS = new StringIdImpl(3690, "License allows an unlimited number of cpus.");
  public static final StringId LicenseInfo_NO_LIMIT_FOR_KEY_0 = new StringIdImpl(3691, "No limit for key \"{0}\"");
  public static final StringId LicenseInfo_DETERMINED_BY_GEMSTONE = new StringIdImpl(3692, "<determined by GemStone>");
  public static final StringId LicenseInfo_PLEASE_SUPPLY_A_CUSTOMER_NAME_HERE = new StringIdImpl(3693, "<Please supply a customer name here>");
  public static final StringId LicenseInfo_DATA_NEEDED_TO_OBTAIN_LICENSE_FOR_CURRENT_MACHINE = new StringIdImpl(3694, "Data Needed to Obtain License for current machine.");
  public static final StringId LicenseInfo_CONTENTS_OF_0 = new StringIdImpl(3695, "-------------------- Contents of {0} --------------------");
  public static final StringId LicenseInfo_COULD_NOT_FIND_DEFAULT_LICENSE_FILE_0 = new StringIdImpl(3696, "Could not find default license file: {0}");
  public static final StringId LicenseInfo_TROUBLE_READING_LICENSE_FILE_0 = new StringIdImpl(3697, "Trouble reading license file: {0}");
  public static final StringId LicenseInfo_LICENSE_SIGNATURE_IS_VALID = new StringIdImpl(3698, "License signature is valid.");
  public static final StringId LicenseInfo_THIS_LICENSE_IS_INVALID_0 = new StringIdImpl(3699, "This license is invalid. {0}");
  public static final StringId GemFireVersion_COULD_NOT_FIND_GEMFIRE_JAR = new StringIdImpl(3700, "<Could not find gemfire.jar>");
  public static final StringId GemFireVersion_COULD_NOT_FIND_RESOURCE_COM_GEMSTONE_GEMFIRE_INTERNAL_0 = new StringIdImpl(3701, "<Could not find resource com/gemstone/gemfire/internal/{0}>");
  public static final StringId GemFireVersion_COULD_NOT_READ_PROPERTIES_FROM_RESOURCE_COM_GEMSTONE_GEMFIRE_INTERNAL_0_BECAUSE_1 = new StringIdImpl(3702, "<Could not read properties from resource com/gemstone/gemfire/internal/{0} because: {1}>");
  public static final StringId GemFireVersion_MISSING_PROPERTY_0_FROM_RESOURCE_COM_GEMSTONE_GEMFIRE_INTERNAL_1 = new StringIdImpl(3703, "<Missing property {0} from resource com/gemstone/gemfire/internal/{1}>");
  public static final StringId GemFireVersion_RUNNING_ON_0 = new StringIdImpl(3704, "Running on: {0}");
  public static final StringId GemFireVersion_WARNING_EXPECTED_JAVA_VERSION_0 = new StringIdImpl(3705, "Warning expected java version: {0}");
  public static final StringId GemFireVersion_WARNING_EXPECTED_NATIVE_VERSION_0 = new StringIdImpl(3706, "Warning expected native version: {0}");
  public static final StringId GemFireVersion_WARNING_FAILED_TO_READ_0_BECAUSE_1 = new StringIdImpl(3707, "Warning failed to read \"{0}\" because {1}.");
  public static final StringId GemFireVersion_WARNING_COULD_NOT_FIND_0 = new StringIdImpl(3708, "Warning could not find \"{0}\".");
  public static final StringId GemFireVersion_WARNING_COULD_NOT_DETERMINE_THE_PRODUCTS_LIB_DIRECTORY = new StringIdImpl(3709, "Warning could not determine the product''s lib directory.");
  public static final StringId LocalRegion_THE_CACHE_IS_NOT_AVAILABLE = new StringIdImpl(3710, "The cache is not available");
  public static final StringId LocalRegion_THE_DISTRIBUTED_SYSTEM_IS_NOT_AVAILABLE = new StringIdImpl(3711, "The distributed system is not available.");
  public static final StringId GemFireCache_NORMAL_DISCONNECT = new StringIdImpl(3712, "Normal disconnect");
  public static final StringId GlobalTransaction_GLOBALTRANSACTION_ADDTRANSACTION_CANNOT_ADD_A_NULL_TRANSACTION = new StringIdImpl(3713, "GlobalTransaction::addTransaction::Cannot add a null Transaction");
  public static final StringId GlobalTransaction_GLOBALTRANSACTION_COMMIT_ERROR_IN_COMMITTING_BUT_TRANSACTION_COULD_NOT_BE_ROLLED_BACK_DUE_TO_EXCEPTION_0 = new StringIdImpl(3714, "GlobalTransaction::commit::Error in committing, but transaction could not be rolled back due to exception: {0}");
  public static final StringId GlobalTransaction_GLOBALTRANSACTION_COMMIT_ERROR_IN_COMMITTING_THE_TRANSACTION_TRANSACTION_ROLLED_BACK_EXCEPTION_0_1 = new StringIdImpl(3715, "GlobalTransaction::commit:Error in committing the transaction. Transaction rolled back.Exception = {0} {1}");
  public static final StringId GlobalTransaction_GLOBALTRANSACTION_ROLLBACK_ROLLBACK_NOT_SUCCESSFUL_DUE_TO_EXCEPTION_0_1 = new StringIdImpl(3716, "GlobalTransaction::rollback:Rollback not successful due to exception {0} {1}");
  public static final StringId GlobalTransaction_GLOBALTRANSACTION_ENLISTRESOURCE_CANNOT_ENLIST_A_RESOURCE_TO_A_TRANSACTION_WHICH_IS_NOT_ACTIVE = new StringIdImpl(3717, "GlobalTransaction::enlistResource::Cannot enlist a resource to a transaction which is not active");
  public static final StringId GlobalTransaction_GLOBALTRANSACTION_ENLISTRESOURCE_EXCEPTION_OCCURED_IN_TRYING_TO_SET_XARESOURCE_TIMEOUT_DUE_TO_0_ERROR_CODE_1 = new StringIdImpl(3718, "GlobalTransaction::enlistResource:Exception occurred in trying to set XAResource timeout due to {0} Error Code = {1}");
  public static final StringId GlobalTransaction_ERROR_WHILE_DELISTING_XARESOURCE_0_1 = new StringIdImpl(3719, "error while delisting XAResource {0} {1}");
  public static final StringId GlobalTransaction_GLOBATRANSACTION_RESUME_RESUME_NOT_SUCCESFUL_DUE_TO_0 = new StringIdImpl(3720, "GlobaTransaction::resume:Resume not succesful due to {0}");
  public static final StringId GlobalTransaction_EXCEPTION_OCCURED_WHILE_TRYING_TO_SET_THE_XARESOURCE_TIMEOUT_DUE_TO_0_ERROR_CODE_1 = new StringIdImpl(3721, "Exception occurred while trying to set the XAResource TimeOut due to {0} Error code = {1}");
  public static final StringId SmHelper_NATIVE_CODE_UNAVAILABLE = new StringIdImpl(3722, "native code unavailable");
  public static final StringId SystemAdmin_WAITING_5_SECONDS_FOR_LOCATOR_PROCESS_TO_TERMINATE = new StringIdImpl(3723, "Waiting 5 seconds for locator process to terminate...");
  public static final StringId SystemAdmin_WAITING_FOR_LOCATOR_PROCESS_WITH_PID_0_TO_TERMINATE = new StringIdImpl(3724, "Waiting for locator process, with pid {0,number,#} to terminate...");
  public static final StringId SystemAdmin_LOCATOR_PROCESS_HAS_TERMINATED = new StringIdImpl(3725, "Locator process has terminated.");
  public static final StringId SystemAdmin_LOCATOR_IN_0_WAS_KILLED_WHILE_IT_WAS_1_LOCATOR_PROCESS_ID_WAS_2 = new StringIdImpl(3726, "Locator in \"{0}\" was killed while it was {1}. Locator process id was {2}.");
  public static final StringId SystemAdmin_LOCATOR_IN_0_IS_1_LOCATOR_PROCESS_ID_IS_2 = new StringIdImpl(3727, "Locator in \"{0}\" is {1}. Locator process id is {2}.");
  public static final StringId SystemAdmin_LOCATOR_IN_0_IS_STOPPED = new StringIdImpl(3728, "Locator in \"{0}\" is stopped.");
  public static final StringId SystemAdmin_LOCATOR_IN_0_IS_STARTING = new StringIdImpl(3729, "Locator in \"{0}\" is starting.");
  public static final StringId SystemAdmin_CLEANED_UP_ARTIFACTS_LEFT_BY_THE_PREVIOUS_KILLED_LOCATOR = new StringIdImpl(3730, "Cleaned up artifacts left by the previous killed locator.");
  public static final StringId SystemAdmin_LOG_FILE_0_DOES_NOT_EXIST = new StringIdImpl(3731, "Log file \"{0}\" does not exist.");
  public static final StringId SystemAdmin_AN_IOEXCEPTION_WAS_THROWN_WHILE_TAILING_0 = new StringIdImpl(3732, "An IOException was thrown while tailing \"{0}\"\n");
  public static final StringId SystemAdmin_MERGING_THE_FOLLOWING_LOG_FILES = new StringIdImpl(3733, "Merging the following log files:");
  public static final StringId SystemAdmin_COMPLETED_MERGE_OF_0_LOGS_TO_1 = new StringIdImpl(3734, "Completed merge of {0} logs to \"{1}\".");
  public static final StringId SystemAdmin_WARNING_NO_STATS_MATCHED_0 = new StringIdImpl(3735, "[warning] No stats matched \"{0}\".");
  public static final StringId SystemAdmin_ERROR_OPERATION_0_FAILED_BECAUSE_1 = new StringIdImpl(3736, "ERROR: Operation \"{0}\" failed because: {1}.");
  public static final StringId SystemAdmin_ERROR_UNKNOWN_COMMAND_0 = new StringIdImpl(3737, "ERROR: Unknown command \"{0}\".");
  public static final StringId SystemAdmin_INFO_FOUND_0_MATCHES_FOR_1 = new StringIdImpl(3738, "[info] Found {0} instances matching \"{1}\":");
  public static final StringId SystemAdmin_THIS_PROGRAM_ALLOWS_GEMFIRE_TO_BE_MANAGED_FROM_THE_COMMAND_LINE_IT_EXPECTS_A_COMMAND_TO_EXECUTE_SEE_THE_HELP_TOPIC_0_FOR_A_SUMMARY_OF_SUPPORTED_OPTIONS_SEE_THE_HELP_TOPIC_1_FOR_A_CONCISE_DESCRIPTION_OF_COMMAND_LINE_SYNTAX_SEE_THE_HELP_TOPIC_2_FOR_A_DESCRIPTION_OF_SYSTEM_CONFIGURATION_SEE_THE_HELP_TOPIC_3_FOR_HELP_ON_A_SPECIFIC_COMMAND_USE_THE_4_OPTION_WITH_THE_COMMAND_NAME = new StringIdImpl(3739, "This program allows GemFire to be managed from the command line. It expects a command to execute.\nSee the help topic \"{0}\". For a summary of supported options see the help topic \"{1}\".\nFor a concise description of command line syntax see the help topic \"{2}\".\nFor a description of system configuration see the help topic \"{3}\".\nFor help on a specific command use the \"{4}\" option with the command name.");
  public static final StringId SystemAdmin_ALL_COMMAND_LINE_OPTIONS_START_WITH_A_AND_ARE_NOT_REQUIRED_EACH_OPTION_HAS_A_DEFAULT_THAT_WILL_BE_USED_WHEN_ITS_NOT_SPECIFIED_OPTIONS_THAT_TAKE_AN_ARGUMENT_ALWAYS_USE_A_SINGLE_CHARACTER_WITH_NO_SPACES_TO_DELIMIT_WHERE_THE_OPTION_NAME_ENDS_AND_THE_ARGUMENT_BEGINS_OPTIONS_THAT_PRECEDE_THE_COMMAND_WORD_CAN_BE_USED_WITH_ANY_COMMAND_AND_ARE_ALSO_PERMITTED_TO_FOLLOW_THE_COMMAND_WORD = new StringIdImpl(3740, "All command line options start with a \"-\" and are not required.\nEach option has a default that will be used when its not specified.\nOptions that take an argument always use a single \"=\" character, with no spaces, to delimit where the option name ends and the argument begins.\nOptions that precede the command word can be used with any command and are also permitted to follow the command word.");
  public static final StringId SystemAdmin_NO_HELP_FOR_OPTION_0 = new StringIdImpl(3741, "no help for option \"{0}]\"");
  public static final StringId SystemAdmin_EXPLAINATION_OF_COMMAND_OPTIONS = new StringIdImpl(3742, "The following synax is used in the usage strings:\n\"[]\" designate an optional item\n\"()\" are used to group items\n\"<>\" designate non-literal text. Used to designate logical items\n\"*\" suffix means zero or more of the previous item\n\"|\" means the item to the left or right is required");
  public static final StringId SystemAdmin_ERROR_INVALID_HELP_TOPIC_0 = new StringIdImpl(3743, "ERROR: Invalid help topic \"{0}\".");
  public static final StringId SystemAdmin_USAGE = new StringIdImpl(3744, "Usage");
  public static final StringId SystemAdmin_ERROR_INVALID_COMMAND_0 = new StringIdImpl(3745, "ERROR: Invalid command \"{0}\".");
  public static final StringId SystemAdmin_GEMFIRE_HELP = new StringIdImpl(3746, "gemfire requires one of the following command strings:\n{0}\nFor additional help on a command specify it along with the \"{1}\" option.\nThe \"{2}\" option causes gemfire to print out extra information when it fails.\nThe \"{1}\" and \"{3}\" are synonyms that cause gemfire to print out help information instead of performing a task.\nThe \"{4}\" option quiets gemfire down by suppressing extra messages.\nThe \"{5}\" option passes <vmOpt> to the java vm''s command line.");
  public static final StringId SystemAdmin_VERSION_HELP = new StringIdImpl(3747, "Prints GemFire product version information.");
  public static final StringId SystemAdmin_LICENSE_HELP_0 = new StringIdImpl(3748, "Prints any current GemFire licenses and information needed to obtain a new license.\nThe \"{0}\" option can be used to specify the license file to print.");
  public static final StringId SystemAdmin_HELP_HELP = new StringIdImpl(3749, "Prints information on how to use this executable.\nIf an optional help topic is specified then more detailed help is printed.");
  public static final StringId SystemAdmin_STATS_HELP_PART_A = new StringIdImpl(3750, "Prints statistic values from a statistic archive\nBy default all statistics are printed.\nThe statSpec arguments can be used to print individual resources or a specific statistic.\nThe format of a statSpec is: an optional combine operator, followed by an optional instanceId, followed by an optional typeId, followed by an optional statId.\nA combine operator can be \"{0}\" to combine all matches in the same file, or \"{1}\" to combine all matches across all files.\nAn instanceId must be the name or id of a resource.\nA typeId is a \"{2}\" followed by the name of a resource type.\nA statId is a \"{3}\" followed by the name of a statistic.\nA typeId or instanceId with no statId prints out all the matching resources and all their statistics.\nA typeId or instanceId with a statId prints out just the named statistic on the matching resources.\nA statId with no typeId or instanceId matches all statistics with that name.\nThe \"{4}\" option causes statistic descriptions to also be printed.\nThe \"{5}\" option, in conjunction with \"{6}\", causes the printed statistics to all be raw, unfiltered, values.\nThe \"{7}\" option, in conjunction with \"{6}\", causes the printed statistics to be the rate of change, per second, of the raw values.\nThe \"{8}\" option, in conjunction with \"{6}\", causes the printed statistics to be the rate of change, per sample, of the raw values.\nThe \"{9}\" option, in conjunction with \"{6}\", causes statistics whose values are all zero to not be printed.");
  public static final StringId SystemAdmin_STATS_HELP_PART_B = new StringIdImpl(3751, "The \"{0}\" option, in conjunction with \"{1}\", causes statistics samples taken before this time to be ignored. The argument format must match \"{2}\".\nThe \"{3}\" option, in conjunction with \"{1}\", causes statistics samples taken after this time to be ignored. The argument format must match \"{2}\".\nThe \"{1}\" option causes the data to come from an archive file.");
  public static final StringId SystemAdmin_ENCRYPTS_A_PASSWORD_FOR_USE_IN_CACHE_XML_DATA_SOURCE_CONFIGURATION = new StringIdImpl(3752, "Encrypts a password for use in cache.xml data source configuration.");
  public static final StringId SystemAdmin_START_LOCATOR_HELP = new StringIdImpl(3753, "Starts a locator.\nThe \"{0}\" option specifies the port the locator will listen on. It defaults to \"{1}\"\nThe \"{2}\" option specifies the address the locator will listen on. It defaults to listening on all local addresses.\nThe \"{3}\" option can be used to specify the directory the locator will run in.\nThe \"{4}\" option can be used to specify the gemfire.properties file for configuring the locator''s distributed system.  The file''s path should be absolute, or relative to the locator''s directory ({3})\nThe \"{5}\" option can be used to specify whether peer locator service should be enabled. True (the default) will enable the service.\nThe \"{6}\" option can be used to specify whether server locator service should be enabled. True (the default) will enable the service.\nThe \"{7}\" option can be used to specify a host name or ip address that will be sent to clients so they can connect to this locator. The default is to use the address the locator is listening on.\nThe \"{8}\" option can be used to set system properties for the locator VM\nThe \"{9}\" option can be used to set vendor-specific VM options and is usually used to increase the size of the locator VM when using multicast.\n");
   public static final StringId SystemAdmin_STOP_LOCATOR_HELP = new StringIdImpl(3754, "Stops a locator.\nThe \"{0}\" option specifies the port the locator is listening on. It defaults to \"{1}\"\nThe \"{2}\" option specifies the address the locator is listening on. It defaults to the local host''s address.\nThe \"{3}\" option can be used to specify the directory the locator is running in.");
  public static final StringId SystemAdmin_STATUS_LOCATOR_HELP = new StringIdImpl(3755, "Prints the status of a locator. The status string will one of the following:\n{0}\nThe \"{1}\" option can be used to specify the directory of the locator whose status is desired.");
  public static final StringId SystemAdmin_INFO_LOCATOR_HELP = new StringIdImpl(3756, "Prints information on a locator.\nThe information includes the process id of the locator, if the product is not running in PureJava mode.\nThe \"{0}\" option can be used to specify the directory of the locator whose information is desired.");
  public static final StringId SystemAdmin_TAIL_LOCATOR_HELP = new StringIdImpl(3757, "Prints the last 64K bytes of the locator''s log file.\nThe \"{0}\" option can be used to specify the directory of the locator whose information is desired.");
  public static final StringId SystemAdmin_MERGE_LOGS = new StringIdImpl(3758, "Merges multiple logs files into a single log.\nThe \"{0}\" option can be used to specify the file to write the merged log to. The default is stdout.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_TO_WRITE_OUTPUT_TO_THE_SPECIFIED_FILE_THE_FILE_IS_OVERWRITTEN_IF_IT_ALREADY_EXISTS = new StringIdImpl(3759, "Causes gemfire to write output to the specified file. The file is overwritten if it already exists.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_TO_PRINT_OUT_EXTRA_INFORMATION_WHEN_IT_FAILS_THIS_OPTION_IS_SUPPORTED_BY_ALL_COMMANDS = new StringIdImpl(3760, "Causes gemfire to print out extra information when it fails. This option is supported by all commands.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_TO_PRINT_DETAILED_INFORMATION_WITH_THE_0_COMMAND_IT_MEANS_STATISTIC_DESCRIPTIONS = new StringIdImpl(3761, "Causes gemfire to print detailed information.  With the \"{0}\" command it means statistic descriptions.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_0_COMMAND_TO_PRINT_UNFILTERED_RAW_STATISTIC_VALUES_THIS_IS_THE_DEFAULT_FOR_NONCOUNTER_STATISTICS = new StringIdImpl(3762, "Causes gemfire \"{0}\" command to print unfiltered, raw, statistic values. This is the default for non-counter statistics.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_0_COMMAND_TO_PRINT_THE_RATE_OF_CHANGE_PER_SECOND_FOR_STATISTIC_VALUES_THIS_IS_THE_DEFAULT_FOR_COUNTER_STATISTICS = new StringIdImpl(3763, "Causes gemfire \"{0}\" command to print the rate of change, per second, for statistic values. This is the default for counter statistics.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_0_COMMAND_TO_PRINT_THE_RATE_OF_CHANGE_PER_SAMPLE_FOR_STATISTIC_VALUES = new StringIdImpl(3764, "Causes gemfire \"{0}\" command to print the rate of change, per sample, for statistic values.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_0_COMMAND_TO_NOT_PRINT_STATISTICS_WHOSE_VALUES_ARE_ALL_ZERO = new StringIdImpl(3765, "Causes gemfire \"{0}\" command to not print statistics whose values are all zero.");
  public static final StringId SystemAdmin_USED_TO_SPECIFY_A_NONDEFAULT_PORT_WHEN_STARTING_OR_STOPPING_A_LOCATOR = new StringIdImpl(3766, "Used to specify a non-default port when starting or stopping a locator.");
  public static final StringId SystemAdmin_USED_TO_SPECIFY_A_SPECIFIC_IP_ADDRESS_TO_LISTEN_ON_WHEN_STARTING_OR_STOPPING_A_LOCATOR = new StringIdImpl(3767, "Used to specify a specific IP address to listen on when starting or stopping a locator.");
  public static final StringId SystemAdmin_THE_ARGUMENT_IS_THE_LICENSE_FILE_WHOSE_CONTENTS_WILL_BE_PRINTED_DEFAULTS_TO_0 = new StringIdImpl(3768, "The argument is the license file whose contents will be printed. Defaults to \"{0}\"");
  public static final StringId SystemAdmin_THE_ARGUMENT_IS_THE_STATISTIC_ARCHIVE_FILE_THE_0_COMMAND_SHOULD_READ = new StringIdImpl(3769, "The argument is the statistic archive file the \"{0}\" command should read.");
  public static final StringId SystemAdmin_CAUSES_GEMFIRE_TO_PRINT_OUT_INFORMATION_INSTEAD_OF_PERFORMING_THE_COMMAND_THIS_OPTION_IS_SUPPORTED_BY_ALL_COMMANDS = new StringIdImpl(3770, "Causes GemFire to print out information instead of performing the command. This option is supported by all commands.");
  public static final StringId SystemAdmin_TURNS_ON_QUIET_MODE_THIS_OPTION_IS_SUPPORTED_BY_ALL_COMMANDS = new StringIdImpl(3771, "Turns on quiet mode. This option is supported by all commands.");
  public static final StringId SystemAdmin_CAUSES_THE_0_COMMAND_TO_IGNORE_STATISTICS_SAMPLES_TAKEN_BEFORE_THIS_TIME_THE_ARGUMENT_FORMAT_MUST_MATCH_1 = new StringIdImpl(3772, "Causes the \"{0}\" command to ignore statistics samples taken before this time. The argument format must match \"{1}\".");
  public static final StringId SystemAdmin_CAUSES_THE_0_COMMAND_TO_IGNORE_STATISTICS_SAMPLES_TAKEN_AFTER_THIS_TIME_THE_ARGUMENT_FORMAT_MUST_MATCH_1 = new StringIdImpl(3773, "Causes the \"{0}\" command to ignore statistics samples taken after this time. The argument format must match \"{1}\".");
  public static final StringId SystemAdmin_DIR_ARGUMENT_HELP = new StringIdImpl(3774, "The argument is the system directory the command should operate on.\nIf the argument is empty then a default system directory will be search for.\nHowever the search will not include the \"{0}\" file.\nBy default if a command needs a system directory, and one is not specified, then a search is done. If a \"{0}\" file can be located then \"{1}\" property from that file is used. Otherwise if the \"{2}\" environment variable is set to a directory that contains a subdirectory named \"{3}\" then that directory is used.\nThe property file is search for in the following locations:\n1. The current working directory.\n2. The user''s home directory.\n3. The class path.\nAll commands except \"{4}\", and \"{5}\" use the system directory.");
  public static final StringId SystemAdmin_SETS_A_JAVA_SYSTEM_PROPERTY_IN_THE_LOCATOR_VM_USED_MOST_OFTEN_FOR_CONFIGURING_SSL_COMMUNICATION = new StringIdImpl(3775, "Sets a Java system property in the locator VM.  Used most often for configuring SSL communication.");
  public static final StringId SystemAdmin_SETS_A_JAVA_VM_X_SETTING_IN_THE_LOCATOR_VM_USED_MOST_OFTEN_FOR_INCREASING_THE_SIZE_OF_THE_VIRTUAL_MACHINE = new StringIdImpl(3776, "Sets a Java VM X setting in the locator VM.  Used most often for increasing the size of the virtual machine.");
  public static final StringId SystemAdmin_HELP = new StringIdImpl(3777, "help");
  public static final StringId SystemAdmin_ERROR_UNKNOWN_OPTION_0 = new StringIdImpl(3778, "ERROR: Unknown option \"{0}\".");
  public static final StringId SystemAdmin_ERROR_WRONG_NUMBER_OF_COMMAND_LINE_ARGS = new StringIdImpl(3779, "ERROR: Wrong number of command line args.");
  public static final StringId SystemAdmin_ERROR_UNEXPECTED_COMMAND_LINE_ARGUMENTS_0 = new StringIdImpl(3780, "ERROR: unexpected command line arguments: \"{0}\".");
  public static final StringId SystemAdmin_GEMFIRE_PRODUCT_DIRECTORY_0 = new StringIdImpl(3781, "GemFire product directory: {0}");
  public static final StringId SystemAdmin_LOCATOR_START_COMPLETE = new StringIdImpl(3782, "Locator start complete.");
  public static final StringId SystemAdmin_LOCATOR_STOP_COMPLETE = new StringIdImpl(3783, "Locator stop complete.");
  public static final StringId SystemAdmin_ERROR_EXPECTED_AT_LEAST_ONE_LOG_FILE_TO_MERGE = new StringIdImpl(3784, "ERROR: expected at least one log file to merge.");
  public static final StringId AgentConfigImpl_USING_DEFAULT_CONFIGURATION_BECAUSE_PROPERTY_FILE_WAS_FOUND = new StringIdImpl(3785, "Using default configuration because property file was not found.");
  public static final StringId AgentConfigImpl_CONFIGURATION_LOADED_FROM_0 = new StringIdImpl(3786, "Configuration loaded from: {0}.");
  public static final StringId AgentConfigImpl_NAME_OF_THE_AGENTS_LOG_FILE = new StringIdImpl(3787, "Name of the agent''s log file");
  public static final StringId AgentConfigImpl_MINIMUM_LEVEL_OF_LOGGING_PERFORMED_BY_AGENT = new StringIdImpl(3788, "Minimum level of logging performed by agent. Valid values are: all, finest, finer, fine, config, info, warning, error, severe and none.");
  public static final StringId AgentConfigImpl_WHETHER_THE_AGENT_SHOULD_PRINT_DEBUGGING_INFORMATION = new StringIdImpl(3789, "Whether the agent should print debugging information");
  public static final StringId AgentConfigImpl_LIMIT_IN_MEGABYTES_OF_HOW_MUCH_DISK_SPACE_CAN_BE_CONSUMED_BY_OLD_INACTIVE_LOG_FILES = new StringIdImpl(3790, "Limit, in megabytes, of how much disk space can be consumed by old inactive log files. This value (in megabytes) should be in the range: 0-1000000.");
  public static final StringId AgentConfigImpl_LIMIT_IN_MEGABYTES_OF_HOW_LARGE_THE_CURRENT_STATISTIC_ARCHIVE_FILE_CAN_GROW_BEFORE_IT_IS_CLOSED_AND_ARCHIVAL_ROLLS_ON_TO_A_NEW_FILE = new StringIdImpl(3791, "Limit, in megabytes, of how large the current log file can grow before it is closed and log rolls on to a new file. This value (in megabytes) should be in the range: 0-1000000.");
  public static final StringId AgentConfigImpl_MULTICAST_PORT_USED_TO_CONNECT_TO_DISTRIBUTED_SYSTEM = new StringIdImpl(3792, "Multicast port used to connect to distributed system. To use IP multicast, you must also define mcast-address. The value must be in the range: 0-65535.");
  public static final StringId AgentConfigImpl_MULTICAST_ADDRESS_USED_TO_CONNECT_TO_DISTRIBUTED_SYSTEM = new StringIdImpl(3793, "Multicast address used to connect to distributed system. To use multicast, you must also define mcast-port, the IP port.");
  public static final StringId AgentConfigImpl_ADDRESSES_OF_THE_LOCATORS_OF_THE_DISTRIBUTED_SYSTEM = new StringIdImpl(3794, "A comma-separated list of address(es) of the locator(s) in the distributed system in host[port] form. E.g. locators=host1[port1],host2[port2],...,hostn[portn]");
  public static final StringId AgentConfigImpl_XML_CONFIGURATION_FILE_FOR_MANAGED_ENTITIES = new StringIdImpl(3795, "The name of an XML file that specifies the configuration for the managed entity administered by the Distributed System. The XML file must conform to the dtd - doc-files/ds5_0.dtd.");
  public static final StringId AgentConfigImpl_WILL_THE_AGENT_AUTOMATICALLY_CONNECT_TO_THE_DISTRIBUTED_SYSTEM = new StringIdImpl(3796, "Whether the JMX agent will connect ''automatically'' to the distributed system that it is configured to monitor.");
  public static final StringId AgentConfigImpl_COMMAND_PREFIX_USED_FOR_LAUNCHING_MEMBERS_OF_THE_DISTRIBUTED_SYSTEM = new StringIdImpl(3797, "Command prefix used for launching members of the distributed system");
  public static final StringId AgentConfigImpl_WILL_THE_AGENT_START_THE_HTTP_JMX_ADAPTER = new StringIdImpl(3798, "Whether the HTTP adapter is enabled in the JMX agent.");
  public static final StringId AgentConfigImpl_BIND_ADDRESS_OF_HTTP_ADAPTERS_SOCKETS = new StringIdImpl(3799, "Bind address of HTTP adapter''s sockets");
  public static final StringId AgentConfigImpl_THE_PORT_ON_WHICH_THE_HTTP_ADAPTER_WILL_BE_STARTED = new StringIdImpl(3800, "The port on which the HTTP adapter will be started. This value should be in the range: 0-65535.");
  public static final StringId AgentConfigImpl_WILL_THE_AGENT_START_THE_RMI_JMX_ADAPTER = new StringIdImpl(3801, "Whether the RMI JMX adapter is enabled.");
  public static final StringId AgentConfigImpl_WILL_THE_AGENT_HOST_AN_RMI_REGISTRY = new StringIdImpl(3802, "Whether the JMX agent should start RMI registry. Alternatively, a registry outside of the JMX agent VM can be used.");
  public static final StringId AgentConfigImpl_BIND_ADDRESS_OF_RMI_ADAPTERS_SOCKETS = new StringIdImpl(3803, "Bind address of RMI adapter''s sockets");
  public static final StringId AgentConfigImpl_THE_PORT_ON_WHICH_TO_CONTACT_THE_RMI_REGISTER = new StringIdImpl(3804, "The port on which to contact the RMI registry. The value must be in the range: 0-65535.");
  public static final StringId AgentConfigImpl_WILL_THE_AGENT_START_THE_SNMP_JMX_ADAPTER = new StringIdImpl(3805, "Whether the SNMP JMX adapter will be enabled.");
  public static final StringId AgentConfigImpl_BIND_ADDRESS_OF_SNMP_ADAPTERS_SOCKETS = new StringIdImpl(3806, "Bind address of SNMP adapter''s sockets");
  public static final StringId AgentConfigImpl_THE_DIRECTORY_IN_WHICH_SNMP_CONFIGURATION_RESIDES = new StringIdImpl(3807, "The directory in which SNMP configuration resides");
  public static final StringId AgentConfigImpl_WILL_THE_AGENT_COMMUNICATE_USING_SSL = new StringIdImpl(3808, "Whether the JMX Agent will use the SSL protocol for communication.");
  public static final StringId AgentConfigImpl_THE_SSL_PROTOCOLS_USED_BY_THE_AGENT = new StringIdImpl(3809, "The space-separated list of the SSL protocols to be used when connecting to the JMX agent.");
  public static final StringId AgentConfigImpl_THE_SSL_CIPHERS_USED_BY_THE_AGENT = new StringIdImpl(3810, "The space-separated list of the SSL ciphers to be used when connecting to the JMX Agent.");
  public static final StringId AgentConfigImpl_WILL_THE_AGENT_REQUIRE_SSL_AUTHENTICATION = new StringIdImpl(3811, "Whether or not SSL connections to the RMI adapter require authentication. If true, needs client authentication for RMI and other non-HTTP connectors/adaptors.");
  public static final StringId AgentConfigImpl_WILL_THE_HTTP_ADAPTER_REQUIRE_SSL_AUTHENTICATION = new StringIdImpl(3812, "Whether SSL connections to the HTTP adapter will need authentication.");
  public static final StringId AgentConfigImpl_WILL_THE_HTTP_JMX_ADAPTER_USE_HTTP_AUTHENTICATION = new StringIdImpl(3813, "Whether the HTTP adapter will use HTTP authentication.");
  public static final StringId AgentConfigImpl_THE_USER_NAME_FOR_AUTHENTICATION_IN_THE_HTTP_JMX_ADAPTER = new StringIdImpl(3814, "The user name for authentication in the HTTP JMX adapter");
  public static final StringId AgentConfigImpl_THE_PASSWORD_FOR_AUTHENTICATION_IN_THE_HTTP_JMX_ADAPTER = new StringIdImpl(3815, "The password for authentication in the HTTP JMX adapter");
  public static final StringId AgentConfigImpl_DOES_THE_DISTRIBUTED_SYSTEM_COMMUNICATE_USING_SSL = new StringIdImpl(3816, "Whether to use the SSL protocol for communication between members of the admin distributed system. If set to true, locators should be used.");
  public static final StringId AgentConfigImpl_SSL_PROTOCOLS_USED_TO_COMMUNICATE_WITH_DISTRIBUTED_SYSTEM = new StringIdImpl(3817, "A space-separated list of the SSL protocols used to communicate with distributed system.");
  public static final StringId AgentConfigImpl_SSL_CIPHERS_USED_TO_COMMUNICATE_WITH_DISTRIBUTED_SYSTEM = new StringIdImpl(3818, "A space-separated list of the SSL ciphers to be used to communicate with distributed system.");
  public static final StringId AgentConfigImpl_DOES_CONNECTING_TO_THE_DISTRIBUTED_SYSTEM_REQUIRE_SSL_AUTHENTICATION = new StringIdImpl(3819, "Whether connection to the distributed system needs SSL authentication.");
  public static final StringId AgentConfigImpl_PROPERTY_FILE_FROM_WHICH_AGENT_READS_CONFIGURATION = new StringIdImpl(3820, "Name and path of the Agent''s properties file from which agent reads configuration");
  public static final StringId AgentConfigImpl_HOST_ON_WHICH_THE_DISTRIBUTED_SYSTEMS_LOCATOR_RUNS = new StringIdImpl(3821, "Host on which the distributed system''s locator runs");
  public static final StringId SystemAdmin_USED_TO_SPECIFY_THE_0_FILE_TO_BE_USED_IN_CONFIGURING_THE_LOCATORS_DISTRIBUTEDSYSTEM = new StringIdImpl(3822, "Used to specify the {0} file to be used in configuring the locator''s DistributedSystem.");
  public static final StringId AgentConfigImpl_GEMFIRE_PRODUCT_DIRECTORY_USED_TO_LAUNCH_A_LOCATOR = new StringIdImpl(3823, "GemFire product directory used to launch a locator");
  public static final StringId AgentConfigImpl_DIRECTORY_IN_WHICH_A_LOCATOR_WILL_BE_LAUNCHED = new StringIdImpl(3824, "Directory in which a locator will be launched");
  public static final StringId AgentConfigImpl_COMMAND_PREFIX_USED_WHEN_LAUNCHING_A_LOCATOR = new StringIdImpl(3825, "Command prefix used when launching a locator");
  public static final StringId AgentConfigImpl_IP_ADDRESS_TO_USE_WHEN_CONTACTING_LOCATOR = new StringIdImpl(3826, "IP address to use when contacting locator");
  public static final StringId AgentConfigImpl_PROPERTIES_FOR_CONFIGURING_A_LOCATORS_DISTRIBUTED_SYSTEM = new StringIdImpl(3827, "Properties for configuring a locator''s distributed system");
  public static final StringId AgentLauncher_STARTS_THE_GEMFIRE_JMX_AGENT = new StringIdImpl(3828, "Starts the GemFire JMX Agent");
  public static final StringId AgentLauncher_VMARG = new StringIdImpl(3829, "<vmarg> a VM-option passed to the agent''s VM, example -J-Xmx1024M for a 1 Gb heap");
  public static final StringId AgentLauncher_DIR = new StringIdImpl(3830, "<dir> Directory in which agent runs, default is the current directory");
  public static final StringId AgentLauncher_PROP = new StringIdImpl(3831, "<prop> A configuration property/value passed to the agent");
  public static final StringId AgentLauncher_SEE_HELP_CONFIG = new StringIdImpl(3832, "(see \"help config\" for more details)");
  public static final StringId AgentLauncher_STOPS_A_GEMFIRE_JMX_AGENT = new StringIdImpl(3833, "Stops a GemFire JMX Agent");
  public static final StringId AgentLauncher_REPORTS_THE_STATUS_AND_THE_PROCESS_ID_OF_A_GEMFIRE_JMX_AGENT = new StringIdImpl(3834, "Reports the status and the process id of a GemFire JMX Agent");
  public static final StringId AgentLauncher_AGENT_CONFIGURATION_PROPERTIES = new StringIdImpl(3835, "Agent configuration properties");
  public static final StringId AgentLauncher_DEFAULT = new StringIdImpl(3836, "Default");
  public static final StringId AgentLauncher_STARTING_JMX_AGENT_WITH_PID_0 = new StringIdImpl(3837, "Starting JMX Agent with pid: {0,number,#}");
  public static final StringId AgentLauncher_STARTING_AGENT = new StringIdImpl(3838, "Starting agent");
  public static final StringId AgentLauncher_UNCAUGHT_EXCEPTION_IN_THREAD_0 = new StringIdImpl(3839, "Uncaught exception in thread {0}");
  public static final StringId AgentLauncher_0_HAS_STOPPED = new StringIdImpl(3840, "The {0} has shut down.");
  public static final StringId AgentLauncher_TIMEOUT_WAITING_FOR_0_TO_SHUTDOWN_STATUS_IS_1 = new StringIdImpl(3841, "Timeout waiting for {0} to shutdown, status is: {1}");
  public static final StringId AgentLauncher_NO_HELP_AVAILABLE_FOR_0 = new StringIdImpl(3842, "No help available for \"{0}\"");
  public static final StringId AgentLauncher_AGENT_HELP = new StringIdImpl(3843, "agent help");
  public static final StringId AgentLauncher_UNKNOWN_COMMAND_0 = new StringIdImpl(3844, "Unknown command: {0}");
  public static final StringId AgentLauncher_ERROR_0 = new StringIdImpl(3845, "Error : {0}");
  public static final StringId AgentLauncher_0_PID_1_STATUS = new StringIdImpl(3846, "{0} pid: {1,number,#} status: ");
  public static final StringId AgentLauncher_SHUTDOWN = new StringIdImpl(3847, "shutdown");
  public static final StringId AgentLauncher_STARTING = new StringIdImpl(3848, "starting");
  public static final StringId AgentLauncher_RUNNING = new StringIdImpl(3849, "running");
  public static final StringId AgentLauncher_SHUTDOWN_PENDING = new StringIdImpl(3850, "shutdown pending");
  public static final StringId AgentLauncher_UNKNOWN = new StringIdImpl(3851, "unknown");
  public static final StringId MsgStreamer_CLOSING_DUE_TO_0 = new StringIdImpl(3852, "closing due to {0}");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_BEGIN_NESTED_TRANSACTION_IS_NOT_SUPPORTED = new StringIdImpl(3853, "Nested transaction is not supported");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_IS_NULL_CANNOT_COMMIT_A_NULL_TRANSACTION = new StringIdImpl(3854, "Transaction is null, cannot commit a null transaction");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_GLOBAL_TRANSACTION_IS_NULL_CANNOT_COMMIT_A_NULL_GLOBAL_TRANSACTION = new StringIdImpl(3855, "Global Transaction is null, cannot commit a null global transaction");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_NOT_ACTIVE_CANNOT_BE_COMMITTED_TRANSACTION_STATUS_0 = new StringIdImpl(3856, "transaction not active, cannot be committed. Transaction Status= {0}");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_IS_NOT_ACTIVE_AND_CANNOT_BE_COMMITTED = new StringIdImpl(3857, "transaction is not active and cannot be committed");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_ROLLED_BACK_BECAUSE_OF_EXCEPTION_IN_NOTIFYBEFORECOMPLETION_FUNCTION_CALL_ACTUAL_EXCEPTION_0 = new StringIdImpl(3858, "Transaction rolled back because of Exception in notifyBeforeCompletion processing");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_COMMIT_TRANSACTION_ROLLED_BACK_BECAUSE_A_USER_MARKED_IT_FOR_ROLLBACK = new StringIdImpl(3859, "Transaction rolled back because a user marked it for Rollback");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_NO_TRANSACTION_EXISTS = new StringIdImpl(3860, "no transaction exists");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_NO_GLOBAL_TRANSACTION_EXISTS = new StringIdImpl(3861, "no global transaction exists");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_STATUS_DOES_NOT_ALLOW_ROLLBACK_TRANSACTIONAL_STATUS_0 = new StringIdImpl(3862, "Transaction status does not allow Rollback .Transactional status = {0}");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_ALREADY_IN_A_ROLLING_BACK_STATE_TRANSACTIONAL_STATUS_0 = new StringIdImpl(3863, "Transaction already in a Rolling Back state.Transactional status = {0}");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_ROLLBACK_TRANSACTION_STATUS_DOES_NOT_ALLOW_ROLLBACK = new StringIdImpl(3864, "Transaction status does not allow Rollback");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETROLLBACKONLY_NO_GLOBAL_TRANSACTION_EXISTS = new StringIdImpl(3865, "no global transaction exists");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETROLLBACKONLY_TRANSACTION_CANNOT_BE_MARKED_FOR_ROLLBACK_TRANSCATION_STATUS_0 = new StringIdImpl(3866, "Transaction cannot be marked for rollback. Transcation status = {0}");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETTRANSACTIONTIMEOUT_NO_GLOBAL_TRANSACTION_EXISTS = new StringIdImpl(3867, "no global transaction exists");
  public static final StringId GemFireCacheImpl_STARTING_GEMFIRE_MEMCACHED_SERVER_ON_PORT_0_FOR_1_PROTOCOL = new StringIdImpl(3868, "Starting GemFireMemcachedServer on port {0} for {1} protocol");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_SETTRANSACTIONTIMEOUT_TRANSACTION_HAS_EITHER_EXPIRED_OR_ROLLEDBACK_OR_COMITTED = new StringIdImpl(3869, "Transaction has either expired or rolledback or comitted");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_CANNOT_RESUME_A_NULL_TRANSACTION = new StringIdImpl(3870, "cannot resume a null transaction");
  public static final StringId AbstractDistributionConfig_SECURITY_CLIENT_DHALGO_NAME_0 = new StringIdImpl(3871, "User defined name for the symmetric encryption algorithm to use in Diffie-Hellman key exchange for encryption of credentials.  Defaults to \"{0}\". Legal values can be any of the available symmetric algorithm names in JDK like \"DES\", \"DESede\", \"AES\", \"Blowfish\". It may be required to install Unlimited Strength Jurisdiction Policy Files from Sun for some symmetric algorithms to work (like \"AES\")");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_RESUME_ERROR_IN_LISTING_THREAD_TO_TRANSACTION_MAP_DUE_TO_0 = new StringIdImpl(3872, "Error in listing thread to transaction map due to {0}");
  public static final StringId TransactionManagerImpl_TRANSACTIONMANAGERIMPL_GETGLOBALTRANSACTION_NO_TRANSACTION_EXISTS = new StringIdImpl(3873, "no transaction exists");
  public static final StringId UserTransactionImpl_USERTRANSACTIONIMPL_SETTRANSACTIONTIMEOUT_CANNOT_SET_A_NEGATIVE_TIME_OUT_FOR_TRANSACTIONS = new StringIdImpl(3874, "Cannot set a negative Time Out for transactions");
  public static final StringId MergeLogFiles_USAGE = new StringIdImpl(3875, "Usage");
  public static final StringId MergeLogFiles_NUMBER_OF_PARENT_DIRS_TO_PRINT = new StringIdImpl(3876, "Number of parent dirs to print");
  public static final StringId MergeLogFiles_FILE_IN_WHICH_TO_PUT_MERGED_LOGS = new StringIdImpl(3877, "File in which to put merged logs");
  public static final StringId MergeLogFiles_SEARCH_FOR_PIDS_IN_FILE_NAMES_AND_USE_THEM_TO_IDENTIFY_FILES = new StringIdImpl(3878, "Search for PIDs in file names and use them to identify files");
  public static final StringId MergeLogFiles_ALIGN_NONTIMESTAMPED_LINES_WITH_OTHERS = new StringIdImpl(3879, "Align non-timestamped lines with others");
  public static final StringId MergeLogFiles_SUPPRESS_OUTPUT_OF_BLANK_LINES = new StringIdImpl(3880, "Suppress output of blank lines");
  public static final StringId MergeLogFiles_USE_MULTITHREADING_TO_TAKE_ADVANTAGE_OF_MULTIPLE_CPUS = new StringIdImpl(3881, "Use multithreading to take advantage of multiple CPUs");
  public static final StringId MergeLogFiles_MERGES_MULTIPLE_GEMFIRE_LOG_FILES_AND_SORTS_THEM_BY_TIMESTAMP = new StringIdImpl(3882, "Merges multiple GemFire log files and sorts them by timestamp.");
  public static final StringId MergeLogFiles_THE_MERGED_LOG_FILE_IS_WRITTEN_TO_SYSTEM_OUT_OR_A_FILE = new StringIdImpl(3883, "The merged log file is written to System.out (or a file).");
  public static final StringId MergeLogFiles_MISSING_NUMBER_OF_PARENT_DIRECTORIES = new StringIdImpl(3884, "Missing number of parent directories");
  public static final StringId MergeLogFiles_NOT_A_NUMBER_0 = new StringIdImpl(3885, "Not a number: {0}");
  public static final StringId MergeLogFiles_MISSING_MERGE_FILE_NAME = new StringIdImpl(3886, "Missing merge file name");
  public static final StringId MergeLogFiles_FILE_0_DOES_NOT_EXIST = new StringIdImpl(3887, "File \"{0}\" does not exist");
  public static final StringId MergeLogFiles_MISSING_FILENAME = new StringIdImpl(3888, "Missing filename");
  public static final StringId MergeLogFiles_LOG_FILE_READER = new StringIdImpl(3889, "Log File Reader");
  public static final StringId MergeLogFiles_EXCEPTION_IN_0 = new StringIdImpl(3890, "Exception in {0}");
  public static final StringId MergeLogFiles_READER_THREADS = new StringIdImpl(3891, "Reader threads");
  public static final StringId OSProcess_WARNING_0_IS_NOT_A_DIRECTORY_DEFAULTING_TO_CURRENT_DIRECTORY_1 = new StringIdImpl(3892, "WARNING: \"{0}\" is not a directory. Defaulting to current directory \"{1}\".");
  public static final StringId OSProcess_REAPER_THREAD = new StringIdImpl(3893, "Reaper Thread");
  public static final StringId ConnectionTable_CANCEL_AFTER_ACCEPT = new StringIdImpl(3894, "cancel after accept");
  public static final StringId ConnectionTable_CONNECTION_TABLE_NO_LONGER_IN_USE = new StringIdImpl(3895, "Connection table no longer in use");
  public static final StringId ConnectionTable_PENDING_CONNECTION_CANCELLED = new StringIdImpl(3896, "pending connection cancelled");
  public static final StringId ConnectionTable_PENDING_CONNECTION_CLOSED = new StringIdImpl(3897, "pending connection closed");
  public static final StringId ConnectionTable_SOMEONE_ELSE_CREATED_THE_CONNECTION = new StringIdImpl(3898, "someone else created the connection");
  public static final StringId ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED = new StringIdImpl(3899, "Connection table being destroyed");
  public static final StringId ConnectionTable_THREAD_FINALIZATION = new StringIdImpl(3900, "thread finalization");
  public static final StringId ConnectionTable_P2P_CONNECTION_TABLE_MAY_BE_THRASHING_INCREASING_WATER_LEVELS_TO_0_1 = new StringIdImpl(3901, "P2P connection table may be thrashing - increasing water levels to {0}, {1}");
  public static final StringId ConnectException_COULD_NOT_CONNECT_TO_0 = new StringIdImpl(3902, "Could not connect to: {0}");
  public static final StringId ConnectException_CAUSES = new StringIdImpl(3903, "Causes:");
  public static final StringId ConnectException_COULD_NOT_CONNECT = new StringIdImpl(3904, "Could not connect");
  public static final StringId SortLogFile_USAGE = new StringIdImpl(3905, "Usage");
  public static final StringId SortLogFile_FILE_IN_WHICH_TO_PUT_SORTED_LOG = new StringIdImpl(3906, "File in which to put sorted log");
  public static final StringId SortLogFile_SORTS_A_GEMFIRE_LOG_FILE_BY_TIMESTAMP_THE_MERGED_LOG_FILE_IS_WRITTEN_TO_SYSTEM_OUT_OR_A_FILE = new StringIdImpl(3907, "Sorts a GemFire log file by timestamp. The merged log file is written to System.out (or a file).");
  public static final StringId SortLogFile_FILE_0_DOES_NOT_EXIST = new StringIdImpl(3908, "File \"{0}\" does not exist");
  public static final StringId SortLogFile_EXTRANEOUS_COMMAND_LINE_0 = new StringIdImpl(3909, "Extraneous command line: {0}");
  public static final StringId SortLogFile_MISSING_FILENAME = new StringIdImpl(3910, "Missing filename");
  public static final StringId PureLogWriter_IGNORING_EXCEPTION = new StringIdImpl(3911, "Ignoring exception: ");
  public static final StringId GemFireMonitorService_SIMPLEADMINCONXCLEANUPTHREAD = new StringIdImpl(3912, "SimpleAdminConxCleanupThread");
  public static final StringId CacheHealthEvaluator_THE_AVERAGE_DURATION_OF_A_CACHE_NETSEARCH_0_MS_EXCEEDS_THE_THRESHOLD_1_MS = new StringIdImpl(3913, "The average duration of a Cache netSearch ({0} ms) exceeds the threshold ({1} ms)");
  public static final StringId ConnectionProxyImpl_AFTER_REMOVING_AN_ENDPOINT_HERE_ARE_THE_ENDPOINTS_0 = new StringIdImpl(3914, "After removing an endpoint, here are the endpoints: {0}");
  public static final StringId CacheHealthEvaluator_THE_SIZE_OF_THE_CACHE_EVENT_QUEUE_0_MS_EXCEEDS_THE_THRESHOLD_1_MS = new StringIdImpl(3915, "The size of the cache event queue ({0} ms) exceeds the threshold ({1} ms)");
  public static final StringId GemFireHealth_GOOD = new StringIdImpl(3916, "Good");
  public static final StringId GemFireHealth_OKAY = new StringIdImpl(3917, "Okay");
  public static final StringId GemFireHealth_POOR = new StringIdImpl(3918, "Poor");
  public static final StringId DistributedSystemHealth_THE_NUMBER_OF_APPLICATIONS_THAT_HAVE_LEFT_THE_DISTRIBUTED_SYSTEM_0_EXCEEDS_THE_THRESHOLD_1 = new StringIdImpl(3919, "The number of applications that have left the distributed system ({0}) exceeds the threshold ({1})");
  public static final StringId DistributedSystemHealthMonitor_HEALTH_MONITORS = new StringIdImpl(3920, "Health Monitors");
  public static final StringId DistributedSystemHealthMonitor_HEALTH_MONITOR_FOR_0 = new StringIdImpl(3921, "Health monitor for {0}");
  public static final StringId DistributedSystemHealthMonitor_INTERRUPTED_WHILE_STOPPING_HEALTH_MONITOR_THREAD = new StringIdImpl(3922, "Interrupted while stopping health monitor thread");
  public static final StringId GemFireClientAdminTool_SLEEPING_FOR_0_SECONDS = new StringIdImpl(3923, "Sleeping for {0} seconds.");
  public static final StringId GemFireClientAdminTool_WAKING_UP = new StringIdImpl(3924, "Waking up");
  public static final StringId GemFireClientAdminTool_USAGE = new StringIdImpl(3925, "Usage");
  public static final StringId GemFireClientAdminTool_THIS_ARGUMENT_IS_REQUIRED = new StringIdImpl(3926, "This argument is required");
  public static final StringId GemFireClientAdminTool_IF_A_COMMAND_IS_SUPPLIED_IT_IS_EXECUTED_AND_GEMFIRECLIENTADMINTOOL_EXITS = new StringIdImpl(3927, "If a command is supplied it is executed and GemFireClientAdminTool exits");
  public static final StringId GemFireClientAdminTool_TYPE_HELP_OR_TO_VIEW_COMMANDS = new StringIdImpl(3928, "Type HELP or ? to view commands");
  public static final StringId GemFireClientAdminTool_FAILED_DUE_TO_AN_EXCEPTION_0 = new StringIdImpl(3929, "Failed due to an exception. {0}");
  public static final StringId GemFireClientAdminTool_THE_CONNECTION_WAS_BROKEN = new StringIdImpl(3930, "The connection was broken!");
  public static final StringId GemFireClientAdminTool__0_SETTING_STATUS_FOR_MEMBER_1 = new StringIdImpl(3931, "{0} setting status for member: {1}");
  public static final StringId GemFireClientAdminTool_USING_ADMIN_CONNECTION_0 = new StringIdImpl(3932, "Using admin connection: {0}");
  public static final StringId GemFireHealthConfigImpl_DEFAULT_GEMFIRE_HEALTH_CONFIGURATION = new StringIdImpl(3933, "Default GemFire health configuration");
  public static final StringId GemFireHealthConfigImpl_GEMFIRE_HEALTH_CONFIGURATION_FOR_HOST_0 = new StringIdImpl(3934, "GemFire health configuration for host \"{0}\"");
  public static final StringId MemberHealthEvaluator_THE_SIZE_OF_THIS_VM_0_MEGABYTES_EXCEEDS_THE_THRESHOLD_1_MEGABYTES = new StringIdImpl(3936, "The size of this VM ({0} megabytes) exceeds the threshold ({1} megabytes)");
  public static final StringId MemberHealthEvaluator_THE_SIZE_OF_THE_OVERFLOW_QUEUE_0_EXCEEDS_THE_THRESHOLD_1 = new StringIdImpl(3937, "The size of the overflow queue ({0}) exceeds the threshold ({1}).");
  public static final StringId MemberHealthEvaluator_THE_NUMBER_OF_MESSAGE_REPLY_TIMEOUTS_0_EXCEEDS_THE_THRESHOLD_1 = new StringIdImpl(3938, "The number of message reply timeouts ({0}) exceeds the threshold ({1})");
  public static final StringId MemberHealthEvaluator_THERE_ARE_0_REGIONS_MISSING_REQUIRED_ROLES_BUT_ARE_CONFIGURED_FOR_FULL_ACCESS = new StringIdImpl(3939, "There are {0} regions missing required roles; however, they are configured for full access.");
  public static final StringId MemberHealthEvaluator_THERE_ARE_0_REGIONS_MISSING_REQUIRED_ROLES_AND_CONFIGURED_WITH_LIMITED_ACCESS = new StringIdImpl(3940, "There are {0} regions missing required roles and configured with limited access.");
  public static final StringId MemberHealthEvaluator_THERE_ARE_0_REGIONS_MISSING_REQUIRED_ROLES_AND_CONFIGURED_WITHOUT_ACCESS = new StringIdImpl(3941, "There are {0} regions missing required roles and configured without access.");
  public static final StringId SystemMemberImpl_NO_LOG_FILE_CONFIGURED_LOG_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT = new StringIdImpl(3942, "No log file configured, log messages will be directed to stdout.");
  public static final StringId SystemMemberImpl_TAIL_OF_CHILD_LOG = new StringIdImpl(3943, "-------------------- tail of child log --------------------");
  public static final StringId AgentImpl_NO_LOG_FILE_CONFIGURED_LOG_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT = new StringIdImpl(3944, "No log file configured, log messages will be directed to stdout.");
  public static final StringId AgentImpl_TAIL_OF_CHILD_LOG = new StringIdImpl(3945, "-------------------- tail of child log --------------------");
  public static final StringId AgentImpl_AGENT_CONFIG_PROPERTY_FILE_NAME_0 = new StringIdImpl(3946, "Agent config property file name: {0}");
  public static final StringId SystemAdmin_ERROR = new StringIdImpl(3947, "ERROR");
  public static final StringId AgentImpl_FAILED_READING_CONFIGURATION_0 = new StringIdImpl(3948, "Failed reading configuration: {0}");
  public static final StringId MBeanUtil_LOADING_RESOURCE_0 = new StringIdImpl(3949, "Loading resource: {0}");
  public static final StringId MX4JModelMBean_CANNOT_RESTORE_PREVIOUSLY_SAVED_STATUS = new StringIdImpl(3950, "Cannot restore previously saved status");
  public static final StringId CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_PUT_ENTRY_REGION_0_KEY_1_VALUE_2 = new StringIdImpl(3951, "The following exception occurred while attempting to put entry (region: {0} key: {1} value: {2})");
  public static final StringId CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_INVALIDATE_ENTRY_REGION_0_KEY_1 = new StringIdImpl(3952, "The following exception occurred while attempting to invalidate entry (region: {0} key: {1})");
  public static final StringId CacheClientUpdater_CAUGHT_AN_EXCEPTION_WHILE_ATTEMPTING_TO_DESTROY_REGION_0 = new StringIdImpl(3953, "Caught an exception while attempting to destroy region {0}");
  public static final StringId CacheClientUpdater_CAUGHT_THE_FOLLOWING_EXCEPTION_WHILE_ATTEMPTING_TO_CLEAR_REGION_0 = new StringIdImpl(3954, "Caught the following exception while attempting to clear region {0}");
  public static final StringId CacheClientUpdater_CAUGHT_AN_EXCEPTION_AND_WILL_EXIT = new StringIdImpl(3955, "Caught an exception and will exit");
  public static final StringId Put_REGION_WAS_NOT_FOUND_DURING_PUT_REQUEST = new StringIdImpl(3956, ": Region was not found during put request");
  public static final StringId CacheServerLauncher_STARTS_A_GEMFIRE_CACHESERVER_VM = new StringIdImpl(3957, "Starts a GemFire CacheServer VM");
  public static final StringId CacheServerLauncher_VMARG = new StringIdImpl(3958, "<vmarg> a VM-option passed to the spawned CacheServer VM, example -J-Xmx1024M for a 1 Gb heap");
  public static final StringId CacheServerLauncher_DIR = new StringIdImpl(3959, "<workingdir> Directory in which cacheserver runs, default is the current directory");
  public static final StringId CacheServerLauncher_CLASSPATH = new StringIdImpl(3960, "<classpath> Location of user classes required by the cache server.  This path is appended to the current classpath.");
  public static final StringId CacheServerLauncher_ATTNAME = new StringIdImpl(3961, "<attName> Distributed system attribute such as \"mcast-port\" or \"cache-xml-file\".");
  public static final StringId CacheServerLauncher_STOPS_A_GEMFIRE_CACHESERVER_VM = new StringIdImpl(3962, "Stops a GemFire CacheServer VM");
  public static final StringId CacheServerLauncher_STATUS = new StringIdImpl(3963, "Reports the status and process id of a GemFire CacheServer VM");
  public static final StringId CacheServerLauncher_ERROR_STARTING_SERVER_PROCESS = new StringIdImpl(3964, "Error starting server process. ");
  public static final StringId CacheServerLauncher_ERROR_0 = new StringIdImpl(3965, "Error: {0}");
  public static final StringId CacheServerLauncher_STARTING_0_WITH_PID_1 = new StringIdImpl(3966, "Starting {0} with pid: {1,number,#}");
  public static final StringId ExecuteFunction_RESULTS_ALREADY_COLLECTED = new StringIdImpl(3967, "Function results already collected");
  public static final StringId CacheServerLauncher_THE_SPECIFIED_WORKING_DIRECTORY_0_CONTAINS_NO_STATUS_FILE = new StringIdImpl(3968, "The specified working directory ({0}) contains no status file");
  public static final StringId CacheServerLauncher_0_STOPPED = new StringIdImpl(3969, "The {0} has stopped.");
  public static final StringId CacheServerLauncher_TIMEOUT_WAITING_FOR_0_TO_SHUTDOWN_STATUS_IS_1 = new StringIdImpl(3970, "Timeout waiting for {0} to shutdown, status is: {1}");
  public static final StringId CacheServerLauncher_SEE_LOG_FILE_FOR_DETAILS = new StringIdImpl(3971, "See log file for details.");
  public static final StringId DistributionManager__0_MESSAGE_DISTRIBUTION_HAS_TERMINATED = new StringIdImpl(3972, "{0}: Message distribution has terminated");
  public static final StringId SystemFailure_DISTRIBUTION_HALTED_DUE_TO_JVM_CORRUPTION = new StringIdImpl(3973, "Distribution halted due to JVM corruption");
  public static final StringId DistributionManager_0_DISTRIBUTION_HAS_TERMINATED = new StringIdImpl(3974, "{0}: Distribution has terminated");
  public static final StringId DistributionManager_DISTRIBUTED_SYSTEM_IS_MISSING = new StringIdImpl(3975, "Distributed system is missing");
  public static final StringId DistributionManager_SERIAL_MESSAGE_PROCESSOR = new StringIdImpl(3976, "Serial Message Processor");
  public static final StringId DistributionManager_VIEW_MESSAGE_PROCESSOR = new StringIdImpl(3977, "View Message Processor");
  public static final StringId DistributionManager_POOLED_MESSAGE_PROCESSOR = new StringIdImpl(3978, "Pooled Message Processor ");
  public static final StringId DistributionManager_POOLED_HIGH_PRIORITY_MESSAGE_PROCESSOR = new StringIdImpl(3979, "Pooled High Priority Message Processor ");
  public static final StringId DistributionManager_POOLED_WAITING_MESSAGE_PROCESSOR = new StringIdImpl(3980, "Pooled Waiting Message Processor ");
  public static final StringId PasswordUtil_ENCRYPTED_TO_0 = new StringIdImpl(3981, "Encrypted to {0}");
  public static final StringId DistributionManager_SHUTDOWN_MESSAGE_THREAD_FOR_0 = new StringIdImpl(3982, "Shutdown Message Thread for {0}");
  public static final StringId HealthMonitorImpl_HEALTH_MONITOR_OWNED_BY_0 = new StringIdImpl(3983, "Health Monitor owned by {0}");
  // ok to reuse 3984
  public static final StringId InternalDistributedSystem_COULD_NOT_RENAME_0_TO_1 = new StringIdImpl(3985, "Could not rename \"{0}\" to \"{1}\".");
  public static final StringId InternalDistributedSystem_RENAMED_OLD_LOG_FILE_TO_0 = new StringIdImpl(3986, "Renamed old log file to \"{0}\".");
  public static final StringId InternalDistributedSystem_COULD_NOT_OPEN_LOG_FILE_0 = new StringIdImpl(3987, "Could not open log file \"{0}\".");
  public static final StringId SystemFailure_DISTRIBUTED_SYSTEM_DISCONNECTED_DUE_TO_JVM_CORRUPTION = new StringIdImpl(3988, "Distributed system disconnected due to JVM corruption");
  public static final StringId InternalDistributedSystem_0_DISTRIBUTED_SYSTEM_IS_DISCONNECTING = new StringIdImpl(3989, "{0}: Distributed system is disconnecting");
  public static final StringId TransactionManagerImpl_CLEAN_UP_THREADS = new StringIdImpl(3990, "Clean up threads");
  public static final StringId InternalDistributedSystem_NORMAL_DISCONNECT = new StringIdImpl(3991, "normal disconnect");
  public static final StringId LicenseInfo_LICENSE_LIMITS_SERVER_TO_0_CLIENTS = new StringIdImpl(3992, "License limits cache servers to \"{0}\" clients.");
  public static final StringId InternalDistributedSystem_NO_DISTRIBUTION_MANAGER = new StringIdImpl(3993, "no distribution manager");
  public static final StringId InternalLocator_ADDITIONAL_DISTRIBUTED_SYSTEM_PROPERTIES = new StringIdImpl(3994, "Additional distributed system properties:");
  public static final StringId LiveServerMonitorThread_SERVERMONITOR_MONITORING_LIVE_CONNECTIONS_ON_0 = new StringIdImpl(3995, "ServerMonitor monitoring live connections on {0}");
  public static final StringId LiveServerMonitorThread_EOF_DETECTED = new StringIdImpl(3996, "EOF detected.");
  public static final StringId LiveServerMonitorThread_SOCKET_WAS_CLOSED = new StringIdImpl(3997, "Socket was closed.");
  public static final StringId LiveServerMonitorThread_CONNECTION_WAS_RESET = new StringIdImpl(3998, "Connection was reset.");
  public static final StringId LiveServerMonitorThread_BROKEN_PIPE = new StringIdImpl(3999, "Broken pipe.");
  public static final StringId LiveServerMonitorThread_SOCKET_TIMED_OUT = new StringIdImpl(4000, "Socket timed out.");
  public static final StringId DestroyRegion__THE_INPUT_REGION_NAME_FOR_THE_DESTROY_REGION_REQUEST_IS_NULL = new StringIdImpl(4001, " The input region name for the destroy region request is null.");
  public static final StringId DestroyRegion_REGION_WAS_NOT_FOUND_DURING_DESTROY_REGION_REQUEST = new StringIdImpl(4002, "Region was not found during destroy region request");
  //ok to reuse 4003
  public static final StringId CreateRegionProcessor_CANNOT_CREATE_PARTITIONEDREGION_0_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_REGION_DEFINED_AS_A_NON_PARTITIONEDREGION = new StringIdImpl(4004, "Cannot create PartitionedRegion {0} because another cache ({1}) has the same region defined as a non PartitionedRegion.");
  public static final StringId CreateRegionProcessor_CANNOT_CREATE_THE_NON_PARTITIONEDREGION_0_BECAUSE_ANOTHER_CACHE_HAS_A_PARTITIONED_REGION_DEFINED_WITH_THE_SAME_NAME = new StringIdImpl(4005, "Cannot create the non PartitionedRegion {0} because another cache ({1}) has a Partitioned Region defined with the same name.");
  public static final StringId CreateRegionProcessor_CANNOT_CREATE_REGION_0_WITH_1_SCOPE_BECAUSE_ANOTHER_CACHE_HAS_SAME_REGION_WITH_2_SCOPE = new StringIdImpl(4006, "Cannot create region {0} with {1} scope because another cache ({2}) has same region with {3} scope.");
  public static final StringId AvailablePort_THIS_PROGRAM_EITHER_PRINTS_WHETHER_OR_NOT_A_PORT_IS_AVAILABLE_FOR_A_GIVEN_PROTOCOL_OR_IT_PRINTS_OUT_AN_AVAILABLE_PORT_FOR_A_GIVEN_PROTOCOL = new StringIdImpl(4007, "This program either prints whether or not a port is available for a given protocol, or it prints out an available port for a given protocol.");
  public static final StringId CacheInfoRequest_FETCH_CACHE_UP_TIME = new StringIdImpl(4008, "Fetch cache up time");
  public static final StringId ResultsCollectionWrapper_CONSTRAINT_VIOLATION_0_IS_NOT_A_1 = new StringIdImpl(4009, "Constraint Violation: {0} is not a {1}");
  public static final StringId DataSerializer_COULD_NOT_ACCESS_ZEROARGUMENT_CONSTRUCTOR_OF_0 = new StringIdImpl(4010, "Could not access zero-argument constructor of {0}");
  public static final StringId DistributionConfigSnapshot_THE_0_CONFIGURATION_ATTRIBUTE_CAN_NOT_BE_MODIFIED_WHILE_THE_SYSTEM_IS_RUNNING = new StringIdImpl(4011, "The \"{0}\" configuration attribute can not be modified while the system is running.");
  public static final StringId BaseCommand_INVALID_DATA_RECEIVED_PLEASE_SEE_THE_CACHE_SERVER_LOG_FILE_FOR_ADDITIONAL_DETAILS = new StringIdImpl(4012, "Invalid data received. Please see the cache server log file for additional details.");
  public static final StringId LRUCapacityController_LRUCAPACITYCONTROLLER_WITH_A_CAPACITY_OF_0_ENTRIES_AND_EVICTION_ACTION_1 = new StringIdImpl(4013, "LRUCapacityController with a capacity of {0} entries and eviction action {1}");
  public static final StringId HeapLRUCapacityController_HEAPLRUCAPACITYCONTROLLER_WITH_A_CAPACITY_OF_0_OF_HEAP_AND_AN_THREAD_INTERVAL_OF_1_AND_EVICTION_ACTION_2 = new StringIdImpl(4014, "HeapLRUCapacityController with a capacity of {0}% of memory and eviction action {1}.");
  public static final StringId MembersRequestMessage_REQUESTING_MEMBERS = new StringIdImpl(4015, "Requesting members");
  public static final StringId ShutdownMessage_SHUTDOWN_MESSAGE_RECEIVED = new StringIdImpl(4016, "shutdown message received");
  public static final StringId ShutdownMessage_SHUTDOWNMESSAGE_DM_0_HAS_SHUTDOWN = new StringIdImpl(4017, "ShutdownMessage DM {0} has shutdown");
  public static final StringId StartupOperation_LEFT_THE_MEMBERSHIP_VIEW = new StringIdImpl(4018, "left the membership view");
  public static final StringId StartupOperation_DISAPPEARED_DURING_STARTUP_HANDSHAKE = new StringIdImpl(4019, "disappeared during startup handshake");
  public static final StringId DistributionLocator__0_IS_NOT_A_VALID_IP_ADDRESS_FOR_THIS_MACHINE = new StringIdImpl(4020, "''{0}'' is not a valid IP address for this machine");
  public static final StringId DistributionLocator_A_ZEROLENGTH_BINDADDRESS_WILL_BIND_TO_LOCALHOST = new StringIdImpl(4021, "A zero-length bind-address will bind to localhost");
  public static final StringId DistributionLocator_DISTRIBUTION_LOCATOR_ON_0 = new StringIdImpl(4022, "Distribution Locator on {0}");
  public static final StringId Locator_USAGE = new StringIdImpl(4023, "Usage");
  public static final StringId AddHealthListenerRequest_ADD_HEALTH_LISTENER = new StringIdImpl(4024, "Add health listener");
  public static final StringId AddStatListenerRequest_ADD_STATISTIC_RESOURCE_LISTENER = new StringIdImpl(4025, "Add statistic resource listener");
  public static final StringId AdminConsoleDisconnectMessage_AUTOMATIC_ADMIN_DISCONNECT_0 = new StringIdImpl(4026, "Reason for automatic admin disconnect : {0}");
  public static final StringId AdminRequest_COULD_NOT_RETURN_ONE_RECIPIENT_BECAUSE_THIS_MESSAGE_HAS_0_RECIPIENTS = new StringIdImpl(4027, "Could not return one recipient because this message has {0} recipients");
  public static final StringId AdminResponse_COULD_NOT_RETURN_ONE_RECIPIENT_BECAUSE_THIS_MESSAGE_HAS_0_RECIPIENTS = new StringIdImpl(4028, "Could not return one recipient because this message has {0} recipients");
  public static final StringId AdminWaiters_REQUEST_WAIT_WAS_INTERRUPTED = new StringIdImpl(4029, "Request wait was interrupted.");
  public static final StringId AlertLevelChangeMessage_CHANGING_ALERT_LEVEL_TO_0 = new StringIdImpl(4030, "Changing alert level to {0}");
  public static final StringId BridgeServerRequest_ADD_BRIDGE_SERVER = new StringIdImpl(4031, "Add bridge server");
  public static final StringId BridgeServerRequest_GET_INFO_ABOUT_BRIDGE_SERVER_0 = new StringIdImpl(4032, "Get info about cache server {0}");
  public static final StringId BridgeServerRequest_START_BRIDGE_SERVER_0 = new StringIdImpl(4033, "Start cache server {0}");
  public static final StringId BridgeServerRequest_STOP_BRIDGE_SERVER_0 = new StringIdImpl(4034, "Stop cache server {0}");
  public static final StringId BridgeServerRequest_UNKNOWN_OPERATION_0 = new StringIdImpl(4035, "Unknown operation {0}");
  public static final StringId CacheConfigRequest_SET_A_SINGLE_CACHE_CONFIGURATION_ATTRIBUTE = new StringIdImpl(4036, "Set a single cache configuration attribute");
  public static final StringId CancellationMessage_CANCELLATIONMESSAGE_FROM_0_FOR_MESSAGE_ID_1 = new StringIdImpl(4037, "CancellationMessage from {0} for message id {1}");
  public static final StringId CancelStatListenerRequest_REMOVE_STATISTIC_RESOURCE_LISTENER = new StringIdImpl(4038, "Remove statistic resource listener");
  public static final StringId CancelStatListenerRequest_CANCELSTATLISTENERREQUEST_FROM_0_FOR_1 = new StringIdImpl(4039, "CancelStatListenerRequest from {0} for {1}");
  public static final StringId CancelStatListenerResponse_CANCELSTATLISTENERRESPONSE_FROM_0 = new StringIdImpl(4040, "CancelStatListenerResponse from {0}");
  public static final StringId DestroyEntryMessage_DESTROYENTRYMESSAGE_FROM_0 = new StringIdImpl(4041, "DestroyEntryMessage from {0}");
  public static final StringId DestroyRegionMessage_DESTROYREGIONMESSAGE_FROM_0 = new StringIdImpl(4042, "DestroyRegionMessage from {0}");
  public static final StringId FetchDistLockInfoRequest_LIST_DISTRIBUTED_LOCKS = new StringIdImpl(4043, "List distributed locks");
  public static final StringId FetchDistLockInfoRequest_FETCHDISTLOCKINFOREQUEST_FROM_0 = new StringIdImpl(4044, "FetchDistLockInfoRequest from {0}");
  public static final StringId FetchDistLockInfoResponse_FETCHDISTLOCKINFORESPONSE_FROM_0 = new StringIdImpl(4045, "FetchDistLockInfoResponse from {0}");
  public static final StringId FetchHealthDiagnosisRequest_FETCH_HEALTH_DIAGNOSIS_FOR_HEALTH_CODE_0 = new StringIdImpl(4046, "fetch health diagnosis for health code {0}");
  public static final StringId FetchHealthDiagnosisRequest_FETCHHEALTHDIAGNOSISREQUEST_FROM_ID_1_HEALTHCODE_2 = new StringIdImpl(4047, "FetchHealthDiagnosisRequest from id={1} healthCode={2}");
  public static final StringId FetchHostRequest_FETCH_REMOTE_HOST = new StringIdImpl(4048, "Fetch remote host");
  public static final StringId FetchHostRequest_FETCHHOSTREQUEST_FOR_0 = new StringIdImpl(4049, "FetchHostRequest for {0}");
  public static final StringId FetchHostResponse_FETCHHOSTRESPONSE_FOR_0_HOST_1 = new StringIdImpl(4050, "FetchHostResponse for {0} host={1}");
  public static final StringId FetchResourceAttributesRequest_FETCH_STATISTICS_FOR_RESOURCE = new StringIdImpl(4051, "Fetch statistics for resource");
  public static final StringId FetchResourceAttributesRequest_FETCHRESOURCEATTRIBUTESREQUEST_FOR_0 = new StringIdImpl(4052, "Fetch statistics for {0}");
  public static final StringId FetchSysCfgRequest_FETCH_CONFIGURATION_PARAMETERS = new StringIdImpl(4053, "Fetch configuration parameters");
  public static final StringId HealthListenerMessage_THE_STATUS_OF_LISTENER_0_IS_1 = new StringIdImpl(4054, "The status of listener {0} is {1}");
  public static final StringId LicenseInfoRequest_FETCH_CURRENT_LICENSE_INFORMATION = new StringIdImpl(4055, "Fetch current license information");
  public static final StringId ObjectDetailsRequest_INSPECT_CACHED_OBJECT = new StringIdImpl(4056, "Inspect cached object");
  public static final StringId ObjectNamesRequest_LIST_CACHED_OBJECTS = new StringIdImpl(4057, "List cached objects");
  public static final StringId RegionAttributesRequest_FETCH_REGION_ATTRIBUTES = new StringIdImpl(4058, "Fetch region attributes");
  public static final StringId RegionRequest_GET_A_SPECIFIC_REGION_FROM_THE_ROOT = new StringIdImpl(4059, "Get a specific region from the root");
  public static final StringId RegionRequest_CREATE_A_NEW_ROOT_VM_REGION = new StringIdImpl(4060, "Create a new root VM region");
  public static final StringId RegionRequest_CREATE_A_NEW_VM_REGION = new StringIdImpl(4061, "Create a new VM region");
  public static final StringId RegionRequest_UNKNOWN_OPERATION_0 = new StringIdImpl(4062, "Unknown operation {0}");
  public static final StringId RegionSizeRequest_FETCH_REGION_SIZE = new StringIdImpl(4063, "Fetch region size");
  public static final StringId RegionStatisticsRequest_FETCH_REGION_STATISTICS = new StringIdImpl(4064, "Fetch region statistics");
  public static final StringId RemoteCacheInfo_INFORMATION_ABOUT_THE_CACHE_0_WITH_1_BRIDGE_SERVERS = new StringIdImpl(4065, "Information about the cache \"{0}\" with {1} bridge servers");
  public static final StringId RemoteGfManagerAgent_DISCONNECT_LISTENER_FOR_0 = new StringIdImpl(4066, "Disconnect listener for {0}");
  public static final StringId RemoveHealthListenerRequest_REMOVE_HEALTH_LISTENER = new StringIdImpl(4067, "Remove health listener");
  public static final StringId ResetHealthStatusRequest_RESET_HEALTH_STATUS = new StringIdImpl(4068, "reset health status");
  public static final StringId RootRegionRequest_INSPECT_ROOT_CACHE_REGIONS = new StringIdImpl(4069, "Inspect root cache regions");
  public static final StringId StoreSysCfgRequest_APPLY_CONFIGURATION_PARAMETERS = new StringIdImpl(4070, "Apply configuration parameters");
  public static final StringId SubRegionRequest_LIST_SUBREGIONS = new StringIdImpl(4071, "List subregions");
  public static final StringId TailLogRequest_TAIL_SYSTEM_LOG = new StringIdImpl(4072, "Tail system log");
  public static final StringId TailLogResponse_NO_LOG_FILE_WAS_SPECIFIED_IN_THE_CONFIGURATION_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT = new StringIdImpl(4073, "No log file was specified in the configuration, messages will be directed to stdout.");
  public static final StringId VersionInfoRequest_FETCH_CURRENT_VERSION_INFORMATION = new StringIdImpl(4074, "Fetch current version information");
  public static final StringId ArchiveSplitter_USAGE = new StringIdImpl(4075, "Usage");
  public static final StringId DistributedRegion_RECONNECT_DISTRIBUTED_SYSTEM = new StringIdImpl(4076, "Reconnect Distributed System");
  public static final StringId MultiWriteSingleReadRegionQueue_MULTIWRITER_SINGLEREADER_REGION_QUEUE_FOR_THE_REGION_0 = new StringIdImpl(4077, "Multi-writer / single-reader region queue for the region {0}");
  public static final StringId CloseCQ_THE_CQNAME_FOR_THE_CQ_CLOSE_REQUEST_IS_NULL = new StringIdImpl(4078, "The cqName for the cq close request is null");
  public static final StringId CloseCQ_EXCEPTION_WHILE_CLOSING_CQ_CQNAME_0 = new StringIdImpl(4079, "Exception while closing CQ CqName :{0}");
  public static final StringId CloseCQ_CQ_CLOSED_SUCCESSFULLY = new StringIdImpl(4080, "cq closed successfully.");
  public static final StringId CreateRegion__0_WAS_NOT_FOUND_DURING_SUBREGION_CREATION_REQUEST = new StringIdImpl(4081, "{0} was not found during subregion creation request");
  public static final StringId Destroy__THE_INPUT_KEY_FOR_THE_DESTROY_REQUEST_IS_NULL = new StringIdImpl(4082, " The input key for the destroy request is null");
  public static final StringId Destroy__THE_INPUT_REGION_NAME_FOR_THE_DESTROY_REQUEST_IS_NULL = new StringIdImpl(4083, " The input region name for the destroy request is null");
  public static final StringId Destroy__0_WAS_NOT_FOUND_DURING_DESTROY_REQUEST = new StringIdImpl(4084, "{0} was not found during destroy request");
  public static final StringId ExecuteCQ_SERVER_NOTIFYBYSUBSCRIPTION_MODE_IS_SET_TO_FALSE_CQ_EXECUTION_IS_NOT_SUPPORTED_IN_THIS_MODE = new StringIdImpl(4085, "Server notifyBySubscription mode is set to false. CQ execution is not supported in this mode.");
  public static final StringId HandShake_HANDSHAKE_FAILED_TO_FIND_PUBLIC_KEY_FOR_SERVER_WITH_SUBJECT_0 = new StringIdImpl(4086, "HandShake failed to find public key for server with subject {0}");
  public static final StringId HandShake_HANDSHAKE_FAILED_IN_DIFFIEHELLMAN_KEY_EXCHANGE = new StringIdImpl(4087, "HandShake failed in Diffie-Hellman key exchange.");
  public static final StringId ExecuteCQ_CQ_CREATED_SUCCESSFULLY = new StringIdImpl(4088, "cq created successfully.");
  public static final StringId KeySet__0_WAS_NOT_FOUND_DURING_KEY_SET_REQUEST = new StringIdImpl(4089, "{0} was not found during key set request");
  public static final StringId MonitorCQ__0_THE_MONITORCQ_OPERATION_IS_INVALID = new StringIdImpl(4090, "{0}: The MonitorCq operation is invalid.");
  public static final StringId MonitorCQ__0_A_NULL_REGION_NAME_WAS_PASSED_FOR_MONITORCQ_OPERATION = new StringIdImpl(4091, "{0}: A null Region name was passed for MonitorCq operation.");
  public static final StringId MonitorCQ_EXCEPTION_WHILE_HANDLING_THE_MONITOR_REQUEST_OP_IS_0 = new StringIdImpl(4092, "Exception while handling the monitor request, the operation is {0}");
  public static final StringId MonitorCQ_MONITOR_CQ_REQUEST_COMPLETED_SUCCESSFULLY = new StringIdImpl(4093, "monitor cq request completed successfully.");
  public static final StringId Request__0_WAS_NOT_FOUND_DURING_GET_REQUEST = new StringIdImpl(4094, "{0} was not found during get request");
  public static final StringId StopCQ_THE_CQNAME_FOR_THE_CQ_STOP_REQUEST_IS_NULL = new StringIdImpl(4095, "The cqName for the cq stop request is null");
  public static final StringId StopCQ_CQ_STOPPED_SUCCESSFULLY = new StringIdImpl(4096, "cq stopped successfully.");
  public static final StringId ServerConnection_ERROR_IN_GETSOCKETSTRING_0 = new StringIdImpl(4097, "Error in getSocketString: {0}");
  public static final StringId ServerMonitor_SERVERMONITOR_MONITORING_DEAD_CONNECTIONS_ON_0 = new StringIdImpl(4098, "ServerMonitor monitoring dead connections on {0}");
  public static final StringId TXManagerImpl_CAN_NOT_COMMIT_THIS_TRANSACTION_BECAUSE_IT_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_COMMIT = new StringIdImpl(4099, "Can not commit this transaction because it is enlisted with a JTA transaction, use the JTA manager to perform the commit.");
  public static final StringId TXManagerImpl_CAN_NOT_ROLLBACK_THIS_TRANSACTION_IS_ENLISTED_WITH_A_JTA_TRANSACTION_USE_THE_JTA_MANAGER_TO_PERFORM_THE_ROLLBACK = new StringIdImpl(4100, "Can not rollback this transaction is enlisted with a JTA transaction, use the JTA manager to perform the rollback.");
  public static final StringId CacheXmlParser_EXCEPTION_IN_PARSING_ELEMENT_0_THIS_IS_A_REQUIRED_FIELD = new StringIdImpl(4101, "Exception in parsing element {0}. This is a required field.");
  public static final StringId CFactory_COULD_NOT_CREATE_CF5IMPL_DUE_TO_AN_EXCEPTION = new StringIdImpl(4102, "Could not create CF5Impl due to an exception.");
  public static final StringId AbstractDataSource_CANNOT_CREATE_A_CONNECTION_WITH_THE_USER_0_AS_IT_DOESNT_MATCH_THE_EXISTING_USER_NAMED_1_OR_THE_PASSWORD_WAS_INCORRECT = new StringIdImpl(4103, "Cannot create a connection with the user, {0}, as it doesnt match the existing user named {1}, or the password was incorrect.");
  public static final StringId DataSourceFactory_DATASOURCEFACTORY_INVOKEALLMETHODS_EXCEPTION_IN_CREATING_CLASS_WITH_THE_GIVEN_CONFIGPROPERTYTYPE_CLASSNAME_EXCEPTION_STRING_0 = new StringIdImpl(4104, "DataSourceFactory::invokeAllMethods: Exception in creating Class with the given config-property-type classname. Exception string={0}");
  public static final StringId DataSourceFactory_DATASOURCEFACTORY_INVOKEALLMETHODS_EXCEPTION_IN_CREATING_METHOD_USING_CONFIGPROPERTYNAME_PROPERTY_EXCEPTION_STRING_0 = new StringIdImpl(4105, "DataSourceFactory::invokeAllMethods: Exception in creating method using config-property-name property. Exception string={0}");
  public static final StringId DataSourceFactory_DATASOURCEFACTORY_INVOKEALLMETHODS_EXCEPTION_IN_CREATING_INSTANCE_OF_THE_CLASS_USING_THE_CONSTRUCTOR_WITH_A_STRING_PARAMETER_EXCEPTION_STRING_0 = new StringIdImpl(4106, "DataSourceFactory::invokeAllMethods: Exception in creating instance of the class using the constructor with a String parameter. Exception string={0}");
  public static final StringId FacetsJCAConnectionManagerImpl_FACETSJCACONNECTIONMANAGERIMPL_CONSTRUCTOR_AN_EXCEPTION_WAS_CAUGHT_WHILE_INITIALIZING_DUE_TO_0 = new StringIdImpl(4107, "FacetsJCAConnectionManagerImpl::Constructor: An Exception was caught while initializing due to {0}");
  public static final StringId FacetsJCAConnectionManagerImpl_FACETSJCACONNECTIONMANAGERIMPL_AN_EXCEPTION_WAS_CAUGHT_WHILE_ALLOCATING_A_CONNECTION_DUE_TO_0 = new StringIdImpl(4108, "FacetsJCAConnectionManagerImpl:: An Exception was caught while allocating a connection due to {0}");
  public static final StringId ElderInitProcessor_0_DISREGARDING_REQUEST_FROM_DEPARTED_MEMBER = new StringIdImpl(4109, "{0}: disregarding request from departed member.");
  public static final StringId DistributionLocator_USAGE = new StringIdImpl(4110, "Usage");
  public static final StringId DistributionLocator_A_ZEROLENGTH_ADDRESS_WILL_BIND_TO_LOCALHOST = new StringIdImpl(4111, "A zero-length address will bind to localhost");
  public static final StringId GemFireFormatter_IGNORING_THE_FOLLOWING_EXCEPTION = new StringIdImpl(4112, "Ignoring the following exception:");
  public static final StringId InternalInstantiator_REGISTER_INSTANTIATOR_0_OF_CLASS_1_THAT_INSTANTIATES_A_2 = new StringIdImpl(4113, "Register Instantiator {0} of class {1} that instantiates a {2}");
  public static final StringId TransactionImpl_TRANSACTIONIMPL_SETROLLBACKONLY_NO_GLOBAL_TRANSACTION_EXISTS = new StringIdImpl(4114, "TransactionImpl::setRollbackOnly: No global transaction exists.");
  public static final StringId GemFireCacheImpl_MEMCACHED_SERVER_ON_PORT_0_IS_SHUTTING_DOWN = new StringIdImpl(4115, "GemFireMemcachedServer on port {0} is shutting down");
  public static final StringId TransactionImpl_SETTRANSACTIONTIMEOUT_IS_NOT_SUPPORTED = new StringIdImpl(4116, "setTransactionTimeout is not supported.");
  public static final StringId TransactionImpl_TRANSACTIONIMPL_ENLISTRESOURCE_NO_GLOBAL_TRANSACTION_EXISTS = new StringIdImpl(4117, "TransactionImpl::enlistResource: No global transaction exists");
  public static final StringId TransactionImpl_TRANSACTIONIMPL_DELISTRESOURCE_NO_GLOBAL_TRANSACTION_EXISTS = new StringIdImpl(4118, "TransactionImpl::delistResource: No global transaction exists");
  public static final StringId TransactionImpl_TRANSACTIONIMPL_REGISTERSYNCHRONIZATION_SYNCHRONIZATION_CANNOT_BE_REGISTERED_BECAUSE_THE_TRANSACTION_HAS_BEEN_MARKED_FOR_ROLLBACK = new StringIdImpl(4119, "TransactionImpl::registerSynchronization: Synchronization cannot be registered because the transaction has been marked for rollback");
  public static final StringId TransactionImpl_TRANSACTIONIMPL_REGISTERSYNCHRONIZATION_SYNCHRONIZATION_CANNOT_BE_REGISTERED_ON_A_TRANSACTION_WHICH_IS_NOT_ACTIVE = new StringIdImpl(4120, "TransactionImpl::registerSynchronization: Synchronization cannot be registered on a transaction which is not active");
  public static final StringId LogFileParser_MISSING_LOG_FILE_NAME = new StringIdImpl(4121, "** Missing log file name");
  public static final StringId ManagerInfo_STOPPED = new StringIdImpl(4122, "stopped");
  public static final StringId ManagerInfo_STOPPING = new StringIdImpl(4123, "stopping");
  public static final StringId ManagerInfo_KILLED = new StringIdImpl(4124, "killed");
  public static final StringId ManagerInfo_STARTING = new StringIdImpl(4125, "starting");
  public static final StringId ManagerInfo_RUNNING = new StringIdImpl(4126, "running");
  public static final StringId ProcessOutputReader_FAILED_TO_GET_EXIT_STATUS_AND_IT_WROTE_TO_STDERR_SO_SETTING_EXIT_STATUS_TO_1 = new StringIdImpl(4127, "Failed to get exit status and it wrote to stderr so setting exit status to 1.");
  public static final StringId CacheClientNotifier_CACHECLIENTNOTIFIER_POST_PROCESS_AUTHORIZATION_CALLBACK_ENABLED_BUT_AUTHENTICATION_CALLBACK_0_RETURNED_WITH_NULL_CREDENTIALS_FOR_PROXYID_1 = new StringIdImpl(4128, "CacheClientNotifier: Post process authorization callback enabled but authentication callback ({0}) returned with null credentials for proxyID: {1}");
  public static final StringId CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1 = new StringIdImpl(4129, "An exception was thrown for client [{0}]. {1}");
  public static final StringId HandShake_AN_EXCEPTION_WAS_THROWN_WHILE_SENDING_WAN_CREDENTIALS_0 = new StringIdImpl(4130, "An exception was thrown while sending wan credentials: {0}");
  public static final StringId HandShake_MISMATCH_IN_CLIENT_CHALLENGE_BYTES_MALICIOUS_SERVER = new StringIdImpl(4131, "Mismatch in client challenge bytes. Malicious server?");
  public static final StringId SystemTimer_TIMER_TASK_0_ENCOUNTERED_EXCEPTION = new StringIdImpl(4132, "Timer task <{0}> encountered exception");
  public static final StringId ConnectionImpl_A_GEMFIRESECURITYEXCEPTION_WAS_CAUGHT_DURRING_CONNECTION_TO_0_1 = new StringIdImpl(4133, "A GemFireSecurityException was caught durring connection to {0}. {1}");
  public static final StringId ConnectionImpl_SSL_NEGOTIATION_WITH_ENDPOINT_0_FAILED_1 = new StringIdImpl(4134, "SSL negotiation with endpoint [{0}] failed, {1}");
  public static final StringId CacheClientUpdater_0_SSL_NEGOTIATION_FAILED_1 = new StringIdImpl(4135, "{0} SSL negotiation failed. {1}");
  public static final StringId CacheClientUpdater_0_SECURITY_EXCEPTION_WHEN_CREATING_SERVERTOCLIENT_COMMUNICATION_SOCKET_1 = new StringIdImpl(4137, "{0}: Security exception when creating server-to-client communication socket. {1}");
  public static final StringId ConnectionProxyImpl_THE_CONNECTION_PROXY_IS_CLOSED = new StringIdImpl(4138, "The connection proxy is closed.");
  public static final StringId ConnectionProxyImpl_REMOVEINTERESTLIST_NO_KEYS_OF_TYPE_0_ARE_REGISTERED_IN_THE_CLIENT = new StringIdImpl(4139, "removeInterestList: No keys of type {0} are registered in the client.");
  public static final StringId ConnectionProxyImpl_REMOVESINGLEINTEREST_THE_KEY_0_NOT_REGISTERED_IN_THE_CLIENT = new StringIdImpl(4140, "removeSingleInterest: The key {0} not registered in the client.");
  public static final StringId ConnectionProxyImpl_REMOVESINGLEINTEREST_NO_KEYS_OF_TYPE_0_ARE_REGISTERED_IN_THE_CLIENT = new StringIdImpl(4141, "removeSingleInterest: No keys of type {0} are registered in the client.");
  public static final StringId ConnectionProxyImpl_REMOVEINTERESTLIST_KEY_0_IS_NOT_REGISTERED_WITH_THE_CLIENT = new StringIdImpl(4142, "removeInterestList: key {0} is not registered with the client.");
  public static final StringId ServerConnection_0_AN_UNEXPECTED_CERTIFICATE_TYPE_1_FOR_PROXYID_2 = new StringIdImpl(4143, "{0}: An unexpected certificate type [{1}] for proxyID {2}");
  public static final StringId ServerConnection_0_AN_EXCEPTION_WAS_THROWN_WHILE_CLOSING_CLIENT_AUTHORIZATION_CALLBACK_1 = new StringIdImpl(4144, "{0}: An exception was thrown while closing client authorization callback. {1}");
  public static final StringId ServerConnection_0_AN_EXCEPTION_WAS_THROWN_WHILE_CLOSING_CLIENT_POSTPROCESS_AUTHORIZATION_CALLBACK_1 = new StringIdImpl(4145, "{0}: An exception was thrown while closing client post-process authorization callback. {1}");
  public static final StringId ServerConnection_AN_UNEXPECTED_SSL_EXCEPTION_WAS_CAUGHT = new StringIdImpl(4146, "An unexpected SSL exception was caught.");
  public static final StringId ServerConnection_0_POSTPROCESS_AUTHORIZATION_ENABLED_BUT_NO_AUTHENTICATION_CALLBACK_PROPERTY_1_IS_CONFIGURED = new StringIdImpl(4147, "{0}: Post-process authorization enabled but no authentication callback property \"{1}\" is configured.");
  public static final StringId Connection_0_TIMED_OUT_DURING_A_MEMBERSHIP_CHECK = new StringIdImpl(4148, "{0} timed out during a membership check.");
  public static final StringId JGroupMembershipManager_THE_MEMBERSHIP_CHECK_WAS_TERMINATED_WITH_AN_EXCEPTION = new StringIdImpl(4149, "The membership check was terminated with an exception.");
  public static final StringId DynamicRegionFactory_EXCEPTION_WHEN_REGISTERING_INTEREST_FOR_ALL_KEYS_IN_DYNAMIC_REGION_0_1 = new StringIdImpl(4150, "Exception when registering interest for all keys in dynamic region [{0}]. {1}");
  public static final StringId ConnectionProxyImpl_NEWLY_CHOSEN_PRIMARY_IS_0 = new StringIdImpl(4151, "Newly chosen primary is {0}");
  public static final StringId ElderInitProcessor__0_RETURNING_EMPTY_LISTS_BECAUSE_I_KNOW_OF_NO_OTHER_MEMBERS = new StringIdImpl(4152, "{0}: returning empty lists because I know of no other members.");
  public static final StringId DistributionManager_CURRENT_CACHE_DISTRIBUTIONMANAGER_0_IS_NOT_THE_SAME_AS_1 = new StringIdImpl(4153, "Current cache DistributionManager ({0}) is not the same as ({1})");
  public static final StringId DistributionManager_ALINGERING_DISTRIBUTIONMANAGER_WAS_DISCOVERED_0 = new StringIdImpl(4154, "Alingering DistributionManager was discovered. {0}");
  public static final StringId FilterPostAuthorization_FILTERPOSTAUTHORIZATION_AN_EXCEPTION_WAS_THROWN_WHILE_TRYING_TO_DESERIALIZE = new StringIdImpl(4155, "FilterPostAuthorization: An exception was thrown while trying to de-serialize.");
  public static final StringId FilterPostAuthorization_FILTERPOSTAUTHORIZATION_AN_EXCEPTION_WAS_THROWN_WHILE_TRYING_TO_SERIALIZE = new StringIdImpl(4156, "FilterPostAuthorization: An exception was thrown while trying to serialize.");
  public static final StringId FilterPostAuthorization_FILTERPOSTAUTHORIZATION_THE_USER_0_IS_NOT_AUTHORIZED_FOR_THE_OBJECT_1 = new StringIdImpl(4157, "FilterPostAuthorization: The user [{0}] is not authorized for the object {1}.");
  public static final StringId FilterPostAuthorization_FILTERPOSTAUTHORIZATION_THE_OBJECT_OF_TYPE_0_IS_NOT_AN_INSTANCE_OF_1 = new StringIdImpl(4158, "FilterPostAuthorization: The object of type {0}, is not an instance of {1}.");
  public static final StringId AuthorizeRequest_AUTHORIZEREQUEST_CLIENT_0_IS_SETTING_AUTHORIZATION_CALLBACK_TO_1 = new StringIdImpl(4159, "AuthorizeRequest: Client[{0}] is setting authorization callback to {1}.");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_GET_OPERATION_ON_REGION_0 = new StringIdImpl(4160, "Not authorized to perform GET operation on region [{0}]");
  public static final StringId CqEventImpl_EXCEPTION_OCCURED_WHILE_APPLYING_QUERY_ON_A_CACHE_EVENT = new StringIdImpl(4161, "Exception occurred while applying query on a cache event.");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_PUT_OPERATION_ON_REGION_0 = new StringIdImpl(4162, "Not authorized to perform PUT operation on region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_DESTROY_OPERATION_ON_REGION_0 = new StringIdImpl(4163, "Not authorized to perform DESTROY operation on region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFOM_QUERY_OPERATION_0_ON_THE_CACHE = new StringIdImpl(4164, "Not authorized to perfom QUERY operation [{0}] on the cache");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFOM_EXECUTE_CQ_OPERATION_0_ON_THE_CACHE = new StringIdImpl(4165, "Not authorized to perfom EXECUTE_CQ operation [{0}] on the cache");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFOM_STOP_CQ_OPERATION_0_ON_THE_CACHE = new StringIdImpl(4166, "Not authorized to perfom STOP_CQ operation [{0}] on the cache");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFOM_CLOSE_CQ_OPERATION_0_ON_THE_CACHE = new StringIdImpl(4167, "Not authorized to perfom CLOSE_CQ operation [{0}] on the cache");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_REGION_CLEAR_OPERATION_ON_REGION_0 = new StringIdImpl(4168, "Not authorized to perform REGION_CLEAR operation on region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_REGISTER_INTEREST_OPERATION_FOR_REGION_0 = new StringIdImpl(4169, "Not authorized to perform REGISTER_INTEREST operation for region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_REGISTER_INTEREST_LIST_OPERATION_FOR_REGION_0 = new StringIdImpl(4170, "Not authorized to perform REGISTER_INTEREST_LIST operation for region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_UNREGISTER_INTEREST_OPERATION_FOR_REGION_0 = new StringIdImpl(4171, "Not authorized to perform UNREGISTER_INTEREST operation for region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_UNREGISTER_INTEREST_LIST_OPERATION_FOR_REGION_0 = new StringIdImpl(4172, "Not authorized to perform UNREGISTER_INTEREST_LIST operation for region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_KEY_SET_OPERATION_ON_REGION_0 = new StringIdImpl(4173, "Not authorized to perform KEY_SET operation on region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_CONTAINS_KEY_OPERATION_ON_REGION_0 = new StringIdImpl(4174, "Not authorized to perform CONTAINS_KEY operation on region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_CREATE_REGION_OPERATION_FOR_THE_REGION_0 = new StringIdImpl(4175, "Not authorized to perform CREATE_REGION operation for the region {0}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_REGION_DESTROY_OPERATION_FOR_THE_REGION_0 = new StringIdImpl(4176, "Not authorized to perform REGION_DESTROY operation for the region {0}");
  public static final StringId CqService_ERROR_WHILE_PROCESSING_CQ_ON_THE_EVENT_KEY_0_CQNAME_1_ERROR_2 = new StringIdImpl(4177, "Error while processing CQ on the event, key : {0} CqName: {1}, Error: {2}");
  public static final StringId CacheClientProxy__0_NOT_ADDING_MESSAGE_TO_QUEUE_1_BECAUSE_THE_OPERATION_CONTEXT_OBJECT_COULD_NOT_BE_OBTAINED_FOR_THIS_CLIENT_MESSAGE = new StringIdImpl(4178, "{0}: Not Adding message to queue: {1} because the operation context object could not be obtained for this client message.");
  public static final StringId CacheClientProxy__0_NOT_ADDING_MESSAGE_TO_QUEUE_1_BECAUSE_AUTHORIZATION_FAILED = new StringIdImpl(4179, "{0}: Not Adding message to queue {1} because authorization failed.");
  public static final StringId TCPConduit_STOPPING_P2P_LISTENER_DUE_TO_SSL_CONFIGURATION_PROBLEM = new StringIdImpl(4180, "Stopping P2P listener due to SSL configuration problem.");
  public static final StringId AuthorizeRequestPP_AUTHORIZEREQUESTPP_SETTING_POST_PROCESS_AUTHORIZATION_CALLBACK_TO_1_FOR_CLIENT_0 = new StringIdImpl(4181, "AuthorizeRequestPP: Setting post process authorization callback to {1} for client[{0}].");
  public static final StringId AuthorizeRequestPP_IN_POSTPROCESS_NOT_AUTHORIZED_TO_PERFORM_GET_OPERATION_ON_REGION_0 = new StringIdImpl(4182, "In post-process: not authorized to perform GET operation on region {0}");
  public static final StringId AuthorizeRequestPP_IN_POSTPROCESS_NOT_AUTHORIZED_TO_PERFORM_QUERY_OPERATION_0_ON_THE_CACHE = new StringIdImpl(4183, "In post-process: not authorized to perform QUERY operation {0} on the cache");
  public static final StringId AuthorizeRequestPP_IN_POSTPROCESS_NOT_AUTHORIZED_TO_PERFORM_EXECUTE_CQ_OPERATION_0_ON_THE_CACHE = new StringIdImpl(4184, "In post-process: not authorized to perform EXECUTE_CQ operation {0} on the cache");
  public static final StringId AuthorizeRequestPP_IN_POSTPROCESS_NOT_AUTHORIZED_TO_PERFORM_KEY_SET_OPERATION_ON_REGION_0 = new StringIdImpl(4185, "In post-process: not authorized to perform KEY_SET operation on region {0}");
  public static final StringId ServerConnection_0_AUTHORIZATION_ENABLED_BUT_THE_AUTHENTICATION_CALLBACK_1_RETURNED_WITH_NULL_CREDENTIALS_FOR_THE_PROXYID_2 = new StringIdImpl(4186, "{0}: Authorization enabled but the authentication callback ({1}) returned with null credentials for the proxyID {2}");
  public static final StringId ServerConnection_DUPLICATE_DURABLE_CLIENTID_0 = new StringIdImpl(4187, "Duplicate durable clientId ({0})");
  public static final StringId ServerMonitor_PROCESSDEADCONNECTIONS_CACHESERVER_0_1_CANNOT_BE_CONTACTED_DUE_TO_AN_EXCEPTION_2 = new StringIdImpl(4188, "processDeadConnections: CacheServer {0} -> {1} cannot be contacted due to an exception. {2}");
  public static final StringId PrimaryKeyIndex_FOR_A_PRIMARYKEY_INDEX_A_RANGE_HAS_NO_MEANING = new StringIdImpl(4189, "For a PrimaryKey Index , a range has no meaning");
  public static final StringId BaseCommand_REGION_DESTROYED_DURING_THE_EXECUTION_OF_THE_QUERY = new StringIdImpl(4190, "Region destroyed during the execution of the query");
  public static final StringId ConnectionProxyImpl_NON_DURABLE_CLIENT_CAN_NOT_REGISTER_OR_UNREGISTER_DURABLE_INTEREST = new StringIdImpl(4191, "Non Durable client can not register or unregister durable interest");
  public static final StringId HandShake_SERVER_EXPECTING_SSL_CONNECTION = new StringIdImpl(4192, "Server expecting SSL connection");
  public static final StringId HandShake_REMOTE_WAN_SITE_DID_NOT_HAVE_VALID_CREDENTIALS = new StringIdImpl(4193, "remote wan site did not have valid credentials");
  public static final StringId HandShake_FAILED_TO_ACQUIRE_AUTHINITIALIZE_METHOD_0 = new StringIdImpl(4194, "Failed to acquire AuthInitialize method {0}");
  public static final StringId HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED = new StringIdImpl(4195, "No security-* properties are provided");
  public static final StringId HandShake_FAILURE_IN_READING_CREDENTIALS = new StringIdImpl(4196, "Failure in reading credentials");
  public static final StringId HandShake_FAILED_TO_ACQUIRE_AUTHENTICATOR_OBJECT = new StringIdImpl(4197, "Failed to acquire Authenticator object");
  public static final StringId HandShake_AUTHENTICATOR_INSTANCE_COULD_NOT_BE_OBTAINED = new StringIdImpl(4198, "Authenticator instance could not be obtained");
  public static final StringId HandShake_METHOD_CANNOT_BE_EMPTY = new StringIdImpl(4199, "method cannot be empty");
  public static final StringId HandShake_UNABLE_TO_DESERIALIZE_MEMBER = new StringIdImpl(4200, "Unable to deserialize member");
  public static final StringId CacheClientUpdater__0_IS_WAITING_FOR_1_TO_COMPLETE = new StringIdImpl(4201, "{0} is waiting for {1} to complete.");
  public static final StringId CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_HANDLE_A_MARKER = new StringIdImpl(4202, "The following exception occurred while attempting to handle a marker.");
  public static final StringId CacheClientUpdater_CAUGHT_THE_FOLLOWING_EXCEPTION_WHILE_ATTEMPTING_TO_INVALIDATE_REGION_0 = new StringIdImpl(4203, "Caught the following exception while attempting to invalidate region {0}.");
  public static final StringId CacheClientNotifier_THE_REGION_NAMED_0_WAS_NOT_FOUND = new StringIdImpl(4204, "The Region named \"{0}\" was not found");
  public static final StringId ConnectionImpl_SSL_NEGOTIATION_FAILED_WITH_ENDPOINT = new StringIdImpl(4205, "SSL negotiation failed with endpoint: ");
  public static final StringId LocalRegion_REGION_0_MUST_BE_DESTROYED_BEFORE_CALLING_GETDESTROYEDSUBREGIONSERIALNUMBERS = new StringIdImpl(4206, "Region {0} must be destroyed before calling getDestroyedSubregionSerialNumbers");
  public static final StringId PRHARedundancyProvider_IF_YOUR_SYSTEM_HAS_SUFFICIENT_SPACE_PERHAPS_IT_IS_UNDER_MEMBERSHIP_OR_REGION_CREATION_STRESS = new StringIdImpl(4207, "If your system has sufficient space, perhaps it is under membership or region creation stress?");
  public static final StringId PRHARedundancyProvider_CONSIDER_STARTING_ANOTHER_MEMBER = new StringIdImpl(4208, "Advise you to start enough data store nodes");
  public static final StringId PartitionedRegion_TIMED_OUT_ATTEMPTING_TO_ALLOCATE_A_BUCKET_IN_THE_PARTITIONED_REGION = new StringIdImpl(4209, "Timed out attempting to allocate a bucket in the partitioned region.");
  public static final StringId CacheClientUpdater_CLOSING_SOCKET_IN_0_FAILED = new StringIdImpl(4210, "Closing socket in {0} failed");
  public static final StringId PartitionedRegion_TIMED_OUT_ATTEMPTING_TO_DESTROY_A_BUCKET_IN_THE_PARTITIONED_REGION = new StringIdImpl(4211, "Timed out attempting to destroy a bucket in the partitioned region.");
  public static final StringId ConnectionTable_MESSAGE_DISTRIBUTION_IS_TERMINATING = new StringIdImpl(4212, "Message distribution is terminating");
  public static final StringId ConnectionTable_TIMER_CANCELLED = new StringIdImpl(4213, "Timer cancelled");
  public static final StringId InternalLocator_FAILED_READING_0 = new StringIdImpl(4214, "Failed reading {0}");
  public static final StringId AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2 = new StringIdImpl(4215, "Could not set \"{0}\" to \"{1}\" because its value can not be less than \"{2}\".");
  public static final StringId AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2 = new StringIdImpl(4216, "Could not set \"{0}\" to \"{1}\" because its value can not be greater than \"{2}\".");
  public static final StringId AbstractDistributionConfig_DEFAULT_ACK_WAIT_THRESHOLD_0_1_2 = new StringIdImpl(4217, "The number of seconds a distributed message can wait for acknowledgment before it sends an alert to signal that something might be wrong with the system node that is unresponsive. After sending this alert the waiter continues to wait. The alerts are logged in the system log as warnings and if a gfc is running will cause a console alert to be signalled.  Defaults to \"{0}\".  Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_ARCHIVE_FILE_SIZE_LIMIT_NAME = new StringIdImpl(4218, "The maximum size in megabytes of a statistic archive file. Once this limit is exceeded, a new statistic archive file is created, and the current archive file becomes inactive. If set to zero, file size is unlimited.");
  public static final StringId AbstractDistributionConfig_ARCHIVE_DISK_SPACE_LIMIT_NAME = new StringIdImpl(4219, "The maximum size in megabytes of all inactive statistic archive files combined. If this limit is exceeded, inactive archive files will be deleted, oldest first, until the total size is within the limit. If set to zero, disk space usage is unlimited.");
  public static final StringId AbstractDistributionConfig_CACHE_XML_FILE_NAME_0 = new StringIdImpl(4220, "The file whose contents is used, by default, to initialize a cache if one is created.  Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_DISABLE_TCP_NAME_0 = new StringIdImpl(4221, "Determines whether TCP/IP communications will be disabled, forcing use of datagrams between members of the distributed system. Defaults to {0}");
  public static final StringId AbstractDistributionConfig_ENABLE_TIME_STATISTICS_NAME = new StringIdImpl(4222, "Turns on timings in distribution and cache statistics.  These are normally turned off to avoid expensive clock probes.");
  public static final StringId AbstractDistributionConfig_LICENSE_DATA_MANAGEMENT_0 = new StringIdImpl(4223, "The value of the data management serial number. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_LICENSE_TYPE_NAME_0 = new StringIdImpl(4224, "The type of license this distributed system will use.  Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_LOG_FILE_NAME_0 = new StringIdImpl(4225, "The file a running system will write log messages to.  Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_LOG_LEVEL_NAME_0_1 = new StringIdImpl(4226, "Controls the type of messages that will actually be written to the system log.  Defaults to \"{0}\".  Allowed values \"{1}\".");
  public static final StringId AbstractDistributionConfig_LOG_FILE_SIZE_LIMIT_NAME = new StringIdImpl(4227, "The maximum size in megabytes of a child log file. Once this limit is exceeded, a new child log is created, and the current child log becomes inactive. If set to zero, child logging is disabled.");
  public static final StringId AbstractDistributionConfig_LOG_DISK_SPACE_LIMIT_NAME = new StringIdImpl(4228, "The maximum size in megabytes of all inactive log files combined. If this limit is exceeded, inactive log files will be deleted, oldest first, until the total size is within the limit. If set to zero, disk space usage is unlimited.");
  public static final StringId AbstractDistributionConfig_LOCATORS_NAME_0 = new StringIdImpl(4229, "A possibly empty list of locators used to find other system nodes. Each element of the list must be a host name followed by bracketed, \"[]\", port number. Host names may be followed by a colon and a bind address used by the locator on that host.  Multiple elements must be comma seperated. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_TCP_PORT_NAME_0_1_2 = new StringIdImpl(4230, "The port used for tcp/ip communcations in the distributed system. If zero then a random available port is selected by the operating system.   Defaults to \"{0}\".  Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_MCAST_PORT_NAME_0_1_2 = new StringIdImpl(4231, "The port used for multicast communcations in the distributed system. If zero then locators are used, and multicast is disabled.   Defaults to \"{0}\".  Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_MCAST_ADDRESS_NAME_0_1 = new StringIdImpl(4232, "The address used for multicast communications. Only used if {0} is non-zero.  Defaults to \"{1}\".");
  public static final StringId AbstractDistributionConfig_MCAST_TTL_NAME_0_1_2 = new StringIdImpl(4233, "Determines how far through your network mulicast packets will propogate. Defaults to \"{0}\".  Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_MCAST_SEND_BUFFER_SIZE_NAME_0 = new StringIdImpl(4234, "Sets the size of multicast socket transmission buffers, in bytes.  Defaults to {0} but this may be limited by operating system settings");
  public static final StringId AbstractDistributionConfig_MCAST_RECV_BUFFER_SIZE_NAME_0 = new StringIdImpl(4235, "Sets the size of multicast socket receive buffers, in bytes.  Defaults to {0} but this may be limited by operating system settings");
  public static final StringId AbstractDistributionConfig_MCAST_FLOW_CONTROL_NAME_0 = new StringIdImpl(4236, "Sets the flow-of-control parameters for multicast messaging.  Defaults to {0}.");
  public static final StringId AbstractDistributionConfig_MEMBER_TIMEOUT_NAME_0 = new StringIdImpl(4237, "Sets the number of milliseconds to wait for ping responses when determining whether another member is still alive. Defaults to {0}.");
  public static final StringId AbstractDistributionConfig_UDP_SEND_BUFFER_SIZE_NAME_0 = new StringIdImpl(4238, "Sets the size of datagram socket transmission buffers, in bytes.  Defaults to {0} but this may be limited by operating system settings");
  public static final StringId AbstractDistributionConfig_UDP_RECV_BUFFER_SIZE_NAME_0 = new StringIdImpl(4239, "Sets the size of datagram socket receive buffers, in bytes. Defaults to {0} but this may be limited by operating system settings");
  public static final StringId AbstractDistributionConfig_UDP_FRAGMENT_SIZE_NAME_0 = new StringIdImpl(4240, "Sets the maximum size of a datagram for UDP and multicast transmission.  Defaults to {0}.");
  public static final StringId AbstractDistributionConfig_SOCKET_LEASE_TIME_NAME_0_1_2 = new StringIdImpl(4241, "The number of milliseconds a thread can keep exclusive access to a socket that it is not actively using. Once a thread loses its lease to a socket it will need to re-acquire a socket the next time it sends a message. A value of zero causes socket leases to never expire. Defaults to \"{0}\" .  Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_SOCKET_BUFFER_SIZE_NAME_0_1_2 = new StringIdImpl(4242, "The size of each socket buffer, in bytes. Smaller buffers conserve memory. Larger buffers can improve performance; in particular if large messages are being sent. Defaults to \"{0}\".  Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_CONSERVE_SOCKETS_NAME_0 = new StringIdImpl(4243, "If true then a minimal number of sockets will be used when connecting to the distributed system. This conserves resource usage but can cause performance to suffer. If false, the default, then every application thread that sends distribution messages to other members of the distributed system will own its own sockets and have exclusive access to them. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_ROLES_NAME_0 = new StringIdImpl(4244, "The application roles that this member performs in the distributed system. This is a comma delimited list of user-defined strings. Any number of members can be configured to perform the same role, and a member can be configured to perform any number of roles. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_BIND_ADDRESS_NAME_0 = new StringIdImpl(4245, "The address server sockets will listen on. An emtpy string causes the server socket to listen on all local addresses. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_SERVER_BIND_ADDRESS_NAME_0 = new StringIdImpl(4246, "The address server sockets in a client-server topology will listen on. An emtpy string causes the server socket to listen on all local addresses. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_NAME_NAME_0 = new StringIdImpl(4247, "A symbolic name that can be used to help identify a system.  Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_STATISTIC_ARCHIVE_FILE_NAME_0 = new StringIdImpl(4248, "The file a running system will write statistic samples to.  Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_STATISTIC_SAMPLE_RATE_NAME_0_1_2 = new StringIdImpl(4249, "The rate, in milliseconds, that a running system will sample statistics.  Defaults to \"{0}\".  Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_STATISTIC_SAMPLING_ENABLED_NAME_0 = new StringIdImpl(4250, "If false then archiving is disabled and operating system statistics are no longer updated.  Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_SSL_ENABLED_NAME_0 = new StringIdImpl(4251, "Communication is performed through SSL when this property is set to true. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_SSL_PROTOCOLS_NAME_0 = new StringIdImpl(4252, "List of available SSL protocols that are to be enabled. Defaults to \"{0}\" meaning your provider''s defaults.");
  public static final StringId AbstractDistributionConfig_SSL_CIPHERS_NAME_0 = new StringIdImpl(4253, "List of available SSL cipher suites that are to be enabled. Defaults to \"{0}\" meaning your provider''s defaults.");
  public static final StringId AbstractDistributionConfig_SSL_REQUIRE_AUTHENTICATION_NAME = new StringIdImpl(4254, "if set to false, ciphers and protocols that permit anonymous peers are allowed. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_MAX_WAIT_TIME_FOR_RECONNECT = new StringIdImpl(4255, "Specifies the maximum time to wait before trying to reconnect to distributed system in the case of required role loss.");
  public static final StringId AbstractDistributionConfig_MAX_NUM_RECONNECT_TRIES = new StringIdImpl(4256, "Maximum number of tries before shutting the member down in the case of required role loss.");
  public static final StringId AbstractDistributionConfig_DURABLE_CLIENT_TIMEOUT_NAME_0 = new StringIdImpl(4257, "The value (in seconds) used by the server to keep disconnected durable clients alive. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_SECURITY_CLIENT_AUTH_INIT_NAME_0 = new StringIdImpl(4258, "User defined fully qualified method name implementing AuthInitialize interface for client. Defaults to \"{0}\". Legal values can be any \"method name\" of a static method that is present in the classpath.");
  public static final StringId AbstractDistributionConfig_SECURITY_CLIENT_AUTHENTICATOR_NAME_0 = new StringIdImpl(4259, "User defined fully qualified method name implementing Authenticator interface for client verification. Defaults to \"{0}\". Legal values can be any \"method name\" of a static method that is present in the classpath.");
  public static final StringId AbstractDistributionConfig_SECURITY_PEER_AUTH_INIT_NAME_0 = new StringIdImpl(4260, "User defined fully qualified method name implementing AuthInitialize interface for peer. Defaults to \"{0}\". Legal values can be any \"method name\" of a static method that is present in the classpath.");
  public static final StringId AbstractDistributionConfig_SECURITY_PEER_AUTHENTICATOR_NAME_0 = new StringIdImpl(4261, "User defined fully qualified method name implementing Authenticator interface for peer verificaiton. Defaults to \"{0}\". Legal values can be any \"method name\" of a static method that is present in the classpath.");
  public static final StringId AbstractDistributionConfig_SECURITY_CLIENT_ACCESSOR_NAME_0 = new StringIdImpl(4262, "User defined fully qualified method name implementing AccessControl interface for client authorization. Defaults to \"{0}\". Legal values can be any \"method name\" of a static method that is present in the classpath.");
  public static final StringId AbstractDistributionConfig_SECURITY_CLIENT_ACCESSOR_PP_NAME_0 = new StringIdImpl(4263, "User defined fully qualified method name implementing AccessControl interface for client authorization in post-processing phase. Defaults to \"{0}\". Legal values can be any \"method name\" of a static method that is present in the classpath.");
  public static final StringId AbstractDistributionConfig_SECURITY_LOG_LEVEL_NAME_0_1 = new StringIdImpl(4264, "Controls the type of messages that will actually be written to the system security log. Defaults to \"{0}\".  Allowed values \"{1}\".");
  public static final StringId AbstractDistributionConfig_SECURITY_LOG_FILE_NAME_0 = new StringIdImpl(4265, "The file a running system will write security log messages to. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_SECURITY_PEER_VERIFYMEMBER_TIMEOUT_NAME_0 = new StringIdImpl(4266, "The timeout value (in milliseconds) used by a peer to verify membership of an unknown authenticated peer requesting a secure connection. Defaults to \"{0}\" milliseconds. The timeout value should not exceed peer handshake timeout.");
  public static final StringId AbstractDistributionConfig_SECURITY_PREFIX_NAME = new StringIdImpl(4267, "Prefix for \"security\" related properties which are packed together and invoked as authentication parameter. Neither key nor value can be NULL. Legal tags can be [security-username, security-digitalid] and Legal values can be any string data.");
  public static final StringId AbstractDistributionConfig_DURABLE_CLIENT_ID_NAME_0 = new StringIdImpl(4268, "An id used by durable clients to identify themselves as durable to servers. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_ASYNC_DISTRIBUTION_TIMEOUT_NAME_0_1_2 = new StringIdImpl(4269, "The number of milliseconds before a publishing process should attempt to distribute a cache operation before switching over to asynchronous messaging for this process. Defaults to \"{0}\". Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_ASYNC_QUEUE_TIMEOUT_NAME_0_1_2 = new StringIdImpl(4270, "The number of milliseconds a queuing may enqueue asynchronous messages without any distribution to this process before that publisher requests this process to depart. Defaults to \"{0}\" Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_ASYNC_MAX_QUEUE_SIZE_NAME_0_1_2 = new StringIdImpl(4271, "The maximum size in megabytes that a publishing process should be allowed to asynchronously enqueue for this process before asking this process to depart from the distributed system. Defaults to \"{0}\". Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_STATUS_MONITORING_ENABLED_NAME_0 = new StringIdImpl(4272, "If false then status monitoring is disabled. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_STATUS_MONITORING_PORT_NAME_0_1_2 = new StringIdImpl(4273, "The status monitoring port used to listen for status requests. Defaults to \"{0}\". Legal values are in the range [{1}..{2}].");
  public static final StringId AbstractDistributionConfig_START_LOCATOR_NAME = new StringIdImpl(4274, "The host|bindAddress[port] of a Locator to start in this VM along with the DistributedSystem. The default is to not start a Locator.");
  public static final StringId InternalDistributedSystem_DISTRIBUTED_SYSTEM_HAS_DISCONNECTED = new StringIdImpl(4275, "Distributed system has disconnected during startup.");
  public static final StringId InternalDistributedSystem_EXCEPTION_TRYING_TO_CLOSE_CACHE = new StringIdImpl(4276, "Exception trying to close cache");
  public static final StringId InternalDistributedSystem_PROBLEM_STARTING_A_LOCATOR_SERVICE = new StringIdImpl(4277, "Problem starting a locator service");
  public static final StringId AbstractGroupOrRangeJunction_INTERMEDIATERESULTS_CAN_NOT_BE_NULL = new StringIdImpl(4278, "intermediateResults can not be null");
  public static final StringId RangeJunction_IN_THE_CASE_OF_AN_OR_JUNCTION_A_RANGEJUNCTION_SHOULD_NOT_BE_FORMED_FOR_NOW = new StringIdImpl(4279, "In the case of an OR junction a RangeJunction should not be formed for now");
  public static final StringId CacheClientUpdater__0_HAS_COMPLETED_WAITING_FOR_1 = new StringIdImpl(4280, "{0} has completed waiting for {1}.");
  public static final StringId CqService_0_FAILED_TO_REMOVE_THE_SPECIFIED_CQ = new StringIdImpl(4281, "{0} Failed to remove the specified CQ.");
  public static final StringId CqService_0_FAILED_TO_GET_THE_SPECIFIED_CQ = new StringIdImpl(4282, "{0} Failed to get the specified CQ.");
  public static final StringId EndPointImpl_UPDATER_FOR_ENDPOINT_0_DID_NOT_JOIN = new StringIdImpl(4283, "Updater for endpoint {0} did not join");
  public static final StringId ConnectionProxyImpl_0_ATTEMPTING_TO_RESTORE_REDUNDANCY_VIA_1 = new StringIdImpl(4284, "{0}: attempting to restore redundancy via {1}");
  public static final StringId HandShake_THE_END_OF_THE_STREAM_HAS_BEEN_REACHED = new StringIdImpl(4285, "The end of the stream has been reached.");
  public static final StringId HandShake_INVALID_WAN_PROPERTIES_WERE_RECEIVED_0 = new StringIdImpl(4286, "Invalid wan properties were received. {0}");
  public static final StringId QCompiler_THE_LIKE_PREDICATE_SHOULD_NOT_CONTAIN__ = new StringIdImpl(4287, "The like predicate should not contain ''_''");
  public static final StringId QCompiler_A_LIKE_PREDICATE_TERMINATING_WITH_IS_NOT_SUPPORTED = new StringIdImpl(4288, "A Like predicate terminating with ''_'' is not supported");
  public static final StringId QCompiler_NON_SARGABLE_PREDICATES_ARE_NOT_SUPPORTED = new StringIdImpl(4289, "Non Sargable predicates are not supported");
  public static final StringId CqService_A_CQ_WITH_THE_GIVEN_NAME_0_ALREADY_EXISTS = new StringIdImpl(4290, "A CQ with the given name \"{0}\" already exists.");
  public static final StringId ConnectionProxyImpl_FAILED_TO_REGISTER_INTEREST_ON_PRIMARY_SERVER = new StringIdImpl(4291, "Failed to register interest on primary server");
  public static final StringId ConnectionProxyImpl_NO_SERVER_AVAILABLE_FAILED_TO_REGISTER_INTEREST = new StringIdImpl(4292, "No server available. Failed to register interest.");
  public static final StringId ConnectionProxyImpl_NO_SERVER_AVAILABLE_FAILED_TO_UNREGISTER_INTEREST = new StringIdImpl(4293, "No server available. Failed to unregister interest.");
  public static final StringId Handshake_UNABLE_TO_DESERIALIZE_AND_GET_WAN_CREDENTIALS = new StringIdImpl(4294, "Unable to deserialize and get wan credentials");
  public static final StringId LocalRegion_FAILED_TO_ADD_THE_CQ_NAMED_0_FOR_THE_CLIENT_1_INTO_BASEREGIONS_CQ_MAP = new StringIdImpl(4295, "Failed to add the cq named {0} for the client {1} into BaseRegion''s CQ Map.");
  public static final StringId PKCSAuthenticator_INVALID_ALIAS_RECEIVED = new StringIdImpl(4296, "invalid alias received");
  public static final StringId PKCSAuthenticator_NO_PUBLIC_KEY_FOUND_FOR_ALIAS_0 = new StringIdImpl(4297, "No public key found for alias: {0}");
  public static final StringId PKCSAuthenticator_PKCSAUTHENTICATOR_ENCRYPTED_DATA_PROPERTY_0_NOT_PROVIDED = new StringIdImpl(4298, "PKCSAuthenticator: encrypted data property [{0}] not provided");
  public static final StringId PKCSAuthenticator_ALIAS_MISMATCH = new StringIdImpl(4299, "alias mismatch");
  public static final StringId PKCSAuthenticator_PKCSAUTHENTICATOR_EXCEPTION_DURING_AUTHENTICATION_0 = new StringIdImpl(4300, "PKCSAuthenticator: Exception during authentication: {0}");
  public static final StringId PKCSAuthenticator_EXCEPTION_WHILE_GETTING_PUBLIC_KEYS_0 = new StringIdImpl(4301, "Exception while getting public keys: {0}");
  public static final StringId PKCSAuthenticator_PKCSAUTHENTICATOR_PROPERTY_0_NOT_SPECIFIED_AS_THE_PUBLIC_KEY_FILE = new StringIdImpl(4302, "PKCSAuthenticator: property {0} not specified as the public key file.");
  public static final StringId PartitionedRegionDatastore_EXECUTEFUNCTIONMESSAGE_COULD_NOT_SERIALIZE_RESULT_0_FOR_PROCESSORID_1 = new StringIdImpl(4303, "ExecuteFunctionMessage Could not serialize result {0} for processorId = {1}");
  public static final StringId PartitionedRegion_NO_VM_AVAILABLE_FOR_GET_IN_0_ATTEMPTS = new StringIdImpl(4304, "No VM available for get in {0} attempts");
  public static final StringId Connection_THREAD_OWNED_RECEIVER_FORCING_ITSELF_TO_SEND_ON_THREAD_OWNED_SOCKETS = new StringIdImpl(4305, "thread owned receiver forcing itself to send on thread owned sockets");
  public static final StringId CqQueryImpl_EXCEPTION_WHILE_EXECUTING_CQ_ON_THE_ENDPOINT_0_EXCEPTION_1 = new StringIdImpl(4306, "Exception while executing cq on the endpoint: {0}. Exception: {1}");
  public static final StringId RemoteGFManagerAgent_AN_AUTHENTICATIONFAILEDEXCEPTION_WAS_CAUGHT_WHILE_CONNECTING_TO_DS = new StringIdImpl(4307, "[RemoteGfManagerAgent]: An AuthenticationFailedException was caught while connecting to DS");
  public static final StringId ExecuteFunctionMessage_EXECUTEFUNCTIONREPLYMESSAGE_WAS_UNABLE_TO_DESERIALIZE_A_PORTION_OF_THE_DATA_FOR_PROCESSORID_0 = new StringIdImpl(4308, "ExecuteFunctionReplyMessage was unable to deserialize a portion of the data for processorId {0}.");
  public static final StringId ExecuteFunctionMessage_EXECUTEFUNCTIONREPLYMESSAGE_WAS_UNABLE_TO_COMPLETE_A_PORTION_OF_THE_DATA_FOR_PROCESSORID_0 = new StringIdImpl(4309, "ExecuteFunctionReplyMessage was unable to complete a portion of the data for processorId {0}.");
  public static final StringId StoreAllCachedDeserializable_VALUE_MUST_NOT_BE_NULL = new StringIdImpl(4310, "value must not be null");
  public static final StringId LocalReadPartitionedRegion_PARTITIONED_REGION_0_HAS_NO_LOCAL_DATA = new StringIdImpl(4311, "Partitioned Region {0} has no local data.");
  public static final StringId PartitionAttributesImpl_CLONENOTSUPPORTEDEXCEPTION_THROWN_IN_CLASS_THAT_IMPLEMENTS_CLONEABLE = new StringIdImpl(4312, "CloneNotSupportedException thrown in class that implements cloneable");
  public static final StringId PartitionAttributesImpl_REDUNDANTCOPIES_0_IS_AN_ILLEGAL_VALUE_PLEASE_CHOOSE_A_VALUE_BETWEEN_0_AND_3 = new StringIdImpl(4313, "RedundantCopies {0} is an illegal value, please choose a value between 0 and 3");
  public static final StringId PartitionAttributesImpl_TOTALNUMBICKETS_0_IS_AN_ILLEGAL_VALUE_PLEASE_CHOOSE_A_VALUE_GREATER_THAN_0 = new StringIdImpl(1902, "TotalNumBuckets {0} is an illegal value, please choose a value greater than 0");
  public static final StringId PartitionAttributesImpl_UNKNOWN_LOCAL_PROPERTY_0 = new StringIdImpl(4314, "Unknown local property: ''{0}''");
  public static final StringId PartitionAttributesImpl_UNKNOWN_GLOBAL_PROPERTY_0 = new StringIdImpl(4315, "Unknown global property: ''{0}''");
  public static final StringId ExecuteFunctionMessage_FUNCTION_NAMED_0_WAS_NOT_FOUND_PLEASE_VERIFY_THAT_THE_APPROPRIATE_FUNCTION_HAS_BEEN_INSTALLED = new StringIdImpl(4316, "Function named {0} was not found. Please verify that the appropriate function has been installed.");
  public static final StringId ExecuteFunctionMessage_UNABLE_TO_SERIALIZE_VALUE = new StringIdImpl(4317, "Unable to serialize value");
  public static final StringId ExecuteFunctionMessage_OPERATION_GOT_INTERRUPTED_DUE_TO_SHUTDOWN_IN_PROGRESS_ON_REMOTE_VM = new StringIdImpl(4318, "Operation got interrupted due to shutdown in progress on remote VM");
  public static final StringId ExecuteFunctionMessage_GET_MESSAGE_SENT_TO_WRONG_MEMBER = new StringIdImpl(4319, "Get message sent to wrong member");
  public static final StringId ExecuteFunctionMessage_FAILED_SENDING_0 = new StringIdImpl(4320, "Failed sending <{0}>");
  public static final StringId ExecuteFunctionMessage_EXECUTEFUNCTIONRESPONSE_GOT_REMOTE_CACHEEXCEPTION_THROWING_FORCEREATTEMPTEXCEPTION = new StringIdImpl(4321, "ExecuteFunctionResponse got remote CacheException, throwing ForceReattemptException");
  public static final StringId Scope_0_IS_NOT_A_VALID_STRING_REPRESENTATION_OF_1 = new StringIdImpl(4322, "{0} is not a valid string representation of {1}.");
  public static final StringId CacheXmlParser_A_0_MUST_BE_DEFINED_IN_THE_CONTEXT_OF_PARTITIONATTRIBUTES = new StringIdImpl(4323, "A {0} must be defined in the context of partition-attributes");
  public static final StringId CacheXmlParser_A_0_IS_NOT_AN_INSTANCE_OF_A_1 = new StringIdImpl(4324, "A {0} is not an instance of a {1}");
  public static final StringId PartitionedRegion_ATTEMPT_TO_ACQUIRE_PRIMARY_NODE_FOR_READ_ON_BUCKET_0_TIMED_OUT = new StringIdImpl(4325, "Attempt to acquire primary node for read on bucket {0} timed out.");
  public static final StringId ExecuteFunction_THE_FUNCTION_GET_ID_RETURNED_NULL = new StringIdImpl(4326, "The Function#getID() returned null");
  public static final StringId PartitionedRegion_NO_TARGET_NODE_FOUND_FOR_KEY_0 = new StringIdImpl(4327, "No target node found for KEY = {0}");
  public static final StringId Connection_CONNECTION_FAILED_CONSTRUCTION_FOR_PEER_0 = new StringIdImpl(4328, "Connection: failed construction for peer {0}");
  public static final StringId AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_2_MUST_BE_0_WHEN_SECURITY_IS_ENABLED = new StringIdImpl(4329, "Could not set \"{0}\" to \"{1}\" because \"{2}\" must be 0 when security is enabled.");
  public static final StringId CqService_NOT_SENDING_CQ_CLOSE_TO_THE_SERVER_AS_IT_IS_A_DURABLE_CQ = new StringIdImpl(4330, "Not sending CQ close to the server as it is a durable CQ ");
  public static final StringId GemFireCache_CACHE_ENCOUNTERED_REPLAY_OF_EVENT_WITH_ID_0 = new StringIdImpl(4331, "Cache encountered replay of event with ID {0}. This usually occurs in client/server configurations when clients have retransmitted an operation after server failure.");
  public static final StringId ClientCacheNotifier_STALECLIENTPROXY_EXCEPTION_WHILE_WAITING_FOR_PROXY_REMOVAL = new StringIdImpl(4332, "staleClientProxy: Exception while waiting for proxy removal.");
  public static final StringId ServerConnection_EXCEPTION_WHILE_WAITING_FOR_PROXY_REMOVAL = new StringIdImpl(4333, "Exception while waiting for proxy removal.");
  public static final StringId CacheClientProxy_CQEXCEPTION_WHILE_CLOSING_NON_DURABLE_CQS_0 = new StringIdImpl(4334, "CqException while closing non durable Cqs. {0}");
  public static final StringId CqService_SERVER_UNREACHABLE_EXCEPTION = new StringIdImpl(4335, "Server unreachable exception");
  public static final StringId InitialImageOperation_REGION_0_REQUESTING_INITIAL_IMAGE_FROM_1 = new StringIdImpl(4336, "Region {0} requesting initial image from {1}");
  public static final StringId CacheClientUpdater_ERROR_WHILE_PROCESSING_THE_CQ_MESSAGE_PROBLEM_WITH_READING_MESSAGE_FOR_CQ_0 = new StringIdImpl(4337, "Error while processing the CQ Message. Problem with reading message for CQ# : {0}");
  public static final StringId StopCQ_EXCEPTION_WHILE_STOPPING_CQ_NAMED_0 = new StringIdImpl(4338, "Exception while stopping CQ named {0} :");
  public static final StringId AbstractRegionMap_RETRIED_1_MILLION_TIMES_FOR_ENTRY_TO_GO_AWAY_0 = new StringIdImpl(4339, "retried 1 million times for entry to go away: {0}");
  public static final StringId CacheClientUpdater_0_READY_TO_PROCESS_MESSAGES = new StringIdImpl(4340, "{0} : ready to process messages.");
  public static final StringId ClientHealthMonitoringRegion_ERROR_WHILE_CREATING_AN_ADMIN_REGION = new StringIdImpl(4341, "Error while creating an admin region");
  public static final StringId ClientStatsManager_CLIENTSTATSMANAGER_PUBLISHCLIENTSTATS_ERROR_WHILE_PUBLISHING_THE_CLIENT_STATS = new StringIdImpl(4342, "ClientStatsManager.publishClientStats Error while publishing the client stats");
  public static final StringId ClientStatsManager_CACHESERVERCLIENTSTATS_HAS_NOT_YET_INITIALIZED_CLIENTSTATSMONITORINGSERVICE_CANNT_PROCEED_FOR_NOW = new StringIdImpl(4343, "CacheServerClientStats has not yet initialized. ClientStatsMonitoringService cannot proceed for now!");
  public static final StringId ClientStatsManager_STATISTICSAMPLING_IS_NOT_ENABLED_CLIENTSTATSMONITORINGSERVICE_CANNT_GATHER_PROCESS_STATS = new StringIdImpl(4344, "statistic-sampling is not enabled.ClientStatsMonitoringService cannot gather process stats.");
  public static final StringId ClientStatsManager_CLIENTSTATSMONITORINGSERVICE_SINCE_WE_ARE_OPERATING_UNDER_PURE_JAVA_MODE_NO_PROCESS_STATS_ARE_AVAILABLE = new StringIdImpl(4345, "ClientStatsMonitoringService, Since we are operating under pure java mode, no process stats are available.");
  public static final StringId TCPConduit_UNABLE_TO_CLOSE_AND_RECREATE_SERVER_SOCKET = new StringIdImpl(4346, "Unable to close and recreate server socket");
  public static final StringId TCPConduit_INTERRUPTED_AND_EXITING_WHILE_TRYING_TO_RECREATE_LISTENER_SOCKETS = new StringIdImpl(4347, "Interrupted and exiting while trying to recreate listener sockets");
  public static final StringId TCPConduit_SERVERSOCKET_THREW_SOCKET_CLOSED_EXCEPTION_BUT_SAYS_IT_IS_NOT_CLOSED = new StringIdImpl(4348, "ServerSocket threw ''socket closed'' exception but says it is not closed");
  public static final StringId TCPConduit_SERVERSOCKET_CLOSED_REOPENING = new StringIdImpl(4349, "ServerSocket closed - reopening");
  public static final StringId StatAlertsManager_STATALERTSMANAGER_CREATED = new StringIdImpl(4350, "StatAlertsManager created");
  public static final StringId StatAlertsManager_STATALERTAMANEGR_INVALID_ARGUMENT_0 = new StringIdImpl(4351, "StatAlertAmanegr : Invalid argument: {0}");
  public static final StringId StatAlertsManager_STATALERTAMANEGR_ERROR_IN_STATS_REFRESH_THREAD_0 = new StringIdImpl(4352, "StatAlertAmanegr : Error in Stats refresh thread {0}");
  public static final StringId StatAlertsManager_STATALERTSMANAGER_CREATEMEMBERSTATALERTDEFINITION_STATISTICS_WITH_GIVEN_TEXTID_0_NOT_FOUND = new StringIdImpl(4353, "StatAlertsManager.createMemberStatAlertDefinition :: statistics with given textId={0}, NOT found.");
  public static final StringId StatAlertsManager_STATALERTMANAGER_EVALUATEALERTDEFNSTASK_THREADINTERRUPTEDEXCEPTION_EXITING_0 = new StringIdImpl(4354, "StatAlertManager.EvaluateAlertDefnsTask :ThreadInterruptedException, exiting: {0}");
  public static final StringId StatAlertsManager_STATALERTMANAGER_EVALUATEALERTDEFNSTASK_DISTRIBUTIONMANAGER_SHUTDOWN_EXITING_0 = new StringIdImpl(4355, "StatAlertManager.EvaluateAlertDefnsTask :DistributionManager Shutdown, exiting: {0}");
  public static final StringId StatAlertsManager_STATALERTMANAGER_EVALUATEALERTDEFNSTASK_DISTRIBUTED_MESSAGE_IS_NOT_SERIALIZABLE_0 = new StringIdImpl(4356, "StatAlertManager.EvaluateAlertDefnsTask :Distributed message is not serializable: {0}");
  public static final StringId StatAlertsManager_STATALERTMANAGER_EVALUATEALERTDEFNSTASK_GENERAL_EXCEPTION_0 = new StringIdImpl(4357, "StatAlertManager.EvaluateAlertDefnsTask :General Exception: {0}");
  public static final StringId CqQueryImpl_CQ_NOT_REGISTERED_ON_PRIMARY = new StringIdImpl(4358, "Cq not registered on primary");
  public static final StringId HACacheServer_INITIALIZED = new StringIdImpl(4359, "Initialized");
  // ok to reuse 4360
  public static final StringId HARegionQueue_TASK_TO_DECREMENT_THE_REF_COUNT_MAY_NOT_HAVE_BEEN_STARTED = new StringIdImpl(4361, "Exception in HARegionQueue.updateHAContainer(). The task to decrement the ref count by one for all the HAEventWrapper instances of this queue present in the haContainer may not have been started");
  public static final StringId CacheClientNotifier_HACONTAINER_0_IS_NOW_CLEANED_UP = new StringIdImpl(4362, "haContainer ({0}) is now cleaned up.");
  public static final StringId CacheClientNotifier_HACONTAINER_0_HAS_BEEN_CREATED = new StringIdImpl(4363, "haContainer ({0}) has been created.");
  public static final StringId CacheCreation_0_IS_NOT_BEING_STARTED_SINCE_IT_IS_CONFIGURED_FOR_MANUAL_START = new StringIdImpl(4364, "{0} is not being started since it is configured for manual start");
  public static final StringId GemFireClientAdminTool_0_STOPPING = new StringIdImpl(4365, "{0}: Stopping");
  public static final StringId CqService_ERROR_PROCESSING_CQLISTENER_FOR_CQ_0 = new StringIdImpl(4366, "Error processing CqListener for cq: {0}");
  public static final StringId CqService_VIRTUALMACHINEERROR_PROCESSING_CQLISTENER_FOR_CQ_0 = new StringIdImpl(4367, "VirtualMachineError processing CqListener for cq: {0}");
  public static final StringId RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR = new StringIdImpl(4368, "The Object is not of type NotEqualConditionEvaluator");
  public static final StringId CqQueryImpl_FAILED_TO_EXECUTE_THE_CQ_ACTIVE_CONNECTION_TO_PRIMARY_OR_REDUNDANT_SERVER_NOT_FOUND_CQNAME_0_QUERY_STRING_IS_1 = new StringIdImpl(4369, "Failed to execute the CQ.  Active connection to primary or redundant server not found. CqName: {0}, Query String is: {1}");
  public static final StringId CqQueryImpl_GOT_SECURITY_EXCEPTION_WHILE_EXECUTING_CQ_ON_SERVER = new StringIdImpl(4370, "Got security exception while executing cq on server");
  public static final StringId Instantiator_INSTANTIATOR_ID_CANNOT_BE_ZERO = new StringIdImpl(4371, "Instantiator id cannot be zero");
  public static final StringId InternalDataSerializer_THE_DATASERIALIZER_0_HAS_NO_SUPPORTED_CLASSES_ITS_GETSUPPORTEDCLASSES_METHOD_MUST_RETURN_AT_LEAST_ONE_CLASS = new StringIdImpl(4372, "The DataSerializer {0} has no supported classes. It''s getSupportedClasses method must return at least one class");
  public static final StringId InternalDataSerializer_THE_DATASERIALIZER_GETSUPPORTEDCLASSES_METHOD_FOR_0_RETURNED_AN_ARRAY_THAT_CONTAINED_A_NULL_ELEMENT = new StringIdImpl(4373, "The DataSerializer getSupportedClasses method for {0} returned an array that contained a null element.");
  public static final StringId InternalDataSerializer_THE_DATASERIALIZER_GETSUPPORTEDCLASSES_METHOD_FOR_0_RETURNED_AN_ARRAY_THAT_CONTAINED_AN_ARRAY_CLASS_WHICH_IS_NOT_ALLOWED_SINCE_ARRAYS_HAVE_BUILTIN_SUPPORT = new StringIdImpl(4374, "The DataSerializer getSupportedClasses method for {0} returned an array that contained an array class which is not allowed since arrays have built-in support.");
  public static final StringId InternalDataSerializer_ATTEMPTED_TO_SERIALIZE_ILLEGAL_DSFID = new StringIdImpl(4375, "attempted to serialize ILLEGAL dsfid");
  public static final StringId InternalDataSerializer_UNKNOWN_PRIMITIVE_TYPE_0 = new StringIdImpl(4376, "unknown primitive type: {0}");
  public static final StringId InternalDataSerializer_UNEXPECTED_TYPECODE_0 = new StringIdImpl(4377, "unexpected typeCode: {0}");
  public static final StringId RegisterInterest_INTEREST_REGISTRATION_IS_SUPPORTED_ONLY_FOR_SERVERS_WITH_NOTIFYBYSUBSCRIPTION_SET_TO_TRUE = new StringIdImpl(4378, "Interest registration is supported only for servers with notifyBySubscription set to true");
  public static final StringId CacheXmlParser_A_0_IS_NOT_AN_INSTANCE_OF_CUSTOMEXPIRY = new StringIdImpl(4379, "A {0} is not an instance of CustomExpiry");
  public static final StringId RegionAttributesCreation_CUSTOMENTRYIDLETIMEOUT_IS_NOT_THE_SAME = new StringIdImpl(4380, "CustomEntryIdleTimeout is not the same");
  public static final StringId RegionAttributesCreation_CUSTOMENTRYTIMETOLIVE_IS_NOT_THE_SAME = new StringIdImpl(4381, "CustomEntryTimeToLive is not the same");
  public static final StringId AbstractRegion_CANNOT_SET_CUSTOM_TIME_TO_LIVE_WHEN_STATISTICS_ARE_DISABLED = new StringIdImpl(4382, "Cannot set custom time to live when statistics are disabled");
  public static final StringId PutMessage_UNKNOWN_DESERIALIZATION_POLICY = new StringIdImpl(4383, "unknown deserialization policy");
  public static final StringId CacheServerImpl__0_INVALID_EVICTION_POLICY = new StringIdImpl(4384, "{0} Invalid eviction policy");
  public static final StringId MergeLogFiles_IF_A_DIRECTORY_IS_SPECIFIED_ALL_LOG_FILES_IN_THAT_DIRECTORY_ARE_MERGED = new StringIdImpl(4385, "If a directory is specified, all .log files in that directory are merged.");
  public static final StringId MergeLogFiles_FILE_0_IS_NEITHER_A_FILE_NOR_A_DIRECTORY = new StringIdImpl(4386, "File ''{0}'' is neither a file nor a directory.");
  public static final StringId AvailablePort_NETWORK_IS_UNREACHABLE = new StringIdImpl(4387, "Network is unreachable");
  public static final StringId InetAddressUtil_UNABLE_TO_QUERY_NETWORK_INTERFACE = new StringIdImpl(4388, "Unable to query network interface");
  public static final StringId DistributionLocator_A_ZEROLENGTH_GEMFIREPROPERTIESFILE_WILL_MEAN_USE_THE_DEFAULT_SEARCH_PATH = new StringIdImpl(4389, "A zero-length gemfire-properties-file will mean use the default search path");
  public static final StringId DistributionLocator_PEERLOCATOR_AND_SERVERLOCATOR_BOTH_DEFAULT_TO_TRUE = new StringIdImpl(4390, "peerLocator and serverLocator both default to true");
  public static final StringId DistributionLocator_A_ZEROLENGTH_HOSTNAMEFORCLIENTS_WILL_DEFAULT_TO_BINDADDRESS = new StringIdImpl(4391, "A zero-length hostname-for-clients will default to bind-address");
  public static final StringId PartitionedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_THE_PARTITIONED_REGION_LOCK_HELD_BY_1 = new StringIdImpl(4392, "{0} seconds have elapsed waiting for the partitioned region lock held by {1}");
  public static final StringId PartitionedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_GLOBAL_REGION_ENTRY_LOCK_HELD_BY_1 = new StringIdImpl(4393, "{0} seconds have elapsed waiting for global region entry lock held by {1}");
  public static final StringId InternalLocator_EXPECTED_ONE_OF_THESE_0_BUT_RECEIVED_1 = new StringIdImpl(4394, "Expected one of these: {0} but received {1}");
  public static final StringId InternalLocator_STARTING_0 = new StringIdImpl(4395, "Starting {0}");
  public static final StringId Oplog_INTERRUPTEDEXCEPTION_OCCURED_WHILE_WAITING_ON_PENDINGFLUSHMAP_WITH_CANCELLATION_IN_PROGRESS_IT_WILL_TERMINATE = new StringIdImpl(4396, "InterruptedException occurred while waiting on pendingFlushMap with cancellation in progress. It will terminate");
  public static final StringId Oplog_ASYNCHWRITER_INTERRUPTEDEXCEPTION_OCCURED_WHILE_WAITING_ON_PENDINGFLUSHMAP_WITH_NO_CANCELLATION_GOING_ON_IT_WILL_TERMINATE = new StringIdImpl(4397, "AsynchWriter:InterruptedException occurred while waiting on pendingFlushMap with NO cancellation going on. It will terminate");
  public static final StringId LocalRegion_RECURSIVEDESTROYREGION_RECURSION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0 = new StringIdImpl(4398, "recursiveDestroyRegion: recursion failed due to cache closure. region = {0}");
  public static final StringId LocalRegion_BASICDESTROYREGION_PARENT_REMOVAL_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0 = new StringIdImpl(4399, "basicDestroyRegion: parent removal failed due to cache closure. region = {0}");
  public static final StringId LocalRegion_BASICDESTROYREGION_INDEX_REMOVAL_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0 = new StringIdImpl(4400, "basicDestroyRegion: index removal failed due to cache closure. region = {0}");
  public static final StringId LocalRegion_RECURSIVEDESTROYREGION_POSTDESTROYREGION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0 = new StringIdImpl(4401, "recursiveDestroyRegion: postDestroyRegion failed due to cache closure. region = {0}");
  public static final StringId LocalRegion_RECURSIVEDESTROYREGION_PROBLEM_IN_CACHEWRITEBEFOREREGIONDESTROY = new StringIdImpl(4402, "recursiveDestroyRegion: problem in cacheWriteBeforeRegionDestroy");
  public static final StringId LocalRegion_A_DISKACCESSEXCEPTION_HAS_OCCURED_WHILE_WRITING_TO_THE_DISK_FOR_REGION_0_THE_REGION_WILL_BE_CLOSED = new StringIdImpl(4403, "A DiskAccessException has occurred while writing to the disk for region {0}. The region will be closed.");
  public static final StringId LocalRegion_REGION_CLOSED_SUCCESSFULLY = new StringIdImpl(4404, "Region closed successfully.");
  public static final StringId LocalRegion_AN_EXCEPTION_OCCURED_WHILE_DESTROYING_THE_REGION_LOCALLY = new StringIdImpl(4405, "An Exception occurred while destroying the region locally.");
  public static final StringId PRHARedundancyProvider_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_PARTITIONED_REGION_LOCK_HELD_BY_1 = new StringIdImpl(4409, "{0} seconds have elapsed waiting for partitioned region lock held by {1}");
  public static final StringId PoolImpl_DESTROYING_CONNECTION_POOL_0 = new StringIdImpl(4410, "Destroying connection pool {0}");
  public static final StringId PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE = new StringIdImpl(4411, "Timeout waiting for background tasks to complete.");
  public static final StringId PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_BACKGROUNDPROCESSOR = new StringIdImpl(4412, "Error encountered while stopping backgroundProcessor.");
  public static final StringId PoolImpl_INTERRUPTED_WHILE_STOPPING_BACKGROUNDPROCESSOR = new StringIdImpl(4413, "Interrupted while stopping backgroundProcessor");
  public static final StringId PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_SOURCE = new StringIdImpl(4414, "Error encountered while stopping connection source.");
  public static final StringId PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_CONNECTION_MANAGER = new StringIdImpl(4415, "Error encountered while stopping connection manager.");
  public static final StringId PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_SUBSCRIPTION_MANAGER = new StringIdImpl(4416, "Error encountered while stopping subscription manager");
  public static final StringId PoolImpl_ERROR_ENCOUNTERED_WHILE_STOPPING_ENDPOINT_MANAGER = new StringIdImpl(4417, "Error encountered while stopping endpoint manager");
  public static final StringId PoolImpl_ERROR_WHILE_CLOSING_STATISTICS = new StringIdImpl(4418, "Error while closing statistics");
  public static final StringId PoolImpl_UNEXPECTED_ERROR_IN_POOL_TASK_0 = new StringIdImpl(4419, "Unexpected error in pool task <{0}>");
  public static final StringId PoolImpl_DISTRIBUTED_SYSTEM_MUST_BE_CREATED_BEFORE_CREATING_POOL = new StringIdImpl(4420, "Distributed System must be created before creating pool");
  public static final StringId PoolImpl_POOL_COULD_NOT_BE_DESTROYED_BECAUSE_IT_IS_STILL_IN_USE_BY_0_REGIONS = new StringIdImpl(4421, "Pool could not be destroyed because it is still in use by {0} regions");
  public static final StringId PoolImpl__0_IS_NOT_THE_SAME_AS_1_BECAUSE_IT_SHOULD_HAVE_BEEN_A_POOLIMPL = new StringIdImpl(4422, "{0} is not the same as {1} because it should have been a PoolImpl");
  public static final StringId PoolImpl_0_ARE_DIFFERENT = new StringIdImpl(4423, "Pool {0} are different");
  public static final StringId PoolImpl_0_IS_DIFFERENT = new StringIdImpl(4424, "Pool {0} is different");
  public static final StringId TXCommitMessage_TRANSACTION_MESSAGE_0_FROM_SENDER_1_FAILED_PROCESSING_UNKNOWN_TRANSACTION_STATE_2 = new StringIdImpl(4425, "Transaction message {0} from sender {1} failed processing, unknown transaction state: {2}");
  public static final StringId StatAlertsManager_EVALUATEALERTDEFNSTASK_FAILED_WITH_AN_EXCEPTION = new StringIdImpl(4426, "EvaluateAlertDefnsTask failed with an exception. ");
  public static final StringId ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_0 = new StringIdImpl(4427, "Error closing connection {0}");
  public static final StringId ConnectionManagerImpl_ERROR_STOPPING_LOADCONDITIONINGPROCESSOR = new StringIdImpl(4428, "Error stopping loadConditioningProcessor");
  public static final StringId ConnectionManagerImpl_INTERRUPTED_STOPPING_LOADCONDITIONINGPROCESSOR = new StringIdImpl(4429, "Interrupted stopping loadConditioningProcessor");
  public static final StringId ConnectionManagerImpl_ERROR_PREFILLING_CONNECTIONS = new StringIdImpl(4430, "Error prefilling connections");
  public static final StringId ConnectionManagerImpl_TIMEOUT_WAITING_FOR_LOAD_CONDITIONING_TASKS_TO_COMPLETE = new StringIdImpl(4431, "Timeout waiting for load conditioning tasks to complete");
  public static final StringId ConnectionManagerImpl_UNABLE_TO_PREFILL_POOL_TO_MINIMUM_BECAUSE_0 = new StringIdImpl(4432, "Unable to prefill pool to minimum because: {0}");
  public static final StringId ConnectionManagerImpl_LOADCONDITIONINGTASK_0_ENCOUNTERED_EXCEPTION = new StringIdImpl(4433, "LoadConditioningTask <{0}> encountered exception");
  public static final StringId ConnectionManagerImpl_IDLEEXPIRECONNECTIONSTASK_0_ENCOUNTERED_EXCEPTION = new StringIdImpl(4434, "IdleExpireConnectionsTask <{0}> encountered exception");
  public static final StringId ConnectionManagerImpl_SECURITY_EXCEPTION_CONNECTING_TO_SERVER_0_1 = new StringIdImpl(4435, "Security exception connecting to server ''{0}'': {1}");
  public static final StringId ConnectionManagerImpl_SERVER_0_REFUSED_NEW_CONNECTION_1 = new StringIdImpl(4436, "Server ''{0}'' refused new connection: {1}");
  public static final StringId ConnectionManagerImpl_ERROR_CLOSING_CONNECTION_TO_SERVER_0 = new StringIdImpl(4437, "Error closing connection to server {0}");
  public static final StringId ConnectionManagerImpl_ERROR_EXPIRING_CONNECTION_0 = new StringIdImpl(4438, "Error expiring connection {0}");
  public static final StringId ServerHandShakeProcessor_0_SERVERS_CURRENT_VERSION_IS_1 = new StringIdImpl(4439, "{0} Server''s current version is {1}.");
  public static final StringId ServerHandShakeProcessor_0_UNEXPECTED_CERTIFICATE_TYPE_1_FOR_PROXYID_2 = new StringIdImpl(4440, "{0}: unexpected certificate type [{1}] for proxyID: {2}");
  public static final StringId ServerHandShakeProcessor_SSL_EXCEPTION_SHOULD_NOT_HAVE_HAPPENED = new StringIdImpl(4441, "SSL exception should not have happened.");
  public static final StringId ServerHandShakeProcessor_0_AUTHORIZATION_ENABLED_BUT_AUTHENTICATION_CALLBACK_1_RETURNED_WITH_NULL_CREDENTIALS_FOR_PROXYID_2 = new StringIdImpl(4442, "{0}: Authorization enabled but authentication callback ({1})  returned with null credentials for proxyID: {2}");
  public static final StringId ServerHandShakeProcessor_0_POSTPROCESS_AUTHORIZATION_ENABLED_BUT_NO_AUTHENTICATION_CALLBACK_2_IS_CONFIGURED = new StringIdImpl(4443, "{0}: Post-process authorization enabled, but no authentication callback ({2}) is configured");
  public static final StringId ServerHandShakeProcessor_0_HANDSHAKE_REPLY_CODE_TIMEOUT_NOT_RECEIVED_WITH_IN_1_MS = new StringIdImpl(4444, "{0}: Handshake reply code timeout, not received with in {1} ms");
  public static final StringId ServerHandShakeProcessor_0_RECEIVED_NO_HANDSHAKE_REPLY_CODE = new StringIdImpl(4445, "{0}: Received no handshake reply code");
  public static final StringId ServerHandShakeProcessor_HANDSHAKEREADER_EOF_REACHED_BEFORE_CLIENT_VERSION_COULD_BE_READ = new StringIdImpl(4446, "HandShakeReader: EOF reached before client version could be read");
  public static final StringId QueueManagerImpl_TIMEOUT_WAITING_FOR_RECOVERY_THREAD_TO_COMPLETE = new StringIdImpl(4447, "Timeout waiting for recovery thread to complete");
  public static final StringId QueueManagerImpl_ERROR_CLOSING_PRIMARY_CONNECTION_TO_0 = new StringIdImpl(4448, "Error closing primary connection to {0}");
  public static final StringId QueueManagerImpl_ERROR_CLOSING_BACKUP_CONNECTION_TO_0 = new StringIdImpl(4449, "Error closing backup connection to {0}");
  public static final StringId QueueManagerImpl_SENDING_READY_FOR_EVENTS_TO_PRIMARY_0 = new StringIdImpl(4450, "Sending ready for events to primary: {0}");
  public static final StringId QueueManagerImpl_COULD_NOT_CREATE_A_QUEUE_NO_QUEUE_SERVERS_AVAILABLE = new StringIdImpl(4451, "Could not create a queue. No queue servers available.");
  public static final StringId QueueManagerImpl_COULD_NOT_INITIALIZE_A_PRIMARY_QUEUE_ON_STARTUP_NO_QUEUE_SERVERS_AVAILABLE = new StringIdImpl(4452, "Could not initialize a primary queue on startup. No queue servers available.");
  public static final StringId QueueManagerImpl_UNABLE_TO_INITIALIZE_ENOUGH_REDUNDANT_QUEUES_ON_STARTUP_THE_REDUNDANCY_COUNT_IS_CURRENTLY_0 = new StringIdImpl(4453, "Unable to initialize enough redundant queues on startup. The redundancy count is currently {0}.");
  public static final StringId QueueManagerImpl_UNABLE_TO_CREATE_A_SUBSCRIPTION_CONNECTION_TO_SERVER_0 = new StringIdImpl(4454, "unable to create a subscription connection to server {0}");
  public static final StringId QueueManagerImpl_REDUNDANCY_LEVEL_0_IS_NOT_SATISFIED_BUT_THERE_ARE_NO_MORE_SERVERS_AVAILABLE_REDUNDANCY_IS_CURRENTLY_1 = new StringIdImpl(4455, "Redundancy level {0} is not satisfied, but there are no more servers available. Redundancy is currently {1}.");
  public static final StringId QueueManagerImpl_QUEUEMANAGERIMPL_FAILED_TO_RECOVER_INTEREST_TO_SERVER_0 = new StringIdImpl(4456, "QueueManagerImpl failed to recover interest to server {0}.");
  public static final StringId QueueManagerImpl_ERROR_IN_REDUNDANCY_SATISFIER = new StringIdImpl(4457, "Error in redundancy satisfier");
  public static final StringId JGroupMembershipManager_MEMBERSHIP_EXPIRING_MEMBERSHIP_OF_SURPRISE_MEMBER_0 = new StringIdImpl(4458, "Membership: expiring membership of surprise member <{0}>");
  public static final StringId GemFireCacheImpl_STARTING_GEMFIRE_REDIS_SERVER_ON_PORT_0 = new StringIdImpl(4459, "Starting GemFireRedisServer on port {0}");
  public static final StringId JGroupMembershipManager_EXCEPTION_DESERIALIZING_MESSAGE_PAYLOAD_0 = new StringIdImpl(4460, "Exception deserializing message payload: {0}");
  public static final StringId JGroupMembershipManager_MEMBERSHIP_SERVICE_FAILURE_0 = new StringIdImpl(4461, "Membership service failure: {0}");
  public static final StringId JGroupMembershipManager_EXCEPTION_CAUGHT_WHILE_SHUTTING_DOWN = new StringIdImpl(4462, "Exception caught while shutting down");
  public static final StringId JGroupMembershipManager_MEMBERSHIP_REQUEST_INITIATED_TO_REMOVE_MEMBER_0_BUT_THERE_IS_NO_GROUP_COORDINATOR = new StringIdImpl(4463, "Membership: request initiated to remove member {0}, but there is no group coordinator");
  public static final StringId JGroupMembershipManager_MEMBERSHIP_REQUESTING_REMOVAL_OF_0_REASON_1 = new StringIdImpl(4464, "Membership: requesting removal of {0}. Reason={1}");
  public static final StringId DLockGrantor_INITIALIZATION_OF_HELD_LOCKS_IS_SKIPPING_0_BECAUSE_LOCK_IS_ALREADY_HELD_1 = new StringIdImpl(4465, "Initialization of held locks is skipping {0} because lock is already held: {1}");
  public static final StringId DLockGrantor_IGNORING_LOCK_REQUEST_FROM_NONMEMBER_0 = new StringIdImpl(4466, "Ignoring lock request from non-member: {0}");
  public static final StringId Oplog_ASYNCH_WRITER_EXPERIENCED_VM_ERROR_SYSTEM_UNSTABLE_WILL_TERMINATE = new StringIdImpl(4467, "Asynch Writer experienced VM Error. System unstable. Will terminate.");
  public static final StringId Oplog_ASYNCH_WRITER_THREAD_FOR_OPLOG_0_ENCOUNTERED_EXCEPTION = new StringIdImpl(4468, "Asynch Writer thread for Oplog {0} encountered Exception.");
  public static final StringId Oplog_ASYNCHWRITER_INTERRUPTEDEXCEPTION_OCCURED_WHILE_WAITING_ON_PENDINGFLUSHMAP_WITH_CANCELLATION_IN_PROGRESS_IT_WILL_TERMINATE = new StringIdImpl(4469, "AsynchWriter:InterruptedException occurred while waiting on pendingFlushMap with cancellation in progress. It will terminate.");
  public static final StringId HARegionQueue_DURABLE_CLIENT_QUEUE_INITIALIZATION_TOOK_0_MS = new StringIdImpl(4470, "Durable client queue initialization took {0} ms.");
  public static final StringId HARegionQueue_0_UNABLE_TO_INITIALIZE_AVAILABLE_IDS = new StringIdImpl(4471, "{0}: unable to initialize available ids.");
  public static final StringId ClientStatsManager_FAILED_TO_PUBLISH_CLIENT_STATISTICS = new StringIdImpl(4472, "Failed to publish client statistics");
  public static final StringId ClientStatsManager_FAILED_TO_SEND_CLIENT_HEALTH_STATS_TO_CACHESERVER = new StringIdImpl(4473, "Failed to send client health stats to cacheserver.");
  public static final StringId ClientStatsManager_CLIENTSTATSMANAGER_INTIALIZING_THE_STATISTICS = new StringIdImpl(4474, "ClientStatsManager, intializing the statistics...");
  public static final StringId ClientStatsManager_CLIENTSTATSMANAGER_0_ARE_NOT_AVAILABLE = new StringIdImpl(4475, "ClientStatsManager, {0} are not available.");
  public static final StringId AutoConnectionSourceImpl_AUTOCONNECTIONSOURCE_DISCOVERED_NEW_LOCATORS_0 = new StringIdImpl(4476, "AutoConnectionSource discovered new locators {0}");
  public static final StringId AutoConnectionSourceImpl_AUTOCONNECTIONSOURCE_DROPPING_PREVIOUSLY_DISCOVERED_LOCATORS_0 = new StringIdImpl(4477, "AutoConnectionSource dropping previously discovered locators {0}");
  public static final StringId AutoConnectionSourceImpl_RECEIVED_EXCEPTION_FROM_LOCATOR_0 = new StringIdImpl(4478, "Received exception from locator {0}");
  public static final StringId AutoConnectionSourceImpl_COMMUNICATION_HAS_BEEN_RESTORED_WITH_LOCATOR_0 = new StringIdImpl(4479, "Communication has been restored with locator {0}.");
  public static final StringId AutoConnectionSourceImpl_COMMUNICATION_WITH_LOCATOR_0_FAILED_WITH_1 = new StringIdImpl(4480, "Communication with locator {0} failed with {1}.");
  public static final StringId AutoConnectionSourceImpl_LOCATOR_0_IS_NOT_RUNNING = new StringIdImpl(4481, "locator {0} is not running.");
  public static final StringId AutoConnectionSourceImpl_0_NOT_STARTED_1 = new StringIdImpl(4482, "{0}: Not Started {1}");
  public static final StringId AutoConnectionSourceImpl_0_STARTED_1 = new StringIdImpl(4483, "{0}: Started {1}");
  public static final StringId AutoConnectionSourceImpl_COULD_NOT_CREATE_A_NEW_CONNECTION_TO_SERVER_0 = new StringIdImpl(4484, "Could not create a new connection to server: {0}");
  public static final StringId DistributionAdvisor_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_CURRENT_OPERATIONS_TO_DISTRIBUTE = new StringIdImpl(4485, "{0} seconds have elapsed while waiting for current operations to distribute");
  public static final StringId DistributionManager_I_0_AM_THE_ELDER = new StringIdImpl(4486, "I, {0}, am the elder.");
  public static final StringId DistributionManager_UNKNOWN_TYPE_OF_MEMBERSHIP_EVENT_RECEIVED_0 = new StringIdImpl(4487, "Unknown type of membership event received: {0}");
  public static final StringId InternalLocator_STARTING_PEER_LOCATION_FOR_0 = new StringIdImpl(4488, "Starting peer location for {0}");
  public static final StringId InternalLocator_EITHER_PEER_LOCATOR_OR_SERVER_LOCATOR_MUST_BE_ENABLED = new StringIdImpl(4489, "Either peer locator or server locator must be enabled");
  public static final StringId InternalLocator_PEER_LOCATION_IS_ALREADY_RUNNING_FOR_0 = new StringIdImpl(4490, "Peer location is already running for {0}");
  public static final StringId InternalLocator_SERVER_LOCATION_IS_ALREADY_RUNNING_FOR_0 = new StringIdImpl(4491, "Server location is already running for {0}");
  public static final StringId InternalLocator_STARTING_SERVER_LOCATION_FOR_0 = new StringIdImpl(4492, "Starting server location for {0}");
  public static final StringId InternalLocator_SINCE_SERVER_LOCATION_IS_ENABLED_THE_DISTRIBUTED_SYSTEM_MUST_BE_CONNECTED = new StringIdImpl(4493, "Since server location is enabled the distributed system must be connected.");
  public static final StringId AbstractRegionEntry_CALLBACKEVENT_WAS_NULL_WHILE_WAITING_TO_DISPATCH_EVENT_0 = new StringIdImpl(4494, "callbackEvent was null while waiting to dispatch event {0}");
  public static final StringId CacheClientUpdater_0_IS_WAITING_FOR_1_TO_COMPLETE = new StringIdImpl(4495, "{0} is waiting for {1} to complete");
  public static final StringId CacheClientUpdater_0_HAS_COMPLETED_WAITING_FOR_1 = new StringIdImpl(4496, "{0} has completed waiting for {1}");
  public static final StringId Connection_CONNECTION_TO_0_IS_INTERRUPTING_BLOCKED_THREAD_1 = new StringIdImpl(4497, "Connection to {0} is interrupting blocked thread {1}");
  public static final StringId Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_TO_0_IN_OVER_1_SECONDS = new StringIdImpl(4498, "Unable to form a TCP/IP connection to {0} in over {1} seconds");
  public static final StringId Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_IN_A_REASONABLE_AMOUNT_OF_TIME = new StringIdImpl(4499, "Unable to form a TCP/IP connection in a reasonable amount of time");
  public static final StringId DLOCKRECOVERGRANTORPROCESSOR_DLOCKRECOVERGRANTORMESSAGE_PROCESS_THROWABLE = new StringIdImpl(4500, "[DLockRecoverGrantorMessage.process] throwable: ");
  public static final StringId StartupMessage_UNABLE_TO_EXAMINE_NETWORK_INTERFACES = new StringIdImpl(4501, "Unable to examine network interfaces");
  public static final StringId StartupMessage_REJECTED_NEW_SYSTEM_NODE_0_BECAUSE_PEER_HAS_NO_NETWORK_INTERFACES = new StringIdImpl(4502, "Rejected new system node {0} because peer has no network interfaces");
  public static final StringId DisKRegion_OUTSTANDING_OPS_REMAIN_AFTER_0_SECONDS_FOR_DISK_REGION_1 = new StringIdImpl(4503, "Outstanding ops remain after {0} seconds for disk region {1}");
  public static final StringId DisKRegion_OUTSTANDING_OPS_CLEARED_FOR_DISK_REGION_0 = new StringIdImpl(4504, "Outstanding ops cleared for disk region {0}");
  public static final StringId CacheClientProxy_0_SLEEP_INTERRUPTED = new StringIdImpl(4505, "{0}: sleep interrupted.");
  public static final StringId Connection_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_A_RESPONSE_FROM_1_FOR_THREAD_2 = new StringIdImpl(4506, "{0} seconds have elapsed waiting for a response from {1} for thread {2}");
  public static final StringId Connection_TRANSMIT_ACKWAITTHRESHOLD = new StringIdImpl(4507, "Sender has been unable to transmit a message within ack-wait-threshold seconds");
  public static final StringId Connection_RECEIVE_ACKWAITTHRESHOLD = new StringIdImpl(4508, "Sender has been unable to receive a response to a message within ack-wait-threshold seconds");
  public static final StringId Connection_MESSAGE_DESERIALIZATION_OF_0_DID_NOT_READ_1_BYTES = new StringIdImpl(4509, "Message deserialization of {0} did not read {1} bytes.");
  public static final StringId Connection_UNCAUGHT_EXCEPTION_FROM_LISTENER = new StringIdImpl(4510, "Uncaught exception from listener");
  public static final StringId DistributedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_GLOBAL_REGION_ENTRY_LOCK_HELD_BY_1 = new StringIdImpl(4511, "{0} seconds have elapsed waiting for global region entry lock held by {1}");
  public static final StringId DistributedRegion_REGION_0_1_SPLITBRAIN_CONFIG_WARNING = new StringIdImpl(4512, "Region {0} is being created with scope {1} but enable-network-partition-detection is enabled in the distributed system.  This can lead to cache inconsistencies if there is a network failure.");
  public static final StringId GemFireCache_0_ERROR_IN_LAST_STAGE_OF_PARTITIONEDREGION_CACHE_CLOSE = new StringIdImpl(4513, "{0}: error in last stage of PartitionedRegion cache close");
  public static final StringId GemFireCache_0_ERROR_CLOSING_REGION_1 = new StringIdImpl(4514, "{0}: error closing region {1}");
  public static final StringId AbstractRegionEntry_RUNTIME_EXCEPTION_CAUSED_BUG_39130_PLEASE_NOTIFY_GEMSTONE_TECHNICAL_SUPPORT = new StringIdImpl(4515, "Runtime exception caused bug 39130, please notify GemStone technical support");
  public static final StringId TCPConduit_PROBLEM_CONNECTING_TO_0 = new StringIdImpl(4516, "Problem connecting to {0}");
  public static final StringId TCPConduit_THROWING_IOEXCEPTION_AFTER_FINDING_BREAKLOOP_TRUE = new StringIdImpl(4517, "Throwing IOException after finding breakLoop=true");
  public static final StringId InstantiatorRecoveryListener_INSTANTIATORRECOVERYTASK_ERROR_RECOVERING_INSTANTIATORS = new StringIdImpl(4518, "InstantiatorRecoveryTask - Error recovering instantiators: ");
  public static final StringId Generic_0_UNEXPECTED_EXCEPTION = new StringIdImpl(4519, "{0}: Unexpected Exception");
  public static final StringId PutAll_THE_INPUT_REGION_NAME_FOR_THE_PUTALL_REQUEST_IS_NULL = new StringIdImpl(4520, " The input region name for the putAll request is null");
  public static final StringId PutAll_ONE_OF_THE_INPUT_KEYS_FOR_THE_PUTALL_REQUEST_IS_NULL = new StringIdImpl(4521, " One of the input keys for the putAll request is null");
  public static final StringId PutAll_ONE_OF_THE_INPUT_VALUES_FOR_THE_PUTALL_REQUEST_IS_NULL = new StringIdImpl(4522, " One of the input values for the putAll request is null");
  public static final StringId Oplog_THE_MAIN_THREAD_COULD_NOT_JOIN_WITH_THE_ASYNCH_FLUSH_THREAD = new StringIdImpl(4523, "The main thread could not join with the asynch flush thread");
  public static final StringId Oplog_OPLOG_SHUTDOWN_INTERRUPTED_ACQUIRING_READ_LOCK = new StringIdImpl(4524, "Oplog#shutdown: interrupted acquiring read lock.");
  public static final StringId InternalDistributedSystem_UNABLE_TO_START_THE_MONITOR_SERVICE = new StringIdImpl(4525, "Unable to start the monitor service");
  public static final StringId AbstractDistributionConfig_REDIS_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1 = new StringIdImpl(4526, "The redis-bind-address \"{0}\" is not a valid address for this machine.  These are the valid addresses for this machine: {1}");
  public static final StringId CacheServerImpl_CACHESERVER_ERROR_CLOSING_LOAD_MONITOR = new StringIdImpl(4527, "CacheServer - Error closing load monitor");
  public static final StringId CacheServerImpl_CACHESERVER_ERROR_CLOSING_ADVISOR = new StringIdImpl(4528, "CacheServer - Error closing advisor");
  public static final StringId CacheServerImpl_CACHESERVER_ERROR_CLOSING_ACCEPTOR_MONITOR = new StringIdImpl(4529, "CacheServer - Error closing acceptor monitor");
  public static final StringId DiskRegion_COMPLEXDISKREGION_CLOSE_EXCEPTION_IN_STOPPING_COMPACTOR = new StringIdImpl(4530, "DiskRegion::close: Exception in stopping compactor");
  public static final StringId CacheClientNotifier_CACHECLIENTNOTIFIER_CAUGHT_EXCEPTION_ATTEMPTING_TO_CLIENT = new StringIdImpl(4531, "CacheClientNotifier: Caught exception attempting to client: ");
  public static final StringId CqQueryImpl_EXCEPTION_WHILE_EXECUTING_CQ_EXCEPTION_0 = new StringIdImpl(4532, "Exception while executing cq Exception: {0}");
  public static final StringId CqQueryImpl_FAILED_TO_EXECUTE_THE_CQ_CQNAME_0_QUERY_STRING_IS_1_ERROR_FROM_LAST_SERVER_2 = new StringIdImpl(4533, "Failed to execute the CQ. CqName: {0}, Query String is: {1}, Error from last server: {2}");
  public static final StringId RegisterInterestTracker_REMOVESINGLEINTEREST_KEY_0_NOT_REGISTERED_IN_THE_CLIENT = new StringIdImpl(4534, "removeSingleInterest: key {0} not registered in the client");
  public static final StringId RegisterInterestTracker_PROBLEM_REMOVING_ALL_INTEREST_ON_REGION_0_INTERESTTYPE_1_2 = new StringIdImpl(4535, "Problem removing all interest on region={0} interestType={1} :{2}");
  public static final StringId RegisterInterestTracker_REMOVEINTERESTLIST_KEY_0_NOT_REGISTERED_IN_THE_CLIENT = new StringIdImpl(4536, "removeInterestList: key {0} not registered in the client");
  public static final StringId PoolmanagerImpl_ERROR_REGISTERING_INSTANTIATOR_ON_POOL = new StringIdImpl(4537, "Error registering instantiator on pool: ");
  public static final StringId ServerLocator_SERVERLOCATOR_UNEXPECTED_PROFILE_UPDATE = new StringIdImpl(4538, "ServerLocator - unexpected profile update.");
  public static final StringId LoadMonitor_CACHESERVER_LOAD_MONITOR_ERROR_IN_POLLING_THREAD = new StringIdImpl(4539, "CacheServer Load Monitor Error in polling thread");
  public static final StringId LoadMonitor_INTERRUPTED_WAITING_FOR_POLLING_THREAD_TO_FINISH = new StringIdImpl(4540, "Interrupted waiting for polling thread to finish");
  public static final StringId JGroupMembershipManager_MEMBERSHIP_DISREGARDING_MESSAGES_FROM_SHUNNED_MEMBER_0 = new StringIdImpl(4541, "Membership: disregarding messages from shunned member <{0}>");
  public static final StringId BlobHelper_DESERIALIZATION_OF_A_0_DID_NOT_READ_1_BYTES_THIS_INDICATES_A_LOGIC_ERROR_IN_THE_SERIALIZATION_CODE_FOR_THIS_CLASS = new StringIdImpl(4542, "Deserialization of a {0} did not read {1} bytes. This indicates a logic error in the serialization code for this class.");
  public static final StringId BucketAdvisor_REDUNDANCY_HAS_DROPPED_BELOW_0_CONFIGURED_COPIES_TO_1_ACTUAL_COPIES_FOR_2 = new StringIdImpl(4543, "Redundancy has dropped below {0} configured copies to {1} actual copies for {2}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_PUTALL_OPERATION_ON_REGION_0 = new StringIdImpl(4544, "Not authorized to perform PUTALL operation on region [{0}]");
  public static final StringId LocalRegion_CAUGHT_THE_FOLLOWING_EXCEPTION_FOR_KEY_0_WHILE_PERFORMING_A_REMOTE_GETALL = new StringIdImpl(4545, "Caught the following exception for key {0} while performing a remote getAll");
  public static final StringId GetAll_THE_INPUT_REGION_NAME_FOR_THE_GETALL_REQUEST_IS_NULL = new StringIdImpl(4546, "The input region name for the getAll request is null");
  public static final StringId GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1 = new StringIdImpl(4547, "{0}: Caught the following exception attempting to get value for key={1}");
  public static final StringId AcceptorImpl_COULD_NOT_CHECK_FOR_STUCK_KEYS = new StringIdImpl(4548, "Could not check for stuck keys.");
  public static final StringId AcceptorImpl_STUCK_SELECTION_KEY_DETECTED_ON_0 = new StringIdImpl(4549, "stuck selection key detected on {0}");
  public static final StringId AcceptorImpl_UNEXPECTED_EXCEPTION = new StringIdImpl(4550, "Unexpected Exception:");
  public static final StringId JGroupMembershipManager_MEMBERSHIP_DISREGARDING_SHUNNED_MEMBER_0 = new StringIdImpl(4551, "Membership: disregarding shunned member <{0}>");
  public static final StringId GlobalTransaction_COULD_NOT_COMPARE_0_TO_1 = new StringIdImpl(4552, "Could not compare {0} to {1}");
  public static final StringId DistributedSystem_THIS_VM_ALREADY_HAS_ONE_OR_MORE_DISTRIBUTED_SYSTEM_CONNECTIONS_0 = new StringIdImpl(4553, "This VM already has one or more Distributed System connections {0}");
  public static final StringId DistributedFunctionMessage_UNABLE_TO_DESERIALIZE_RESPONSE = new StringIdImpl(4554, "Unable to deserialize a portion of the data in a distributed function response.");
  public static final StringId Op_UNKNOWN_MESSAGE_TYPE_0 = new StringIdImpl(4555, "Unknown message type {0}");
  public static final StringId AdminDistributedSystem_ENCOUNTERED_AN_IOEXCEPTION_0 = new StringIdImpl(4556, "Encountered an IOException while serializing notifications, objects were not sent to the jmx clients as a result. {0}");
  public static final StringId AdminDistributedSystem_ENCOUNTERED_A_0_WHILE_LOADING_STATALERTDEFINITIONS_1 = new StringIdImpl(4557, "Encountered a {0} while loading StatAlertDefinitions [from {1}]. This could be due to GemFire version mismatch. Loading of statAlertDefinitions has been aborted.");
  public static final StringId AdminDistributedSystem_ENCOUNTERED_A_0_WHILE_SAVING_STATALERTDEFINITIONS_1 = new StringIdImpl(4558, "Encountered a {0} while saving StatAlertDefinitions [from {1}]. This could be due to GemFire version mismatch. Saving of statAlertDefinitions has been aborted.");
  public static final StringId FunctionMessage_UNABLE_TO_DESERIALIZE_RESPONSE = new StringIdImpl(4559, "Unable to deserialize a portion of the data in a function response.");
  public static final StringId ExecuteRegionFunction_THE_REGION_NAMED_0_WAS_NOT_FOUND_DURING_EXECUTE_FUNCTION_REQUEST = new StringIdImpl(4560, "The region named {0} was not found during execute Function request.");
  public static final StringId BucketAdvisor_UNABLE_TO_ACQUIRE_THE_PRIMARY_LOCK_FOR_BUCKET_0 = new StringIdImpl(4561, "Unable to acquire the primary lock for bucket {0}.");
  public static final StringId BucketAdvisor_ACQUIRED_LOCK_FOR_BUCKET_0_OF_PARTITIONEDREGION_1 = new StringIdImpl(4562, "Acquired lock for bucket {0} of PartitionedRegion {1}.");
  public static final StringId BucketAdvisor_COLOCATEDPRIMARY_IS_NULL_0_1_2 = new StringIdImpl(4563, "ColocatedPrimary is NULL, for Bucket {0} of the PartitionedRegion named {1} and the colocated region {2}");
  public static final StringId BucketAdvisor_COULD_NOT_ACQUIRE_THE_PRIMARY_LOCK_FOR_BUCKET_0_OF_THE_PARTITIONEDREGION_NAMED_1 = new StringIdImpl(4564, "Could not acquire the primary lock for Bucket {0} of the PartitionedRegion named {1}");
  public static final StringId ExecuteRegionFunction_CAN_NOT_EXECUTE_ON_NORMAL_REGION = new StringIdImpl(4565, "Function execution on region with DataPolicy.NORMAL is not supported");
  public static final StringId MemberExecutor_SPECIFING_A_FILTER_FOR_DATA_INDEPENDENT_FUNCTIONS_IS_UNSUPPORTED = new StringIdImpl(4566, "Specifing a filter for data independent functions is unsupported");
  public static final StringId ExecuteFunction_THE_INPUT_FUNCTION_FOR_THE_EXECUTE_FUNCTION_REQUEST_IS_NULL = new StringIdImpl(4567, "The input function for the execute function request is null");
  public static final StringId ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED = new StringIdImpl(4568, "Function named {0} is not registered to FunctionService");
  public static final StringId ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0 = new StringIdImpl(4569, "Exception on server while executing function: {0}");
  public static final StringId ExecuteFunction_SERVER_COULD_NOT_SEND_THE_REPLY = new StringIdImpl(4570, "Server could not send the reply");
  public static final StringId ExecuteRegionFunction_EXECUTING_ON_SERVER_FOR_KEY_0 = new StringIdImpl(4571, "Executing on server for Key: {0}");
  public static final StringId ExecuteRegionFunction_BUCKET_FILTER_ON_NON_PR = new StringIdImpl(4572, "Buckets as filter cannot be applied to a non partitioned region: {0}");
  public static final StringId ExecuteRegionFunction_SERVER_COULD_NOT_SEND_THE_REPLY = new StringIdImpl(4573, "Server could not send the reply");
  public static final StringId ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0 = new StringIdImpl(4574, "Exception on server while executing function : {0}");
  public static final StringId ExecuteRegionFunction_THE_INPUT_0_FOR_THE_EXECUTE_FUNCTION_REQUEST_IS_NULL = new StringIdImpl(4575, "The input {0} for the execute function request is null");
  public static final StringId ExecuteRegionFunction_THE_FUNCTION_0_HAS_NOT_BEEN_REGISTERED = new StringIdImpl(4576, "The function, {0}, has not been registered");
  public static final StringId ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT = new StringIdImpl(4577, "The function, {0}, did not send last result");
  public static final StringId CacheClientProxy_REGION_NOTIFICATION_OF_INTEREST_FAILED = new StringIdImpl(4579, "Region notification of interest failed");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_EXECUTE_REGION_FUNCTION_OPERATION = new StringIdImpl(4580, "Not authorized to perform EXECUTE_REGION_FUNCTION operation");
  public static final StringId PartitionedRegionDataStore_AFTER_0_ATTEMPTS_PARTITIONEDREGION_1_MAY_NOT_HAVE_REACHED_CONFIGURED_REDUNDANCY_2 = new StringIdImpl(4581, "After {0} attempts, PartitionedRegion {1} may not have reached configured redundancy: {2}");
  public static final StringId RemoteBridgeServer_INTERESTREGISTRATIONLISTENERS_CANNOT_BE_REGISTERED_ON_A_REMOTE_BRIDGESERVER = new StringIdImpl(4582, "InterestRegistrationListeners cannot be registered on a remote BridgeServer");
  public static final StringId RemoteBridgeServer_INTERESTREGISTRATIONLISTENERS_CANNOT_BE_UNREGISTERED_FROM_A_REMOTE_BRIDGESERVER = new StringIdImpl(4583, "InterestRegistrationListeners cannot be unregistered from a remote BridgeServer");
  public static final StringId RemoteBridgeServer_INTERESTREGISTRATIONLISTENERS_CANNOT_BE_RETRIEVED_FROM_A_REMOTE_BRIDGESERVER = new StringIdImpl(4584, "InterestRegistrationListeners cannot be retrieved from a remote BridgeServer");
  public static final StringId PartitionAttributesImpl_REGION_SPECIFIED_IN_COLOCATEDWITH_IS_NOT_PRESENT_IT_SHOULD_BE_CREATED_BEFORE_SETTING_COLOCATED_WITH_THIS_REGION = new StringIdImpl(4585, "Region specified in ''colocated-with'' is not present. It should be created before setting ''colocated-with'' to this region.");
  public static final StringId PartitionAttributesImpl_SETTING_THE_ATTRIBUTE_COLOCATEDWITH_IS_SUPPORTED_ONLY_FOR_PARTITIONEDREGIONS = new StringIdImpl(4586, "Setting the attribute ''colocated-with'' is supported only for PartitionedRegions");
  public static final StringId PartitionAttributesImpl_CURRENT_PARTITIONEDREGIONS_TOTALNUMBUCKETS_SHOULD_BE_SAME_AS_TOTALNUMBUCKETS_OF_COLOCATED_PARTITIONEDREGION = new StringIdImpl(4587, "Current PartitionedRegion''s TotalNumBuckets should be same as TotalNumBuckets of colocated PartitionedRegion");
  public static final StringId PartitionAttributesImpl_CURRENT_PARTITIONEDREGIONS_REDUNDANCY_SHOULD_BE_SAME_AS_THE_REDUNDANCY_OF_COLOCATED_PARTITIONEDREGION = new StringIdImpl(4588, "Current PartitionedRegion''s redundancy should be same as the redundancy of colocated PartitionedRegion");
  public static final StringId CacheXmlParser_ONLY_A_FUNCTION_IS_ALLOWED_IN_THE_CONTEXT_OF_0 = new StringIdImpl(4589, "Only a Function is allowed in the context of {0}");
  public static final StringId LocalRegion_REGION_INTEREST_REGISTRATION_IS_ONLY_SUPPORTED_FOR_PARTITIONEDREGIONS = new StringIdImpl(4590, "Region interest registration is only supported for PartitionedRegions");
  public static final StringId PartitionRegion_REQUESTED_EVICTIONATTRIBUTES_0_IS_INCOMPATIBLE_WITH_EXISTING_EVICTIONATTRIBUTES_1 = new StringIdImpl(4591, "Requested EvictionAttributes {0} is incompatible with existing EvictionAttributes {1}");
  public static final StringId PartitionRegion_MAX_MEMORY_FOR_EVICTION_ATTRIBUTES_0_MUST_BE_LESS_THAN_THE_TOTAL_MAX_MEMORY_OF_THE_PARTITIONEDREGION_WHICH_IS_1_MB = new StringIdImpl(4592, "Max Memory for Eviction Attributes {0} must be less than the total Max Memory of the PartitionedRegion, which is {1} MB");
  public static final StringId PartitionRegion_MAX_MEMORY_FOR_EVICTION_ATTRIBUTES_0_MUST_BE_MORE_THAN_1_MB = new StringIdImpl(4593, "Max Memory for Eviction Attributes {0} Must be more than {1} MB");
  public static final StringId PartitionRegion_MAX_MEMORY_FOR_EVICTION_ATTRIBUTES_0_MUST_BE_LESS_THAN_1_MB = new StringIdImpl(4594, "Max Memory for Eviction Attributes {0} Must be less than {1} MB.");
  public static final StringId PartitionRegion_MAX_ENTRY_FOR_EVICTION_ATTRIBUTES_0_MUST_BE_MORE_THAN_TOTAL_NO_OF_BUCKETS_1 = new StringIdImpl(4595, "Max Entry for Eviction Attributes {0} Must be more than total no. of buckets, {1}.");
  public static final StringId PartitionRegion_REQUESTED_REDUNDANCY_0_IS_INCOMPATIBLE_WITH_EXISTING_REDUNDANCY_1 = new StringIdImpl(4596, "Requested redundancy {0} is incompatible with existing redundancy {1}");
  public static final StringId PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_LISTENER = new StringIdImpl(4597, "The PartitionListeners={0} are incompatible with the PartitionListeners={1} used by other distributed members.");
  public static final StringId PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_RESOLVER = new StringIdImpl(4598, "The PartitionResolver={0} is incompatible with the PartitionResolver={1} used by other distributed members.");
  public static final StringId PartitionRegionConfigValidator_INCOMPATIBLE_COLOCATED_WITH = new StringIdImpl(4599, "The colocatedWith={0} found in PartitionAttributes is incompatible with the colocatedWith={1} used by other distributed members.");
  public static final StringId PartitionedRegionHelper_THE_ROUTINGOBJECT_RETURNED_BY_PARTITIONRESOLVER_IS_NULL = new StringIdImpl(4600, "The RoutingObject returned by PartitionResolver is null.");
  public static final StringId StartupResponseMessage_COULD_NOT_LOAD_SERIALIZER_CLASS_0 = new StringIdImpl(4601, "Could not load serializer class: {0}");
  public static final StringId AgentConfigImpl_IDENTIFY_IF_EMAIL_NOTIFICATIONS_ARE_ENABLED_OR_NOT = new StringIdImpl(4602, "Whether the e-mail notifications are enabled.");
  public static final StringId AgentConfigImpl_IDENTIFY_THE_EMAIL_ADDRESS_USING_WHICH_EMAIL_NOTIFICATIONS_ARE_SENT = new StringIdImpl(4603, "E-mail address to be used to send e-mail notifications.");
  public static final StringId AgentConfigImpl_IDENTIFY_THE_EMAIL_SERVER_HOST_USING_WHICH_EMAIL_NOTIFICATIONS_ARE_SENT = new StringIdImpl(4604, "The host name of the e-mail server to be used for sending email notification.");
  public static final StringId AgentConfigImpl_IDENTIFY_THE_COMMA_SEPARATED_EMAIL_ADDRESSES_LIST_TO_WHICH_EMAIL_NOTIFICATIONS_ARE_SENT = new StringIdImpl(4605, "A comma-separated list of recipient e-mail addresses to send e-mail notifications to.");
  public static final StringId AgentConfigImpl_IDENTIFY_THE_NAME_OF_THE_FILE_TO_BE_USED_FOR_SAVING_AGENT_STATE = new StringIdImpl(4606, "The name(not the path) of the file to be used for saving agent state. The file is stored in the same directory in which the agent.properties file is located.");
  public static final StringId CacheXmlParser_A_0_IS_NOT_AN_INSTANCE_OF_A_FUNCTION = new StringIdImpl(4607, "A {0} is not an instance of a Function");
  public static final StringId PartitionedRegion_EVICTIONATTRIBUTES_0_WILL_HAVE_NO_EFFECT_1_2 = new StringIdImpl(4608, "EvictionAttributes {0} will have no effect for Partitioned Region {1} on this VM because localMaxMemory is {2}.");
  public static final StringId GemFireCache_INITIALIZATION_FAILED_FOR_REGION_0 = new StringIdImpl(4609, "Initialization failed for Region {0}");
  public static final StringId LocalRegion_INITIALIZATION_FAILED_FOR_REGION_0 = new StringIdImpl(4610, "Initialization failed for Region {0}");
  public static final StringId PartitionedRegion_0_EVICTIONATTRIBUTES_1_DO_NOT_MATCH_WITH_OTHER_2 = new StringIdImpl(4611, "For Partitioned Region {0} the locally configured EvictionAttributes {1} do not match with other EvictionAttributes {2} and may cause misses during reads from VMs with smaller maximums.");
  public static final StringId PartitionedRegion_FOR_PARTITIONED_REGION_0_THE_EVICTION_ATTRIBUTE_FOR_MAXIMUM_MEMORY_1_SHOULD_BE_LESS_THAN_LOCAL_MAXIMUM_MEMORY_FOR_THE_PARTITIONED_REGION_2_MB_RESETTING_EVICTION_MAXIMUM_TO_3 = new StringIdImpl(4612, "For Partitioned Region {0} the Eviction Attribute for maximum memory, {1}, should be less than local maximum memory for the Partitioned Region : {2} MB.  Re-setting eviction maximum to {3}.");
  public static final StringId PartitionedRegion_FOR_PARTITIONED_REGION_0_THE_EVICTION_ATTRIBUTE_FOR_MAXIMUM_MEMORY_1_MB_IS_TOO_SMALL_AND_HAS_BEEN_RESET_TO_2_MB_IN_THIS_VM = new StringIdImpl(4613, "For Partitioned Region {0} the Eviction Attribute for maximum memory, {1} MB, is too small and has been reset to {2} MB in this VM.");
  public static final StringId PartitionedRegion_FOR_PARTITIONED_REGION_0_THE_EVICTION_ATTRIBUTE_FOR_MAXIMUM_ENTRIES_1_IS_TOO_SMALL_AND_HAS_BEEN_RESET_TO_2_ENTRIES_IN_THIS_VM = new StringIdImpl(4614, "For Partitioned Region {0} the Eviction Attribute for maximum entries, {1} , is too small and has been reset to {2} entries in this VM.");
  public static final StringId CFactory_UNABLE_TO_LOAD_0 = new StringIdImpl(4615, "Unable to load {0}");
  public static final StringId DSFIDFactory_COULD_NOT_INSTANTIATE_SQLFABRIC_MESSAGE_CLASSID_0_1 = new StringIdImpl(4616, "Could not instantiate SQLFabric message [classId:{0}]:{1}");
  public static final StringId DSFIDFactory_ILLEGAL_ACCESS_FOR_SQLFABRIC_MESSAGE_CLASSID_0_1 = new StringIdImpl(4617, "Illegal access for SQLFabric message [classId:{0}]:{1}");
  public static final StringId DSFIDFactory_UNKNOWN_CLASSID_0_FOR_SQLFABRIC_MESSAGE = new StringIdImpl(4618, "Unknown ClassId [{0}] for SQLFabric message");
  public static final StringId AbstractRegionMap_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE = new StringIdImpl(4619, "The current value was not equal to expected value.");
  public static final StringId AbstractRegionEntry_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE = new StringIdImpl(4620, "The current value was not equal to expected value.");
  public static final StringId AbstractRegionMap_ENTRY_NOT_FOUND_WITH_EXPECTED_VALUE = new StringIdImpl(4621, "entry not found with expected value");
  public static final StringId PartitionedRegion_CANNOT_APPLY_A_DELTA_WITHOUT_EXISTING_ENTRY = new StringIdImpl(4622, "Cannot apply a delta without existing entry");
  public static final StringId ExecuteRegionFunction_CAUGHT_EXCEPTION_EXECUTING_FUNCTION_0_ON_1_2_3 = new StringIdImpl(4623, "Caught exception executing function {0} on {1}: {2}: {3}");
  public static final StringId CacheXmlParser_EXPECTED_A_FUNCTIONSERVICECREATION_INSTANCE = new StringIdImpl(4624, "Expected a FunctionServiceCreation instance");
  public static final StringId CacheXmlParser_A_0_IS_ONLY_ALLOWED_IN_THE_CONTEXT_OF_1_MJTDEBUG_E_2 = new StringIdImpl(4625, "A {0} is only allowed in the context of {1} MJTDEBUG e={2}");
  public static final StringId ExecuteRegionFunctionOp_UNEXPECTED_EXCEPTION_DURING_EXECUTION_OF_FUNCTION_0 = new StringIdImpl(4626, "Unexpected exception during execution of function, \"{0}\"");
  public static final StringId CacheHealthEvaluator_THE_AVERAGE_DURATION_OF_A_CACHE_LOAD_0_MS_EXCEEDS_THE_THRESHOLD_1_MS = new StringIdImpl(4627, "The average duration of a Cache load ({0} ms) exceeds the threshold ({1} ms)");
  public static final StringId DistributionManager_UNEXPECTED_CANCELLATION = new StringIdImpl(4628, "Unexpected cancellation");
  public static final StringId GatewayImpl_GATEWAY_0_IS_NOT_CLOSING_CLEANLY_FORCING_CANCELLATION = new StringIdImpl(4629, "Gateway <{0}> is not closing cleanly; forcing cancellation.");
  public static final StringId GatewayImpl_TERMINATED_DUE_TO_REGIONDESTROYEDEXCEPTION = new StringIdImpl(4630, "Terminated due to RegionDestroyedException");
  public static final StringId GatewayImpl_A_CANCELLATION_OCCURRED_STOPPING_THE_DISPATCHER = new StringIdImpl(4631, "A cancellation occurred. Stopping the dispatcher.");
  public static final StringId GatewayImpl_MESSAGE_DISPATCH_FAILED_DUE_TO_UNEXPECTED_EXCEPTION = new StringIdImpl(4632, "Message dispatch failed due to unexpected exception..");
  public static final StringId DistributedRegion_REGION_0_IS_REQUESTING_INITIAL_IMAGE_FROM_MULTIPLE_PROVIDERS_1 = new StringIdImpl(4633, "Region, {0}, is requesting initial image from multiple providers [{1}]");
  public static final StringId DistributionManager_INTERRUPTED_SENDING_SHUTDOWN_MESSAGE_TO_PEERS = new StringIdImpl(4634, "Interrupted sending shutdown message to peers");
  public static final StringId DistributionManager_INTERRUPTED_DURING_SHUTDOWN = new StringIdImpl(4635, "Interrupted during shutdown");
  public static final StringId GemFireCache_0_NOW_CLOSING = new StringIdImpl(4636, "{0}: Now closing.");
  public static final StringId HARegionQueue_QUEUEREMOVALTHREAD_IGNORED_CANCELLATION = new StringIdImpl(4637, "QueueRemovalThread ignored cancellation");
  public static final StringId ConnectionTable_UNABLE_TO_FORM_A_TCPIP_CONNECTION_TO_0_IN_OVER_1_SECONDS = new StringIdImpl(4638, "Unable to form a TCP/IP connection to {0} in over {1} seconds");
  public static final StringId InternalDistributedSystem_DISCONNECT_WAIT_INTERRUPTED = new StringIdImpl(4639, "Disconnect wait interrupted");
  public static final StringId InternalDistributedSystem_WAITING_THREAD_FOR_RECONNECT_GOT_INTERRUPTED = new StringIdImpl(4640, "Waiting thread for reconnect got interrupted.");
  public static final StringId DLockRequestProcess_INTERRUPTED_WHILE_RELEASING_GRANT = new StringIdImpl(4641, "Interrupted while releasing grant.");
  public static final StringId LicenseHelper_UNABLE_TO_DELETE_0 = new StringIdImpl(4642, "Unable to delete {0}");
  public static final StringId CacheClientUpdater_0_NO_CACHE_EXITING = new StringIdImpl(4643, "{0}: no cache (exiting)");
  public static final StringId CacheClientUpdater_0_WAIT_TIMED_OUT_MORE_THAN_1_SECONDS = new StringIdImpl(4644, "{0}: wait timed out (more than {1} seconds)");
  public static final StringId CacheClientUpdater_0_ABANDONED_WAIT_DUE_TO_CANCELLATION = new StringIdImpl(4645, "{0}: abandoned wait due to cancellation.");
  public static final StringId CacheClientUpdater_0_ABANDONED_WAIT_BECAUSE_IT_IS_NO_LONGER_CONNECTED = new StringIdImpl(4646, "{0}: abandoned wait because it is no longer connected");
  public static final StringId GatewayEventRemoteDispatcher_INTERRUPTED_WHILE_REMOVING_0_EVENTS = new StringIdImpl(4647, "Interrupted while removing {0} events.");
  public static final StringId MailManager_ALERT_MAIL_SUBJECT = new StringIdImpl(4648, "Alert from GemFire Admin Agent");
  public static final StringId MailManager_EMAIL_ALERT_HAS_BEEN_SENT_0_1_2 = new StringIdImpl(4649, "Email sent to {0}. Subject: {1}, Content: {2}");
  public static final StringId StartupResponseMessage_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0 = new StringIdImpl(4650, "Could not load instantiator class: {0}");
  public static final StringId StartupResponseMessage_COULD_NOT_LOAD_INSTANTIATED_CLASS_0 = new StringIdImpl(4651, "Could not load instantiated class: {0}");
  public static final StringId QueueManagerImpl_0_UNABLE_TO_NOTIFY_A_PRIMARY_SERVER_OF_CLIENT_READINESS_THERE_ARE_NO_ACTIVE_PRIMARY_SERVERS = new StringIdImpl(4652, "{0}: Unable to notify a primary server of client readiness. There are no active primary servers.");
  public static final StringId CacheClientProxy_0_CANT_CREATE_INTEREST_REGION = new StringIdImpl(4653, "{0}: Unexpected exception during initialization");
  public static final StringId CacheClientProxy_0_INTEREST_REG_FOR_0_FAILED = new StringIdImpl(4654, "Interest registration for {0} was not completed because of the following exception:");
  public static final StringId CacheClientProxy_THE_FOLLOWING_EXCEPTION_OCCURRED_0 = new StringIdImpl(4655, "The following exception occurred while attempting to serialize {0}");
  public static final StringId RemoteBridgeServer_CANNOT_GET_CLIENT_SESSION = new StringIdImpl(4656, "Cannot get a client session for a remote BridgeServer");
  public static final StringId RemoteBridgeServer_CANNOT_GET_ALL_CLIENT_SESSIONS = new StringIdImpl(4657, "Cannot get all client sessions for a remote BridgeServer");
  public static final StringId CacheServerLauncher_REBALANCE = new StringIdImpl(4658, "-rebalance  Indicates that the Cache should immediately be rebalanced");
  public static final StringId PRHARedundancyProvider_UNEXPECTED_EXCEPTION_DURING_BUCKET_RECOVERY = new StringIdImpl(4659, "Unexpected exception during bucket recovery");
  public static final StringId PartitionedRegionRebalanceOp_UNABLE_TO_RELEASE_RECOVERY_LOCK = new StringIdImpl(4660, "Unable to release recovery lock");
  public static final StringId PartitionedRegionRebalanceOp_ERROR_IN_RESOURCE_OBSERVER = new StringIdImpl(4661, "Error in resource observer");
  public static final StringId PartitionedRegionFunctionMessage_UNABLE_TO_DESERIALIZE_A_PORTION_OF_THE_DATA = new StringIdImpl(4662, "PartitionedRegionFunctionReplyMessage unable to deserialize a portion of the data");
  public static final StringId PartitionedRegionFunctionMessage_UNABLE_TO_COMPLETE_A_PORTION_OF_THE_DATA = new StringIdImpl(4663, "PartitionedRegionFunctionReplyMessage unable to complete a portion of the data");
  public static final StringId AuthorizeRequestPP_0_NOT_AUTHORIZED_TO_PERFORM_EXECUTE_REGION_FUNCTION_1= new StringIdImpl(4664, "{0}: In post-process: Not authorized to perform EXECUTE_REGION_FUNCTION operation on region [{1}]");
  public static final StringId PartitionedRegionLoadModel_INCOMPLETE_COLOCATION= new StringIdImpl(4665, "PartitionedRegionLoadModel - member {0} has incomplete colocation, but it has buckets for some regions. Should have colocated regions {1}  but had {2}  and contains buckets {3}");
  public static final StringId HeapMemoryMonitor_OVERRIDDING_MEMORYPOOLMXBEAN_HEAP_0_NAME_1 = new StringIdImpl(4666, "Overridding MemoryPoolMXBean heap threshold bytes {0} on pool {1}");
  
  // 4667-4668 is UNUSED.
  
  public static final StringId MemoryMonitor_MEMBER_ABOVE_CRITICAL_THRESHOLD = new StringIdImpl(4669, "Member: {0} above {1} critical threshold");
  public static final StringId MemoryMonitor_MEMBER_ABOVE_HIGH_THRESHOLD = new StringIdImpl(4670, "Member: {0} above {1} eviction threshold");
  public static final StringId ResourceManager_REJECTED_EXECUTION_CAUSE_NOHEAP_EVENTS = new StringIdImpl(4671, "No memory events will be delivered because of RejectedExecutionException");
  public static final StringId ResourceManager_FAILED_TO_STOP_RESOURCE_MANAGER_THREADS = new StringIdImpl(4672, "Failed to stop resource manager threads in {0} seconds");
  public static final StringId GatewayImpl_EVENT_QUEUE_ALERT_OPERATION_0_REGION_1_KEY_2_VALUE_3_TIME_4 = new StringIdImpl(4673, "{0} event for region={1} key={2} value={3} was in the queue for {4} milliseconds");
  public static final StringId GatewayImpl_PAUSED__0 = new StringIdImpl(4674, "Paused {0}");
  public static final StringId GatewayImpl_RESUMED__0 = new StringIdImpl(4675, "Resumed {0}");
  public static final StringId CacheClientProxy_NOT_PRIMARY = new StringIdImpl(4676, "This process is not the primary server for the given client");
  public static final StringId CacheServerImpl_MUST_BE_RUNNING = new StringIdImpl(4677, "The cache server must be running to use this operation");
  public static final StringId InitialImageOperation_0_UNABLE_TO_FLUSH_STATE_TO_1 = new StringIdImpl(4678, "{0}: Unable to flush state to {1} for concurrent gii union");
  public static final StringId InstantiatorRecoveryListener_INSTANTIATORRECOVERYTASK_ERROR_CLASSNOTFOUNDEXCEPTION = new StringIdImpl(4679, "InstantiatorRecoveryTask - Error ClassNotFoundException: {0}");
  public static final StringId AbstractRegion_NO_CUSTOM_EVICTION_SET = new StringIdImpl(4680, "Custom eviction not enabled for region {0}");  public static final StringId ResourceAdvisor_MEMBER_CAUGHT_EXCEPTION_PROCESSING_PROFILE = new StringIdImpl(4682, "This member caught exception processing profile {0} {1}");
  public static final StringId MemoryMonitor_EXCEPTION_OCCURED_WHEN_NOTIFYING_LISTENERS = new StringIdImpl(4683, "Exception occurred when notifying listeners ");
  public static final StringId CacheXmlParser_A_0_IS_NOT_DATA_SERIALIZABLE = new StringIdImpl(4684, "The class {0}, presented for instantiator registration is not an instance of DataSerializable and cannot be registered.");
  public static final StringId CacheXmlParser_NO_SERIALIZATION_ID = new StringIdImpl(4685, "The instantiator registration did not include an ID attribute.");
  public static final StringId CacheXmlParser_NO_CLASSNAME_FOUND = new StringIdImpl(4686, "A string class-name was expected, but not found while parsing.");
  public static final StringId CacheXmlParser_A_0_CLASS_NOT_FOUND = new StringIdImpl(4687, "Unable to load class {0}");
  public static final StringId CacheXmlParser_A_0_NOT_A_SERIALIZER = new StringIdImpl(4688, "The class {0} presented for serializer registration does not extend DataSerializer and cannot be registered.");
  public static final StringId SerializerCreation_A_0_INSTANTIATION_FAILED = new StringIdImpl(4689, "Failed to create a new instance of DataSerializable class {0}");
  public static final StringId HeapMemoryMonitor_NO_POOL_FOUND_POOLS_0 = new StringIdImpl(4690, "No tenured pools found.  Known pools are: {0}");
  public static final StringId MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100 = new StringIdImpl(4691, "Critical percentage must be greater than 0.0 and less than or equal to 100.0.");
  public static final StringId MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE = new StringIdImpl(4692, "Critical percentage must be greater than the eviction percentage.");
  public static final StringId MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100 = new StringIdImpl(4693, "Eviction percentage must be greater than 0.0 and less than or equal to 100.0.");
  public static final StringId MemoryMonitor_EVICTION_PERCENTAGE_LTE_CRITICAL_PERCENTAGE = new StringIdImpl(4694,"Eviction percentage must be less than the critical percentage.");
  public static final StringId PartitionedRegionFunctionResultSender_UNEXPECTED_EXCEPTION_DURING_FUNCTION_EXECUTION_ON_LOCAL_NODE = new StringIdImpl(4695, "Unexpected exception during function execution on local node Partitioned Region");
  public static final StringId DistributedRegionFunctionResultSender_UNEXPECTED_EXCEPTION_DURING_FUNCTION_EXECUTION_ON_LOCAL_NODE = new StringIdImpl(4696, "Unexpected exception during function execution on local node Distributed Region");
  public static final StringId MemberResultSender_UNEXPECTED_EXCEPTION_DURING_FUNCTION_EXECUTION_ON_LOCAL_NODE = new StringIdImpl(4697, "Unexpected exception during function execution local member");
  public static final StringId ServerResultSender_UNAVOIDABLE_IOEXCEPTION = new StringIdImpl(4698, "Unavoidable Network Error while sending result");
  public static final StringId ResourceManager_LOW_MEMORY_IN_0_FOR_PUT_1_MEMBER_2 = new StringIdImpl(4700, "Region: {0} cannot process operation on key: {1} because member {2} is running low on memory");
  public static final StringId ResourceManager_LOW_MEMORY_PR_0_KEY_1_MEMBERS_2 = new StringIdImpl(4701, "PartitionedRegion: {0} cannot process operation on key {1} because members {2} are running low on memory");
  public static final StringId ExecuteFunction_CANNOT_0_RESULTS_HASRESULT_FALSE = new StringIdImpl(4702, "Cannot {0} result as the Function#hasResult() is false");
  public static final StringId ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1 = new StringIdImpl(4703, "Function: {0} cannot be executed because the members {1} are running low on memory");
  public static final StringId ResourceManager_LOW_MEMORY_FOR_INDEX = new StringIdImpl(4704, "Cannot create index on region {0} because the target member is running low on memory");
  public static final StringId AdminDistributedsystemImpl_UNKNOWN_GEMFIREVM_TYPE_0 = new StringIdImpl(4705, "Unknown GemFireVM type: {0}");
  public static final StringId DistributedSystemConfigImpl_0_IS_NOT_A_VALID_INTEGER_1 = new StringIdImpl(4706, "{0} is not a valid integer for {1}");
  public static final StringId AdminDistributedSystemJmxImpl_JMX_CLIENT_COUNT_HAS_DROPPED_TO_ZERO = new StringIdImpl(4707, "JMX Client count has dropped to zero.");
  public static final StringId AdminDistributedSystemJmxImpl_MEMBER_JOINED_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0 = new StringIdImpl(4708, "Member joined the Distributed System\n\tMember Id: {0}");
  public static final StringId AdminDistributedSystemJmxImpl_MEMBER_LEFT_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0 = new StringIdImpl(4709, "Member left the Distributed System\n\tMember Id: {0}");
  public static final StringId AdminDistributedSystemJmxImpl_MEMBER_CRASHED_IN_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0 = new StringIdImpl(4710, "Member crashed in the Distributed System\n\tMember Id: {0}");
  public static final StringId AdminDistributedSystemJmxImpl_MEMBER_JOINED = new StringIdImpl(4711, "Member Joined");
  public static final StringId AdminDistributedSystemJmxImpl_MEMBER_LEFT = new StringIdImpl(4712, "Member Left");
  public static final StringId AdminDistributedSystemJmxImpl_MEMBER_CRASHED = new StringIdImpl(4713, "Member Crashed");
  public static final StringId AdminDistributedSystemJmxImpl_SYSTEM_ALERT_FROM_DISTRIBUTED_SYSTEM_0 = new StringIdImpl(4714, "System Alert from Distributed System\n\t: {0}");
  public static final StringId AdminDistributedSystemJmxImpl_STATISTICS_ALERT_FOR_MEMBER = new StringIdImpl(4715, "Statistics Alert for member");
  public static final StringId AgentConfigImpl_IP_ADDRESS_OF_THE_AGENTS_DISTRIBUTED_SYSTEM = new StringIdImpl(4716, "An IP address of the JMX Agent''s distributed system on a multi-homed host. On a multi-homed host, you must explicitly specify the bind address.");
  public static final StringId AgentConfigImpl_REFRESH_INTERVAL_IN_SECONDS_FOR_AUTOREFRESH_OF_MEMBERS_AND_STATISTIC_RESOURCES = new StringIdImpl(4718, "Refresh Interval, in seconds, to be used for auto-refresh of SystemMember, StatisticResource and CacheServer refreshes");
  public static final StringId AgentConfigImpl_FAILED_TO_CREATE_NEW_FILE_0 = new StringIdImpl(4719, "Failed to create new file: {0}");
  public static final StringId AgentConfigImpl_AGENT_CONFIGURATION = new StringIdImpl(4720, "Agent Configuration:");
  public static final StringId AgentImpl_FAILED_TO_START_RMI_SERVICE = new StringIdImpl(4721, "Failed to start RMI service, verify RMI configuration properties");
  public static final StringId AgentImpl_SETTING_0 = new StringIdImpl(4722, "Setting {0}");
  public static final StringId AgentLauncher_SERVER_FAILED_TO_START_0 = new StringIdImpl(4723, "Server failed to start: {0}");
  public static final StringId AgentLauncher_MISSING_COMMAND = new StringIdImpl(4724, "Missing command");
  public static final StringId AgentLauncher_THE_SPECIFIED_WORKING_DIRECTORY_0_CONTAINS_NO_STATUS_FILE = new StringIdImpl(4725, "The specified working directory ({0}) contains no status file");
  public static final StringId AgentLauncher_NO_AVAILABLE_STATUS = new StringIdImpl(4726, "No available status.");
  public static final StringId AgentLauncher_COULD_NOT_DELETE_FILE_0 = new StringIdImpl(4727, "Could not delete file: \"{0}\".");
  public static final StringId AgentLauncher_REQUEST_INTERRUPTED_BY_USER = new StringIdImpl(4728, "Request interrupted by user");
  public static final StringId MANAGED_RESOURCE_REFRESH_INTERVAL_CANT_BE_SET_DIRECTLY = new StringIdImpl(4729, "RefreshInterval can not be set directly. Use DistributedSystemConfig.refreshInterval.");
  public static final StringId MBeanUtil_0_IN_1 = new StringIdImpl(4730, "{0} in ''{1}''");
  public static final StringId MailManager_AN_EXCEPTION_OCCURRED_WHILE_SENDING_EMAIL = new StringIdImpl(4731, "An exception occurred while sending email.");
  public static final StringId MailManager_UNABLE_TO_SEND_EMAIL_PLEASE_CHECK_YOUR_EMAIL_SETTINGS_AND_LOG_FILE = new StringIdImpl(4732, "Unable to send email. Please check your mail settings and the log file.");
  public static final StringId MailManager_EXCEPTION_MESSAGE_0 = new StringIdImpl(4733, "Exception message: {0}");
  public static final StringId MailManager_FOLLOWING_EMAIL_WAS_NOT_DELIVERED = new StringIdImpl(4734, "Following email was not delivered:");
  public static final StringId MailManager_MAIL_HOST_0 = new StringIdImpl(4735, "Mail Host: {0}");
  public static final StringId MailManager_FROM_0 = new StringIdImpl(4736, "From: {0}");
  public static final StringId MailManager_TO_0 = new StringIdImpl(4737, "To: {0}");
  public static final StringId MailManager_SUBJECT_0 = new StringIdImpl(4738, "Subject: {0}");
  public static final StringId MailManager_CONTENT_0 = new StringIdImpl(4739, "Content: {0}");
  public static final StringId PutMessage_ERROR_APPLYING_DELTA_FOR_KEY_0= new StringIdImpl(4740, "Error applying delta for key {0}");
  public static final StringId RegionAttributesCreation__CLONING_ENABLE_IS_NOT_THE_SAME_THIS_0_OTHER_1 = new StringIdImpl(4741, "Cloning enabled is not the same: this:  {0}  other:  {1}");
  public static final StringId UpdateOperation_ERROR_APPLYING_DELTA_FOR_KEY_0_OF_REGION_1 = new StringIdImpl(4742, "Error applying delta for key {0} of region {1}");
  public static final StringId UpdateOperation_DELTA_CANNOT_BE_APPLIED_AS_REGION_IS_ALREADY_DESTROYED = new StringIdImpl(4743, "Delta cannot be applied as region is already destroyed");
  public static final StringId RequestEventValue_0_THE_EVENT_ID_FOR_THE_GET_EVENT_VALUE_REQUEST_IS_NULL = new StringIdImpl(4744, "{0}: The event id for the get event value request is null.");
  public static final StringId RequestEventValue_UNABLE_TO_FIND_A_CLIENT_UPDATE_MESSAGE_FOR_0 = new StringIdImpl(4745, "Unable to find a client update message for {0}");
  public static final StringId PoolImpl_STATISTIC_SAMPLING_MUST_BE_ENABLED_FOR_SAMPLING_RATE_OF_0_TO_TAKE_AFFECT = new StringIdImpl(4746, "statistic-sampling must be enabled for sampling rate of {0} to take affect");
  public static final StringId AgentLauncher_EXCEPTION_IN_0_1 = new StringIdImpl(4747, "Exception in {0} : {1} ");
  public static final StringId MBeanUtil_FAILED_TO_CREATE_MBEAN_FOR_0 = new StringIdImpl(4748, "Failed to create MBean representation for resource {0}.");
  public static final StringId GemFireCache_LONG_RUNNING_QUERY_EXECUTION_CANCELED = new StringIdImpl(4749, "Query execution taking more than the max query-execution time is canceled, for query: {0} on thread thread id: {1} canceled");
  public static final StringId QueryMonitor_LONG_RUNNING_QUERY_CANCELED = new StringIdImpl(4750, "Query execution cancelled after exceeding max execution time {0}ms.");
  public static final StringId AdminDistributedSystemJmxImpl_STATISTICS_ALERT_FROM_DISTRIBUTED_SYSTEM_MEMBER_0_STATISTICS_1 = new StringIdImpl(4751, "Statistics Alert from Distributed System\n\tMember: {0}\n\tStatistics: {1}");
  public static final StringId SystemAdmin_VALIDATE_DISK_STORE = new StringIdImpl(4752, "Checks to make sure files of a disk store are valid.\n The name of the disk store and the directories its files are stored in are required arguments.");
  public static final StringId SystemAdmin_MODIFY_DISK_STORE = new StringIdImpl(4753, "Modifies the contents stored in a disk store.\n Note that this operation writes to the disk store files so use it with care. Requires that a region name by specified using -region=<regionName>\n Options:\n   -remove will remove the region from the disk store causing any data stored in the disk store for this region to no longer exist. Subregions of the removed region will not be removed.\n   -lru=<type> Sets region''s lru algorithm. Valid types are: none, lru-entry-count, lru-heap-percentage, or lru-memory-size\n   -lruAction=<action> Sets the region''s lru action. Valid actions are: none, overflow-to-disk, local-destroy\n   -lruLimit=<int> Sets the region''s lru limit. Valid values are >= 0\n   -concurrencyLevel=<int> Sets the region''s concurrency level. Valid values are >= 0\n   -initialCapacity=<int> Sets the region''s initial capacity. Valid values are >= 0.\n   -loadFactor=<float> Sets the region''s load factory. Valid values are >= 0.0\n   -statisticsEnabled=<boolean> Sets the region''s statistics enabled. Value values are true or false.\n The name of the disk store and the directories its files are stored in and the region to target are all required arguments.");
  public static final StringId DiskRegion_COMPACTION_DELETING = new StringIdImpl(4754, "compaction deleting {0} entries");
  public static final StringId DiskRegion_COMPACTION_DELETED = new StringIdImpl(4755, "compaction deleted {0} entries in {1} ms");
  public static final StringId DiskRegion_COMPACTION_SUMMARY = new StringIdImpl(4756, "compaction did {0} creates and updates in {1} ms");
  public static final StringId DiskRegion_COMPACTION_OPLOGIDS = new StringIdImpl(4757, "OplogCompactor for {0} compaction oplog id(s): {1}");
  public static final StringId DiskRegion_COMPACTION_SUCCESS = new StringIdImpl(4758, "OplogCompactor for {0} completed compaction of oplog id(s): {1}");
  public static final StringId DiskRegion_COMPACTION_FAILURE = new StringIdImpl(4759, "OplogCompactor for {0} did NOT complete compaction of oplog id(s): {1}");
  public static final StringId DiskRegion_DB_LOAD_TIME = new StringIdImpl(4760, "recovery db load took {0} ms");
  public static final StringId DiskRegion_OPLOG_LOAD_TIME = new StringIdImpl(4761, "recovery oplog load took {0} ms");
  public static final StringId DiskRegion_REGION_INIT_TIME = new StringIdImpl(4762, "recovery region initialization took {0} ms");
  public static final StringId DiskRegion_OPLOG_REMOVE_TIME = new StringIdImpl(4763, "recovery oplog deletion took {0} ms");
  public static final StringId Oplog_DUPLICATE_CREATE = new StringIdImpl(4764, "Oplog::readNewEntry: Create is present in more than one Oplog. This should not be possible. The Oplog Key ID for this entry is {0,number,#}.");
  public static final StringId StreamingPartitionOperation_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1 = new StringIdImpl(4765, "Streaming reply processor got memberDeparted event for < {0} > crashed =  {1}");
  public static final StringId Eviction_EVICTOR_TASK_EXCEPTION = new StringIdImpl(4766, "Exception: {0} occurred during eviction ");
  public static final StringId AdminDistributedSystemJmxImpl_READONLY_STAT_ALERT_DEF_FILE_0 = new StringIdImpl(4767, "stat-alert definitions could not be saved in the read-only file {0}.");
  public static final StringId Oplog_CLOSING_EMPTY_OPLOG_0_1 = new StringIdImpl(4768, "Closing {1} early since it is empty. It is for disk store {0}.");
  public static final StringId CacheServerHelper_UTF8_EXCEPTION = new StringIdImpl(4769, "UTF-8 Exception malformed input");
  public static final StringId Mem_LRU_Eviction_Attribute_Reset = new StringIdImpl(4770, "For region {0} with data policy PARTITION, memory LRU eviction attribute \"maximum\" has been reset from {1}MB to local-max-memory {2}MB");
  public static final StringId DiskRegion_MISSING_OR_CORRUPT_OPLOG = new StringIdImpl(4771, "Detected that an oplog was mistakenly deleted or corrupted. This has caused creates to be lost but the keys of those creates are unknown.");
  public static final StringId SingleWriteSingleReadRegionQueue_57_QUEUE_UPGRADED = new StringIdImpl(4772, "Upgraded the persistent files for WAN queue {0} to version 6.0+");
  public static final StringId AdminDistributedSystemJmxImpl_FAILED_TO_CREATE_STAT_ALERT_DEF_FILE_0 = new StringIdImpl(4773, "Could not create file {0} to save stat-alert definitions. stat-alert definitions could not be saved");
  public static final StringId GemFireHealthImpl_COULD_NOT_FIND_A_HOST_WITH_NAME_0 = new StringIdImpl(4774, "Could not find a host with name \"{0}\".");
  public static final StringId AbstractDistributionConfig_REMOVE_UNRESPONSIVE_CLIENT_PROP_NAME_0 = new StringIdImpl(4775,"Whether to remove unresponsive client or not. Defaults to {0}.");
  public static final StringId CacheClientNotifier_CLIENT_0_IS_A_SLOW_RECEIVER = new StringIdImpl(4776,"Client {0} is a slow receiver.");
  public static final StringId HARegionQueue_CLIENT_QUEUE_FOR_0_IS_FULL = new StringIdImpl(4777,"Client queue for {0} client is full.");

  public static final StringId Oplog_DELETE_0_1_2 = new StringIdImpl(4778,"Deleted {0} {1} for disk store {2}.");
  public static final StringId Oplog_CREATE_0_1_2 = new StringIdImpl(4779,"Created {0} {1} for disk store {2}.");
  public static final StringId DiskRegion_RECOVERING_OPLOG_0_1_2 = new StringIdImpl(4780,"Recovering {0} {1} for disk store {2}.");
  public static final StringId DiskRegion_COULD_NOT_OPEN_0 = new StringIdImpl(4781, "Could not open {0}.");

  public static final StringId MemoryMonitor_MEMBER_BELOW_CRITICAL_THRESHOLD = new StringIdImpl(4782,"Member: {0} below {1} critical threshold");
  public static final StringId MemoryMonitor_MEMBER_BELOW_HIGH_THRESHOLD = new StringIdImpl(4783,"Member: {0} below {1} eviction threshold");
  public static final StringId AttributesFactory_INVALIDATE_REGION_NOT_SUPPORTED_FOR_PR = new StringIdImpl(4784,"ExpirationAction INVALIDATE or LOCAL_INVALIDATE for region is not supported for Partitioned Region.");
  public static final StringId AttributesFactory_LOCAL_DESTROY_IS_NOT_SUPPORTED_FOR_PR = new StringIdImpl(4785,"ExpirationAction LOCAL_DESTROY is not supported for Partitioned Region.");
  public static final StringId AttributesFactory_LOCAL_INVALIDATE_IS_NOT_SUPPORTED_FOR_PR = new StringIdImpl(4786,"ExpirationAction LOCAL_INVALIDATE is not supported for Partitioned Region.");
  public static final StringId CONNECTION_DISTRIBUTOR_THREAD = new StringIdImpl(4787, "SQLFabric Connection open/close distributor thread");
  public static final StringId CONNECTION_CHANGE_PROCESS_FAILED = new StringIdImpl(4788, "SQLFabric Connection distributor thread: Exception in distributing connection change on remote nodes or unknown exception in thread");
  public static final StringId GemFireUtilLauncher_ARGUMENTS = new StringIdImpl(4789, "Usage:\n{0} [{1}] <arguments for the utility specified>\n\nThe command to display a particular utility''s usage is:\n{0} <utility name> --help");
  public static final StringId GemFireUtilLauncher_INVALID_UTILITY_0 = new StringIdImpl(4790, "Invalid utility name: {0} was specified.");
  public static final StringId GemFireUtilLauncher_PROBLEM_STARTING_0 = new StringIdImpl(4791, "Problem starting {0}.");
  public static final StringId GemFireUtilLauncher_MISSING_COMMAND = new StringIdImpl(4792, "** Missing command");
  public static final StringId GemFireUtilLauncher_HELP = new StringIdImpl(4793, "** Displaying help information");
  public static final StringId AttributesFactory_DESTROY_REGION_NOT_SUPPORTED_FOR_PR = new StringIdImpl(4794,"ExpirationAction DESTROY or LOCAL_DESTROY for region is not supported for Partitioned Region.");
  public static final StringId ExecuteFunction_DS_NOT_CREATED_OR_NOT_READY = new StringIdImpl(4795, "DistributedSystem is either not created or not ready");

  public static final StringId CacheClientUpdater_CLASS_NOT_FOUND=new StringIdImpl(4796, "Unable to load the class: {0}");
  public static final StringId DataSerializerRecoveryListener_ERROR_CLASSNOTFOUNDEXCEPTION = new StringIdImpl(4797, "DataSerializerRecoveryTask - Error ClassNotFoundException: {0}");
  public static final StringId DataSerializerRecoveryListener_ERROR_RECOVERING_DATASERIALIZERS = new StringIdImpl(4798, "DataSerializerRecoveryTask - Error recovering dataSerializers: ");
  public static final StringId GetClientPRMetadata_THE_INPUT_REGION_PATH_IS_NULL = new StringIdImpl(4799, " The input region path for the GetClientPRMetadata request is null");
  public static final StringId GetClientPartitionAttributes_THE_INPUT_REGION_PATH_IS_NULL = new StringIdImpl(4800, " The input region path for the GetClientPartitionAttributes request is null");
  public static final StringId GetClientPRMetadata_REGION_NOT_FOUND_FOR_SPECIFIED_REGION_PATH = new StringIdImpl(4801, "Region was not found during GetClientPRMetadata request for region path : {0}");
  public static final StringId GetClientPartitionAttributes_REGION_NOT_FOUND_FOR_SPECIFIED_REGION_PATH = new StringIdImpl(4802, "Region was not found during GetClientPartitionAttributes request for region path : {0}");
  public static final StringId GetClientPRMetadata_REGION_NOT_FOUND = new StringIdImpl(4803, "Region was not found during GetClientPRMetadata request for region path : ");
  public static final StringId GetClientPartitionAttributes_REGION_NOT_FOUND= new StringIdImpl(4804, "Region was not found during GetClientPartitionAttributes request for region path : ");
  public static final StringId ClientPartitionAdvisor_CANNOT_CREATE_AN_INSTANCE_OF_PARTITION_RESOLVER_0 = new StringIdImpl(4805, "Cannot create an instance of PartitionResolver : {0}");
  public static final StringId FunctionService_0_PASSED_IS_NULL = new StringIdImpl(4806, "{0} passed is null");
  public static final StringId FunctionService_FUNCTION_GET_ID_RETURNED_NULL  = new StringIdImpl(4807, "function.getId() returned null, implement the Function.getId() method properly");
  public static final StringId DistributionManager_CAUGHT_EXCEPTION_WHILE_SENDING_DELTA = new StringIdImpl(4808, "Caught exception while sending delta. ");
  public static final StringId DirectChannel_FAILURE_SENDING_DIRECT_REPLY = new StringIdImpl(4809, "Failed sending a direct reply to {0}");

  //4810 is free
  public static final StringId GatewayImpl_EVENT_QUEUE_DISPATCH_FAILED = new StringIdImpl(4811,"During normal processing, unsuccessfully dispatched {0} events (batch #{1})");
  //4812 is free
  public static final StringId SqlfServerLauncher_STARTING_NET_SERVER = new StringIdImpl(4813, "Starting network server for {0} at address {1}[{2}]");
  public static final StringId SqlfServerLauncher_UNKNOWN_ARGUMENT = new StringIdImpl(4814, "Unknown argument: {0}={1}");

  public static final StringId PartitionedRegion_KEY_0_NOT_COLOCATED_WITH_TRANSACTION = new StringIdImpl(4815, "Key {0} is not colocated with transaction");
  public static final StringId LocalRegion_NON_TRANSACTIONAL_REGION_COLLECTION_IS_BEING_USED_IN_A_TRANSACTION = new StringIdImpl(4816, "The Region collection is not transactional but is being used in a transaction {0}.");
  public static final StringId LocalRegion_REGION_COLLECTION_WAS_CREATED_WITH_A_DIFFERENT_TRANSACTION = new StringIdImpl(4817, "Region collection was created in a different transaction than the current transaction {0}");
  public static final StringId TXEntry_UA_NOT_SUPPORTED_FOR_PR = new StringIdImpl(4818, "Partitioned region does not support UserAttributes in transactional context");
  public static final StringId TXStateStub_ROLLBACK_ON_NODE_0_FAILED = new StringIdImpl(4819, "Rollback operation on node {0} failed");
  public static final StringId PartitionedRegion_INVALIDATING_REGION_CAUGHT_EXCEPTION = new StringIdImpl(4820, "Invalidating partitioned region caught exception {0}");
  public static final StringId PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING = new StringIdImpl(4821, "Transactional data moved, due to rebalancing.");
  public static final StringId PartitionedRegion_TRANSACTION_DATA_NODE_0_HAS_DEPARTED_TO_PROCEED_ROLLBACK_THIS_TRANSACTION_AND_BEGIN_A_NEW_ONE = new StringIdImpl(4822, "Transaction data node {0} has departed. To proceed, rollback this transaction and begin a new one.");
  public static final StringId TXState_GET_ALL_NOT_SUPPORTED_IN_A_TRANSACTION = new StringIdImpl(4823,"getAll() is not supported while in a transaction");
  public static final StringId TXState_PUT_ALL_NOT_SUPPORTED_IN_A_TRANSACTION = new StringIdImpl(4824,"putAll() is not supported while in a transaction");
  public static final StringId TXState_REGION_DESTROY_NOT_SUPPORTED_IN_A_TRANSACTION = new StringIdImpl(4825,"destroyRegion() is not supported while in a transaction");
  public static final StringId TXState_REGION_INVALIDATE_NOT_SUPPORTED_IN_A_TRANSACTION = new StringIdImpl(4826,"invalidateRegion() is not supported while in a transaction");
  public static final StringId PartitionedRegion_TX_FUNCTION_ON_MORE_THAN_ONE_NODE = new StringIdImpl(4827, "Function inside a transaction cannot execute on more than one node");
  public static final StringId PartitionedRegion_TX_ON_DATASTORE = new StringIdImpl(4828, "PartitionedRegion Transactions cannot execute on nodes with local max memory zero");
  public static final StringId PartitionedRegion_TX_FUNCTION_EXECUTION_NOT_COLOCATED = new StringIdImpl(4829, "Function execution is not colocated with transaction");
  public static final StringId FAILED_SENDING_0 = new StringIdImpl(4830, "Failed sending < {0} >");
  public static final StringId RemoteContainsKeyValueMessage_CONTAINSKEYVALUERESPONSE_GOT_REMOTE_CACHEEXCEPTION = new StringIdImpl(4831, "RemoteContainsKeyResponse got remote CacheException; triggering RemoteOperationException.");
  public static final StringId RemoteContainsKeyValueMessage_NO_RETURN_VALUE_RECEIVED = new StringIdImpl(4832, "no return value received");
  public static final StringId RemoteDestroyMessage_FAILED_SENDING_0 = new StringIdImpl(4833, "Failed sending < {0} >");
  public static final StringId RemoteInvalidateMessage_NO_RESPONSE_CODE_RECEIVED = new StringIdImpl(4834, "no response code received");
  public static final StringId ReliableReplyProcessor_FAILED_TO_DELIVER_MESSAGE_TO_MEMBERS_0 = new StringIdImpl(4835, "Failed to deliver message to members: {0}");
  public static final StringId RemotePutMessage_DID_NOT_RECEIVE_A_VALID_REPLY = new StringIdImpl(4836, "did not receive a valid reply");
  public static final StringId RemotePutMessage_FAILED_SENDING_0 = new StringIdImpl(4837, "Failed sending < {0} >");
  public static final StringId RemotePutMessage_UNABLE_TO_PERFORM_PUT_BUT_OPERATION_SHOULD_NOT_FAIL_0 = new StringIdImpl(4838, "unable to perform put, but operation should not fail {0}");
  public static final StringId TXState_REGION_CLEAR_NOT_SUPPORTED_IN_A_TRANSACTION = new StringIdImpl(4839,"clear() is not supported while in a transaction");
  public static final StringId PartitionedRegion_TX_FUNCTION_EXECUTION_NOT_COLOCATED_0_1 = new StringIdImpl(4840, "Function execution is not colocated with transaction. The transactional data is hosted on node {0}, but you are trying to target node {1}");
  public static final StringId GemFireCacheImpl_STARTING_GEMFIRE_REDIS_SERVER_ON_BIND_ADDRESS_0_PORT_1 = new StringIdImpl(4841, "Starting GemFireRedisServer on bind address {0} on port {1}"); 
  public static final StringId RemoteFetchEntryMessage_ENTRY_NOT_FOUND = new StringIdImpl(4842, "entry not found");
  public static final StringId RemoteFetchEntryMessage_FAILED_SENDING_0 = new StringIdImpl(4843, "Failed sending < {0} >");
  public static final StringId RemoteFetchEntryMessage_FETCHENTRYRESPONSE_GOT_REMOTE_CACHEEXCEPTION_FORCING_REATTEMPT = new StringIdImpl(4844, "FetchEntryResponse got remote CacheException; forcing reattempt.");
  public static final StringId Dist_TX_PRECOMMIT_NOT_SUPPORTED_IN_A_TRANSACTION = new StringIdImpl(4845,"precommit() operation {0} meant for Dist Tx is not supported");
  public static final StringId Dist_TX_ROLLBACK_NOT_SUPPORTED_IN_A_TRANSACTION = new StringIdImpl(4846,"rollback() operation {0} meant for Dist Tx is not supported");
  public static final StringId AdminDistributedSystemJmxImpl_PROCESSING_CLIENT_MEMBERSHIP_EVENT_0_FROM_1_FOR_2_RUNNING_ON_3 = new StringIdImpl(4847, "Processing client membership event \"{0}\" from {1} for client with id: {2} running on host: {3}");
  public static final StringId AdminDistributedSystemJmxImpl_FAILED_TO_PROCESS_CLIENT_MEMBERSHIP_FROM_0_FOR_1 = new StringIdImpl(4848, "Could not process client membership notification from {0} for client with id {1}.");
  public static final StringId SystemMemberJmx_FAILED_TO_SEND_0_NOTIFICATION_FOR_1 = new StringIdImpl(4849, "Failed to send {0} notification for {1}");
  public static final StringId AgentConfigImpl_FAILED_READING_0_USING_DEFAULT_PROPETIES = new StringIdImpl(4850, "Failed reading {0}, using default properties.");
  public static final StringId AgentConfigImpl_COULD_NOT_FIND_PROPERTIES_FILE_0_USING_DEFAULTS = new StringIdImpl(4851, "Could not find the properties file: \"{0}\". Using default properties ... ");
  public static final StringId DISTTX_TX_EXPECTED = new StringIdImpl(4852,"Expected {0} during a distributed transaction but got {1}");
  public static final StringId PartitionManager_BUCKETID_0_DOES_NOT_EXIST = new StringIdImpl(4853, "The bucket for bucketId {0} does not exist");
  public static final StringId PartitionManager_PROVIDED_MEMBER_0_NO_PR_OR_NO_DATASTORE = new StringIdImpl(4854, "The provided target member {0} either does not have the partitioned region defined, or is not configured to store data for the partitioned region");
  public static final StringId PartitionManager_REGION_0_IS_NOT_A_PARTITIONED_REGION = new StringIdImpl(4855, "Region {0} is not a Partitioned Region");
  public static final StringId PartitionManager_BUCKETID_ARG0_RANGE_0_TO_ARG1_PR_ARG2 = new StringIdImpl(4856, "Bucket id {0} must be in the range 0 to {1} for Partitioned Region {2}");
  public static final StringId PartitionManager_SOURCE_MEMBER_0_BUCKETID_1_DOES_NOT_HAVE_THE_BUCKET = new StringIdImpl(4857, "Source member {0} for bucketId {1} does not have the bucket");
  public static final StringId PartitionManager_BUCKET_CANNOT_BE_MOVED_AS_DESTROYEXISTING_IS_FALSE = new StringIdImpl(4858, "Bucket cannot be on {1} as it already exist on {0} and destroyExisting is false");
  public static final StringId PartitionAttributesFactory_PARTITION_LISTENER_PARAMETER_WAS_NULL = new StringIdImpl(4859, "PartitionListner parameter was null");
  public static final StringId PartitionRegionConfigValidator_INCOMPATIBLE_EXPIRATION_ATTRIBUETS = new StringIdImpl(4860, "The {0} set in RegionAttributes is incompatible with {0} used by other distributed members.");
  public static final StringId PartitionManager_TARGET_MEMBER_0_BUCKETID_1_ALREADY_HAS_BUCKET = new StringIdImpl(4861, "Target member {0} already has the bucket for bucketId {1}");
  public static final StringId PartitionManager_TARGET_MEMBER_0_FOR_BUCKETID_1_DOES_NOT_STORE_BUCKET = new StringIdImpl(4862, "Target member {0} for bucketId {1} does not store the bucket");
  public static final StringId RemoteGfManagerAgent_FAILED_TO_FETCH_LICENSE_INFO_FROM_0 = new StringIdImpl(4863, "Failed to fetch License information from {0}. Check logs for this member.");
  public static final StringId AdminDistributedSystem_ENCOUNTERED_A_0_WHILE_LOADING_STATALERTDEFINITIONS_1_LOADING_ABORTED = new StringIdImpl(4864, "Encountered a {0} while loading StatAlertDefinitions [from {1}]. Loading of statAlertDefinitions has been aborted.");
  public static final StringId AgentConfigImpl_THE_PORT_USED_TO_CONFIGURE_RMI_CONNECTOR_SERVER = new StringIdImpl(4865, "The port on which the RMI Connector Server should start. The value must be in the range: 0-65535.");
  public static final StringId AbstractDistributionConfig_MEMBERSHIP_PORT_RANGE_NAME_0 = new StringIdImpl(4866, "Sets the range of datagram socket ports that can be used for membership ID purposes and unicast datagram messaging. Defaults to {0}.");
  public static final StringId AgentConfigImpl_ALLOWED_RANGE_OF_UDP_PORTS_TO_FORM_UNIQUE_MEMBERSHIP_ID = new StringIdImpl(4867, "The allowed range of UDP ports for use in forming an unique membership identifier. This range is given as two numbers separated by a minus sign.");
  public static final StringId DistributedSystemConfigImpl_INVALID_VALUE_FOR_MEMBERSHIP_PORT_RANGE = new StringIdImpl(4868, "The value specified \"{0}\" is invalid for the property : \"{1}\". This range should be specified as min-max.");

  public static final StringId ServerConnection_SERVER_FAILED_TO_ENCRYPT_DATA_0 = new StringIdImpl(4869, "Server failed to encrpt data {0}" );
  public static final StringId CacheClientProxy__0_NOT_ADDING_CQ_MESSAGE_TO_QUEUE_1_BECAUSE_AUTHORIZATION_FAILED = new StringIdImpl(4870, "{0}: Not Adding CQ message to queue {1} because authorization failed.");
  public static final StringId PoolImpl_POOL_0_STARTED_WITH_MULTIUSER_SECURE_MODE_ENABLED_1 = new StringIdImpl(4871, "Pool {0} started with multiuser-authentication={1}");
  public static final StringId HARegionQueue_ENYTRY_EXPIRY_TASKS_DISABLED_BECAUSE_QUEUE_BECAME_PRIMARY_OLD_MSG_TTL_0 = new StringIdImpl(4872, "Entry expiry tasks disabled because the queue became primary. Old messageTimeToLive was: {0}");
  public static final StringId HARegionQueue_RESUMING_WITH_PROCESSING_PUTS = new StringIdImpl(4873, "Resuming with processing puts ...");
  public static final StringId DISTTX_TXSTATE_RESPONSE_NOT_SUPPORTED_IN_PRECOMMIT_OR_ROLLBACK = new StringIdImpl(4874,"Response to precommit/rollback is supported only in a distributed transaction");
  public static final StringId InternalDistributedSystem_MEMORY_OVERCOMMIT = new StringIdImpl(4875, "Insufficient free memory ({0}) when attempting to lock {1} bytes.  Either reduce the amount of heap or off-heap memory requested or free up additional system memory.  You may also specify -Dgemfire.Cache.ALLOW_MEMORY_OVERCOMMIT=true on the command-line to override the constraint check.");
  public static final StringId InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN = new StringIdImpl(4876, "System memory appears to be over committed by {0} bytes.  You may experience instability, performance issues, or terminated processes due to the Linux OOM killer.");

  // 4877..4883 unused

  public static final StringId BaseCommand__THE_INPUT_KEY_FOR_THE_0_REQUEST_IS_NULL = new StringIdImpl(4884, " The input key for the {0} request is null");
  public static final StringId JGroupMembershipManager_PROBLEM_GENERATING_CACHE_XML = new StringIdImpl(4885, "Unable to generate XML description for reconnect of cache due to exception");
  public static final StringId BaseCommand__THE_INPUT_REGION_NAME_FOR_THE_0_REQUEST_IS_NULL = new StringIdImpl(4886, " The input region name for the {0} request is null");
  public static final StringId BaseCommand__0_WAS_NOT_FOUND_DURING_1_REQUEST = new StringIdImpl(4887, "{0} was not found during {0} request");
  public static final StringId BaseCommand_DURING_0_NO_ENTRY_WAS_FOUND_FOR_KEY_1 = new StringIdImpl(4888, "During {0} no entry was found for key {1}");

  public static final StringId AbstractDistributionConfig_LICENSE_APPLICATION_CACHE_0 = new StringIdImpl(4889, "The value of the application cache serial number. Defaults to \"{0}\".");
  public static final StringId AbstractDistributionConfig_LICENSE_WORKING_DIR_0 = new StringIdImpl(4890, "The license working directory that can be used to persist runtime information. Defaults to \"{0}\".");

  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_INVALIDATE_OPERATION_ON_REGION_0 = new StringIdImpl(4891, "Not authorized to perform INVALIDATE operation on region {0}");

  public static final StringId AbstractDistributionConfig_LICENSE_SERVER_TIMEOUT_0 = new StringIdImpl(4892, "The max time to wait for a license from a vFabric License Server. Defaults to \"{0}\".");

  public static final StringId GemFireCache_INDEX_CREATION_EXCEPTION_1 = new StringIdImpl(4893, "Failed to create index {0} on region {1}");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_GET_DURABLE_CQS_OPERATION_0_ON_THE_CACHE = new StringIdImpl(4894, "Not authorized to perform GET_DURABLE_CQS operation on cache");

  public static final StringId AbstractDistributionConfig_DEPLOY_WORKING_DIR_0 = new StringIdImpl(4895, "The working directory that can be used to persist JARs deployed during runtime. Defaults to \"{0}\".");

  public static final StringId DiskStoreAlreadyInVersion_0 = new StringIdImpl(4896, "This disk store is already at version {0}.");

  public static final StringId DiskStoreStillAtVersion_0 = new StringIdImpl(4897, "This disk store is still at version {0}.");

  public static final StringId AbstractDistributionConfig_ENABLE_SHARED_CONFIGURATION = new StringIdImpl(4898, "Enables cluster configuration support in dedicated locators.  This allows the locator to share configuration information amongst members and save configuration changes made using GFSH.");
  public static final StringId AbstractDistributionConfig_LOAD_SHARED_CONFIGURATION_FROM_DIR = new StringIdImpl(4899,  "Loads cluster configuration from the \"{0}\" directory of a locator. This is property is only applicable to the locator(s)");

  public static final StringId QueueManagerImpl_COULD_NOT_RETRIEVE_LIST_OF_SERVERS_FOR_SUBSCRIPTION_0 = new StringIdImpl(4900, "Could not retrieve the list of servers for subscription. {0}");

  public static final StringId DISTRIBUTED_SYSTEM_RECONNECTING = new StringIdImpl(4901, "Attempting to reconnect to the distributed system.  This is attempt #{0}.");
  public static final StringId AbstractDistributionConfig_USE_SHARED_CONFIGURATION = new StringIdImpl(4902, "Boolean flag that allows the cache to use the cluster configuration provided by the cluster config service");
  public static final StringId GemFireCache_RECEIVED_SHARED_CONFIGURATION_FROM_LOCATORS = new StringIdImpl(4903, "Received cluster configuration from the locator");
  public static final StringId GemFireCache_SHARED_CONFIGURATION_NOT_AVAILABLE = new StringIdImpl(4904, "cluster configuration service not available");
  public static final StringId GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION = new StringIdImpl(4905, "Exception while deploying the jars received as a part of cluster Configuration");
  public static final StringId GemFireCache_NO_LOCATORS_FOUND_WITH_SHARED_CONFIGURATION = new StringIdImpl(4906, "No locator(s) found with cluster configuration service");
  public static final StringId GemFireCache_NOT_USING_SHARED_CONFIGURATION = new StringIdImpl(4907, "The cache has been created with \"use-cluster-configuration=false\". It will not receive any cluster configuration");
  public static final StringId AbstractDistributionConfig_CLUSTER_CONFIGURATION_DIR = new StringIdImpl(4908,  "The directory to store the cluster configuration artifacts and disk-store. This property is only applicable to the locator(s)");
  public static final StringId GemFireCache_INDEX_RECOVERY_EXCEPTION_1 = new StringIdImpl(4909, "Failed to populate indexes after disk recovery on region {0}");
  public static final StringId GemFireCache_INDEX_LOADING = new StringIdImpl(4910, "Loading data into the indexes");
  public static final StringId PoolManagerImpl_GETPENDINGEVENTCOUNT_SHOULD_BE_CALLED_BEFORE_INVOKING_READYFOREVENTS = new StringIdImpl(4911, "getPendingEventCount() should be called before invoking readyForEvents().");
  public static final StringId RemoveAll_THE_INPUT_REGION_NAME_FOR_THE_REMOVEALL_REQUEST_IS_NULL = new StringIdImpl(4912, "The input region name for the removeAll request is null");
  public static final StringId RemoveAll_ONE_OF_THE_INPUT_KEYS_FOR_THE_REMOVEALL_REQUEST_IS_NULL = new StringIdImpl(4913, " One of the input keys for the removeAll request is null");
  public static final StringId AuthorizeRequest_NOT_AUTHORIZED_TO_PERFORM_REMOVEALL_OPERATION_ON_REGION_0 = new StringIdImpl(4914, "Not authorized to perform removeAll operation on region [{0}]");
  public static final StringId AbstractDistributionConfig_OFF_HEAP_MEMORY_SIZE_0 = new StringIdImpl(4915, "The amount of off-heap memory to be allocated for GemFire. Value is <n>[g|m], where <n> is the size and [g|m] specifies the units in gigabytes or megabytes. Defaults to \"{0}\".");
  public static final StringId CacheServerLauncher_CRITICAL_OFF_HEAP_PERCENTAGE =
      new StringIdImpl(4916, "<critical-Off-heap-percentage>  Sets the critical off-heap "
          + "threshold limit of the Resource Manager. This overrides the "
          + "critical-off-heap-percentage set in the <resource-manager> element "
          + "of the \"cache-xml-file\"");
  public static final StringId CacheServerLauncher_EVICTION_OFF_HEAP_PERCENTAGE =
      new StringIdImpl(4917, "<eviction-off-heap-percentage>  Sets the eviction heap "
          + "threshold limit of the Resource Manager above which the eviction "
          + "should begin on Regions configured for eviction by off-heap LRU. "
          + "This overrides the eviction-off-heap-percentage set in the "
          + "<resource-manager> element of the \"cache-xml-file\"");
  public static final StringId CacheServerLauncher_CRITICAL_HEAP_PERCENTAGE =
      new StringIdImpl(4918, "<critical-heap-percentage>  Sets the critical heap "
          + "threshold limit of the Resource Manager. This best works with "
          + "parallel young generation collector (UseParNewGC) and concurrent "
          + "low pause collector (UseConcMarkSweepGC) with appropriate "
          + "CMSInitiatingOccupancyFraction like 50%. This overrides the "
          + "critical-heap-percentage set in the <resource-manager> element "
          + "of the \"cache-xml-file\"");
  public static final StringId CacheServerLauncher_EVICTION_HEAP_PERCENTAGE =
      new StringIdImpl(4919, "<eviction-heap-percentage>  Sets the eviction heap "
          + "threshold limit of the Resource Manager above which the eviction "
          + "should begin on Regions configured for eviction by heap LRU. "
          + "This overrides the eviction-heap-percentage set in the "
          + "<resource-manager> element of the \"cache-xml-file\"");
  public static final StringId AbstractDistributionConfig_LOCK_MEMORY = new StringIdImpl(4920, "Locks heap and off-heap memory pages into RAM, thereby preventing the operating system from swapping them out to disk.");
  public static final StringId CacheServerLauncher_LOCK_MEMORY = new StringIdImpl(4921, "-lock-memory Locks heap and off-heap memory pages into RAM, thereby preventing the operating system from swapping them out to disk.");

  //4922-4999 are now unused 

  public static final StringId CacheXmlParser_NULL_DiskStoreName = new StringIdImpl(5000, "Disk Store name is configured to use null name.");
  public static final StringId CacheXmlParser_A_0_MUST_BE_DEFINED_IN_THE_CONTEXT_OF_REGIONATTRIBUTES_OR_DISKSTORE = new StringIdImpl(5001, "A  {0}  must be defined in the context of region-attributes or disk-store.");
  public static final StringId DiskStoreAttributesCreation_NUMBER_OF_DISKSIZES_IS_0_WHICH_IS_NOT_EQUAL_TO_NUMBER_OF_DISK_DIRS_WHICH_IS_1 = new StringIdImpl(5002, "Number of diskSizes is  {0}  which is not equal to number of disk Dirs which is  {1}");
  public static final StringId DiskStoreAttributesCreation_AUTOCOMPACT_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2 = new StringIdImpl(5003, "AutoCompact of disk store {0} is not the same: this:  {1}  other:  {2}");
  public static final StringId DiskStoreAttributesCreation_COMPACTIONTHRESHOLD_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2 = new StringIdImpl(5004, "CompactionThreshold of disk store {0} is not the same: this:  {1}  other:  {2}");
  public static final StringId DiskStoreAttributesCreation_ALLOWFORCECOMPACTION_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2 = new StringIdImpl(5005, "AllowForceCompaction of disk store {0} is not the same: this:  {1}  other:  {2}");
  public static final StringId SystemAdmin_REMOVE_OPTION_HELP = new StringIdImpl(5006, "Causes the region specified by the -region=<regionName> to be removed from a disk store. Any records in the disk store for this region become garbage and will be deleted from the disk store files if compact-disk-store is called. Note that this option writes to the disk store files so use it with care.");
  public static final StringId DiskStoreAttributesCreation_MAXOPLOGSIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2 = new StringIdImpl(5007, "MaxOpLogSize of disk store {0} is not the same: this:  {1}  other:  {2}");
  public static final StringId DiskStoreAttributesCreation_TIMEINTERVAL_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2 = new StringIdImpl(5008, "TimeInterval of disk store {0} is not the same: this:  {1}  other:  {2}");
  public static final StringId DiskStoreAttributesCreation_WRITEBUFFERSIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2 = new StringIdImpl(5009, "WriteBufferSize of disk store {0} is not the same: this:  {1}  other:  {2}");
  public static final StringId DiskStoreAttributesCreation_QUEUESIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2 = new StringIdImpl(5010, "QueueSize of disk store {0} is not the same: this:  {1}  other:  {2}");
  public static final StringId DiskStoreAttributesCreation_DISK_DIRS_OF_0_ARE_NOT_THE_SAME = new StringIdImpl(5011, "Disk Dirs of disk store {0} are not the same");
  public static final StringId DiskStoreAttributesCreation_DISK_DIR_SIZES_OF_0_ARE_NOT_THE_SAME = new StringIdImpl(5012, "Disk Dir Sizes of disk store {0} are not the same");
  public static final StringId DiskStoreAttributesCreation_0_WAS_NOT_AN_EXISTING_DIRECTORY_FOR_DISKSTORE_1 = new StringIdImpl(5013, "\"{0}\" was not an existing directory for disk store {1}.");
  public static final StringId DiskStoreAttributesCreation_DIR_SIZE_CANNOT_BE_NEGATIVE_0_FOR_DISKSTORE_1 = new StringIdImpl(5014, "Dir size cannot be negative :  {0} for disk store {1}");
  public static final StringId DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1 = new StringIdImpl(5015, "Deprecated API {0} cannot be used with DiskStore {1}");
  public static final StringId PartitionedRegion_REGION_WITH_PRID_0_FAILED_INITIALIZATION_ON_THIS_NODE = new StringIdImpl(5016, "Region with prId= {0}  failed initialization on this node");
  public static final StringId PersistenceAdvisorImpl_MEMBER_REVOKED = new StringIdImpl(5017, "The following persistent member has been revoked:\n{0}");
  public static final StringId CreatePersistentRegionProcessor_DONE_WAITING_FOR_BUCKET_MEMBERS = new StringIdImpl(5018, "Region {0} has successfully completed waiting for other members to recover the latest data.\nMy persistent member information:{1}");
  public static final StringId CreatePersistentRegionProcessor_WAITING_FOR_OFFLINE_BUCKET_MEMBERS = new StringIdImpl(5019, "Region {0} (and any colocated sub-regions) has potentially stale data.  Buckets {1} are waiting for another offline member to recover the latest data.\nMy persistent id is:{2}\nOffline members with potentially new data:\n{3}\nUse the \"gemfire list-missing-disk-stores\" command to see all disk stores that are being waited on by other members.");
  public static final StringId CreatePersistentRegionProcessor_SPLIT_DISTRIBUTED_SYSTEM = new StringIdImpl(5020, "Region {0} remote member {1} with persistent data {2} was not part of the same distributed system as the local data from {3}");
  public static final StringId CreatePersistentRegionProcessor_INITIALIZING_FROM_OLD_DATA = new StringIdImpl(5021, "Region {0} refusing to initialize from member {1} with persistent data {2} which was offline when the local data from {3} was last online");
  public static final StringId CreatePersistentRegionProcessor_WAITING_FOR_LATEST_MEMBER = new StringIdImpl(5022, "Region {0} has potentially stale data. It is waiting for another member to recover the latest data.\nMy persistent id:\n{1}\nMembers with potentially new data:\n{2}\nUse the \"gemfire list-missing-disk-stores\" command to see all disk stores that are being waited on by other members.");
  public static final StringId PersistenceAdvisorImpl_UNABLE_TO_PERSIST_MEMBERSHIP_CHANGE = new StringIdImpl(5023, "Unable to persist membership change");
  public static final StringId DistributedRegion_ERROR_CLEANING_UP_FAILED_INITIALIZATION = new StringIdImpl(5024, "Error cleaning up after failed region initialization of region {0}");
  public static final StringId PartitionedRegionDataStore_DATA_OFFLINE_MESSAGE = new StringIdImpl(5025, "Region {0} bucket {1} has persistent data that is no longer online stored at these locations: {2}");
  public static final StringId PersistenceAdvisorImpl_FINISHING_INCOMPLETE_DESTROY = new StringIdImpl(5026, "Region {0} crashed during a region destroy. Finishing the destroy.");
  public static final StringId CacheCreation_DISKSTORE_NOTFOUND_0 = new StringIdImpl(5027, "Disk store {0} not found");
  public static final StringId FetchEntriesMessage_ERROR_DESERIALIZING_VALUES = new StringIdImpl(5028, "Error deserializing values");
  public static final StringId DistributedRegion_INITIALIZED_FROM_DISK = new StringIdImpl(5030, "Region {0} recovered from the local disk. Old persistent ID: {1}, new persistent ID {2}");
  public static final StringId BackupManager_README = new StringIdImpl(5031, "This directory contains a backup of the persistent data for a single gemfire VM. The layout is:\n\ndiskstores\n\tA backup of the persistent disk stores in the VM\nuser\n\tAny files specified by the backup element in the cache.xml file.\nconfig\n\tThe cache.xml and gemfire.properties for the backed up member.\nrestore.[sh|bat]\n\tA script to restore the backup.\n\nPlease note that the config is not restored, only the diskstores and user files.");
  public static final StringId PartitionedRegion_MULTIPLE_TARGET_NODE_FOUND_FOR = new StringIdImpl(5032, "Multiple target nodes found for single hop operation");
  public static final StringId CqQueryImpl_Null_CQ_Result_Key_Cache_0 = new StringIdImpl(5033, "The CQ Result key cache is Null. This should not happen as the call to isPartOfCqResult() is based on the condition cqResultsCacheInitialized.");
  public static final StringId TXState_DELTA_WITHOUT_CLONING_CANNOT_BE_USED_IN_TX = new StringIdImpl(5034, "Delta without cloning cannot be used in transaction");
  public static final StringId SearchLoadAndWriteProcessor_UNEXPECTED_EXCEPTION = new StringIdImpl(5035, "Unexpected exception creating net search reply");
  public static final StringId FunctionService_FUNCTION_ATTRIBUTE_MISMATCH  = new StringIdImpl(5036, "For Functions with isHA true, hasResult must also be true.");
  public static final StringId FunctionService_FUNCTION_ATTRIBUTE_MISMATCH_CLIENT_SERVER  = new StringIdImpl(5037, "Function attributes at client and server don''t match");
  public static final StringId Region_PutAll_Applied_PartialKeys_0_1 = new StringIdImpl(5038, "Region {0} putAll: {1}");
  public static final StringId Region_PutAll_Applied_PartialKeys_At_Server_0 = new StringIdImpl(5039, "Region {0} putAll at server applied partial keys due to exception.");
  public static final StringId BucketPersistenceAdvisor_WAITING_FOR_LATEST_MEMBER = new StringIdImpl(5040, "Region {0}, bucket {1} has potentially stale data.  It is waiting for another member to recover the latest data.\nMy persistent id:\n{2}\nMembers with potentially new data:\n{3}\nUse the \"gemfire list-missing-disk-stores\" command to see all disk stores that are being waited on by other members.");

  public static final StringId AgentConfigImpl_TCP_PORT = new StringIdImpl(5041, "TCP/IP port number to use in the agent''s distributed system");

  public static final StringId PartitionRegionConfigValidator_CACHE_LOADER_IS_NULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE = new StringIdImpl(5042, "Incompatible CacheLoader. CacheLoader is null in partitionedRegion {0} on another datastore.");
  public static final StringId PartitionRegionConfigValidator_CACHE_LOADER_IS_NOTNULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE = new StringIdImpl(5043, "Incompatible CacheLoader. CacheLoader is not null in partitionedRegion {0} on another datastore.");
  public static final StringId PartitionRegionConfigValidator_CACHE_WRITER_IS_NULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE = new StringIdImpl(5044, "Incompatible CacheWriter. CacheWriter is null in partitionedRegion {0} on another datastore.");
  public static final StringId PartitionRegionConfigValidator_CACHE_WRITER_IS_NOTNULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE = new StringIdImpl(5045, "Incompatible CacheWriter. CacheWriter is not null in partitionedRegion {0} on another datastore.");

  public static final StringId PutAllOp_Retry_OtherException_0 = new StringIdImpl(5049, "PutAllOp : Retry failed with exception. Send back the saved succeeded keys: {0}");
  public static final StringId CacheServerLauncher_SERVER_PORT = new StringIdImpl(5050, "<server-port>  Port the server is to listen on for client connections. This overrides the port set in the <cache-server> element of the \"cache-xml-file\"");
  public static final StringId CacheServerLauncher_SERVER_BIND_ADDRESS = new StringIdImpl(5051, "<server-bind-address>  Address the server is to listen on for client connections. This overrides the bind-address set in the <cache-server> element of the \"cache-xml-file\"");
  public static final StringId CacheServerLauncher_SERVER_PORT_MORE_THAN_ONE_CACHE_SERVER = new StringIdImpl(5052,"When using \"-server-port\" or \"-server-bind-address\" arguments, the \"cache-xml-file\" can not have more than one cache-server defined.");
  public static final StringId MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0 = new StringIdImpl(5053, "Exception occurred for operation: {0}");
  public static final StringId MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1 = new StringIdImpl(5054, "Exception occurred for operation: {0} for member: {1}");
  public static final StringId MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING = new StringIdImpl(5055, "Exception occurred while intializing.");
  public static final StringId MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING_0_CONTINUING = new StringIdImpl(5056, "Exception occurred while intializing : {0}. Contiuning with next  ...");
  public static final StringId MemberInfoWithStatsMBean_EXCEPTION_WHILE_REGISTERING_NOTIFICATION_LISTENER_FOR_0 = new StringIdImpl(5057, "Exception while registering notification listener for: {0}");
  public static final StringId MemberInfoWithStatsMBean_EXCEPTION_WHILE_UNREGISTERING_NOTIFICATION_LISTENER_FOR_0 = new StringIdImpl(5058, "Exception while unregistering notification listener for: {0}");
  public static final StringId AgentImpl_FAILED_TO_INITIALIZE_MEMBERINFOWITHSTATSMBEAN = new StringIdImpl(5059, "Failed to initialize MemberInfoWithStatsMBean.");


  public static final StringId PoolManagerImpl_ONLY_DURABLE_CLIENTS_SHOULD_CALL_READYFOREVENTS = new StringIdImpl(5060, "Only durable clients should call readyForEvents()");
  public static final StringId LocalRegion_DURABLE_FLAG_ONLY_APPLICABLE_FOR_DURABLE_CLIENTS = new StringIdImpl(5061, "Durable flag only applicable for durable clients.");
  public static final StringId DistributedRegion_NEW_PERSISTENT_REGION_CREATED = new StringIdImpl(5062, "Region {0} was created on this member with the persistent id {1}.");
  public static final StringId InitialImageOperation_REGION_0_INITIALIZED_PERSISTENT_REGION_WITH_ID_1_FROM_2 = new StringIdImpl(5063, "Region {0} initialized persistent id: {1} with data from {2}.");
  public static final StringId MemberInfoWithStatsMBean_EXCEPTION_WHILE_INITIALIZING_STATISICS_FOR_0 = new StringIdImpl(5064, "Exception while initializing statistics for: {0}");
  public static final StringId MemberInfoWithStatsMBean_REINITIALIZING_STATS_FOR_0 = new StringIdImpl(5065, "Re-initializing statistics for: {0}");

  public static final StringId PartitionAttributesImpl_FIXED_PARTITION_NAME_CANNOT_BE_NULL = new StringIdImpl(5066, "Fixed partition name cannot be null");
  public static final StringId PartitionAttributesImpl_PARTITION_NAME_0_CAN_BE_ADDED_ONLY_ONCE_IN_FIXED_PARTITION_ATTRIBUTES = new StringIdImpl(5067, "Partition name \"{0}\" can be added only once in FixedPartitionAttributes");
  public static final StringId PartitionedRegionConfigValidator_FOR_REGION_0_SAME_PARTITION_NAME_1_CANNOT_BE_DEFINED_AS_PRIMARY_ON_MORE_THAN_ONE_NODE = new StringIdImpl(5068, "For region \"{0}\", same partition name \"{1}\" can not be defined as primary on more than one node.");
  public static final StringId PartitionAttributesImpl_FIXED_PARTITION_ATTRBUTES_0_CANNOT_BE_DEFINED_FOR_ACCESSOR = new StringIdImpl(5069, "FixedPartitionAttributes \"{0}\" can not be defined for accessor");
  public static final StringId PartitionedRegionConfigValidator_FOR_REGION_0_NUMBER_OF_SECONDARY_PARTITIONS_1_OF_A_PARTITION_2_SHOULD_NEVER_EXCEED_NUMBER_OF_REDUNDANT_COPIES_3 = new StringIdImpl(5070, "For region \"{0}\", number of secondary partitions {1} of a partition \"{2}\" should never exceed number of redundant copies {3}.");
  public static final StringId PartitionedRegionConfigValidator_FOR_REGION_0_SUM_OF_NUM_BUCKETS_1_FOR_DIFFERENT_PRIMARY_PARTITIONS_SHOULD_NOT_BE_GREATER_THAN_TOTAL_NUM_BUCKETS_2 = new StringIdImpl(5071, "For region \"{0}\",sum of num-buckets {1} for different primary partitions should not be greater than total-num-buckets {2}.");
  public static final StringId FOR_FIXED_PARTITION_REGION_0_PARTITION_1_IS_NOT_YET_INITIALIZED_ON_DATASTORE = new StringIdImpl(5072, "For FixedPartitionedRegion \"{0}\", Partition \"{1}\" is not yet initialized on datastore");
  public static final StringId AbstractDistributionConfig_MEMCACHED_PROTOCOL_MUST_BE_ASCII_OR_BINARY = new StringIdImpl(5073, "memcached-protocol must be \"ASCII\" or \"BINARY\" ");

  public static final StringId Disk_Store_Exception_During_Cache_Close = new StringIdImpl(5074, "Cache close caught an exception during disk store close");
  public static final StringId PoolManagerImpl_ONLY_DURABLE_CLIENTS_SHOULD_CALL_GETPENDINGEVENTCOUNT = new StringIdImpl(5075, "Only durable clients should call getPendingEventCount()");
  public static final StringId PartitionAttributesImpl_IF_COLOCATED_WITH_IS_SPECFIED_THEN_FIXED_PARTITION_ATTRIBUTES_CAN_NOT_BE_SPECIFIED = new StringIdImpl(5077, "FixedPartitionAttributes \"{0}\" can not be specified in PartitionAttributesFactory if colocated-with is specified. ");
  public static final StringId PartitionedRegionHelper_FOR_REGION_0_FOR_PARTITION_1_PARTITIION_NUM_BUCKETS_ARE_SET_TO_0_BUCKETS_CANNOT_BE_CREATED_ON_THIS_MEMBER = new StringIdImpl(5078, "For region \"{0}\", For partition \"{1}\" partition-num-buckets is set to 0. Buckets cann not be created on this partition.");
  public static final StringId PartitionedRegionHelper_FOR_REGION_0_PARTITION_NAME_1_IS_NOT_AVAILABLE_ON_ANY_DATASTORE = new StringIdImpl(5079, "For region \"{0}\", partition name \"{1}\" is not available on any datastore.");
  public static final StringId PartitionedRegionHelper_FOR_REGION_0_PARTITIONRESOLVER_1_RETURNED_PARTITION_NAME_NULL = new StringIdImpl(5080, "For region \"{0}\", partition resolver {1} returned partition name null");
  public static final StringId PartitionedRegionConfigValidator_FOR_REGION_0_FOR_PARTITION_1_NUM_BUCKETS_ARE_NOT_SAME_ACROSS_NODES = new StringIdImpl(5081, "For region \"{0}\",for partition \"{1}\", num-buckets are not same ({2}, {3})across nodes.");
  public static final StringId PartitionedRegionHelper_FOR_FIXED_PARTITIONED_REGION_0_FIXED_PARTITION_RESOLVER_IS_NOT_AVAILABLE = new StringIdImpl(5082, "For FixedPartitionedRegion \"{0}\", FixedPartitionResolver is not available (neither through the partition attribute partition-resolver nor key/callbackArg implementing FixedPartitionResolver)");
  public static final StringId PartitionedRegionHelper_FOR_FIXED_PARTITIONED_REGION_0_RESOLVER_DEFINED_1_IS_NOT_AN_INSTANCE_OF_FIXEDPARTITIONRESOLVER = new StringIdImpl(5083, "For FixedPartitionedRegion \"{0}\", Resolver defined {1} is not an instance of FixedPartitionResolver");
  public static final StringId PartitionedRegionHelper_FOR_FIXED_PARTITIONED_REGION_0_FIXED_PARTITION_IS_NOT_AVAILABLE_FOR_BUCKET_1_ON_ANY_DATASTORE = new StringIdImpl(5084, "For FixedPartitionedRegion \"{0}\", Fixed partition is not defined for bucket id {1} on any datastore");
  public static final StringId PartitionedRegionConfigValidator_FIXED_PARTITION_REGION_ONE_DATASTORE_IS_WITHOUTFPA = new StringIdImpl(5085, "Region \"{0}\" uses fixed partitioning but at least one datastore node (localMaxMemory > 0) has no fixed partitions. Please make sure that each datastore creating this region is configured with at least one fixed partition.");
  public static final StringId FixedPartitionManager_BUCKETID_ARG_PR_ARG2 = new StringIdImpl(5086, "Bucket id {0} is not part of any primary partition on this node for the FixedPartitionRegion {1}.");
  public static final StringId LocalDataSet_THE_FOLLOWING_EXCEPTION_OCCURRED_ATTEMPTING_TO_GET_KEY_0 = new StringIdImpl(5087, "The following exception occurred attempting to get key={0}");
  public static final StringId PartitionRegionHelper_ARGUMENT_REGION_IS_NULL= new StringIdImpl(5088, "Argument ''Region'' is null");
  public static final StringId PartitionedRegionHelper_FOR_FIXED_PARTITIONED_REGION_0_FIXED_PARTITION_1_IS_NOT_AVAILABLE_ON_ANY_DATASTORE = new StringIdImpl(5089, "For FixedPartitionedRegion \"{0}\", partition \"{1}\" is not available on any datastore.");
  public static final StringId CacheServerLauncher_DISABLE_DEFAULT_SERVER = new StringIdImpl(5090, "-disable-default-server  Do not add a default <cache-server>");
  public static final StringId Oplog_REMOVING_INCOMPLETE_KRF = new StringIdImpl(5091, "Removing incomplete krf {0} for oplog {1}, disk store \"{2}\"");
  public static final StringId PlaceHolderDiskRegion_A_DISKACCESSEXCEPTION_HAS_OCCURED_WHILE_RECOVERING_FROM_DISK = new StringIdImpl(5092, "A DiskAccessException has occurred while recovering values asynchronously from disk for region {0}.");
  public static final StringId PartitionedRegion_FOR_REGION_0_TotalBucketNum_1_SHOULD_NOT_BE_CHANGED_Previous_Configured_2 = new StringIdImpl(5093, "For partition region \"{0}\",total-num-buckets {1} should not be changed. Previous configured number is {2}.");
  public static final StringId GatewayImpl_UnknownHost = new StringIdImpl(5094, "Unknown Host");
  public static final StringId PR_CONTAINSVALUE_WARNING = new StringIdImpl(5095, "PR containsValue warning. Got an exception while executing function");
  public static final StringId MultiUserSecurityEnabled_USE_POOL_API = new StringIdImpl(5096,"Use Pool APIs for doing operations when multiuser-secure-mode-enabled is set to true.");
  public static final StringId SystemMemberJmxImpl_EXCEPTION_OCCURRED_WHILE_INITIALIZING_0_MBEANS_FOR_1 = new StringIdImpl(5097, "Exception occurred while initializing {0} MBean for member: {1}");
  public static final StringId SystemMemberJmxImpl_CACHE_INSTANCE_NOT_FOUND_IN_0 = new StringIdImpl(5098, "Cache instance not found in {0}");
  public static final StringId GetFunctionAttribute_THE_INPUT_0_FOR_GET_FUNCTION_ATTRIBUTE_REQUEST_IS_NULL = new StringIdImpl(5099, "The input {0} for GetFunctionAttributes request is null");
  public static final StringId GetFunctionAttribute_THE_FUNCTION_IS_NOT_REGISTERED_FOR_FUNCTION_ID_0 = new StringIdImpl(5100, "The function is not registered for function id {0}");
  public static final StringId CacheXmlPropertyResolver_UNSEROLVAVLE_STRING_FORMAT_ERROR__0 = new StringIdImpl(5101, "Format of the string \"{0}\" used for perameterization is unresolvable");
  public static final StringId CacheXmlPropertyResolverHelper_SOME_UNRESOLVED_STRING_REPLACED_CIRCULAR_ERROR__0 = new StringIdImpl(5102, "Some still unresolved string \"{0}\"was replaced by resolver, leading to circular references.");
  public static final StringId AgentLauncher_UNABLE_TO_DELETE_FILE_0 = new StringIdImpl(5103,"Unable to delete file {0}.");
  public static final StringId AgentLauncher_0_IS_NOT_RUNNING_IN_SPECIFIED_WORKING_DIRECTORY_1 = new StringIdImpl(5104,"{0} is not running in the specified working directory: ({1}).");
  public static final StringId AgentLauncher_SEE_LOG_FILE_FOR_DETAILS = new StringIdImpl(5105, "See log file for details.");
  public static final StringId AgentLauncher_SHUTDOWN_PENDING_AFTER_FAILED_STARTUP = new StringIdImpl(5106, "shutdown pending after failed startup");
  public static final StringId MBeanUtil_MBEAN_SERVER_NOT_INITIALIZED_YET = new StringIdImpl(5107, "MBean Server is not initialized yet.");
  public static final StringId MBeanUtil_FAILED_TO_FIND_0 = new StringIdImpl(5108, "Failed to find {0}");
  public static final StringId MBeanUtil_FAILED_TO_LOAD_0 = new StringIdImpl(5109, "Failed to load metadata from {0}");
  public static final StringId MBeanUtil_COULDNT_FIND_MBEAN_REGISTERED_WITH_OBJECTNAME_0 = new StringIdImpl(5110, "Could not find a MBean registered with ObjectName: {0}.");
  public static final StringId MBeanUtil_COULD_NOT_FIND_REGISTERED_REFRESHTIMER_INSTANCE = new StringIdImpl(5111, "Could not find registered RefreshTimer instance.");
  public static final StringId MBeanUtil_FAILED_TO_CREATE_REFRESH_TIMER = new StringIdImpl(5112, "Failed to create/register/start refresh timer.");
  public static final StringId MBeanUtil_FAILED_TO_REGISTER_SERVERNOTIFICATIONLISTENER = new StringIdImpl(5113, "Failed to register ServerNotificationListener.");
  public static final StringId AbstractDistributionConfig_USERDEFINED_PREFIX_NAME = new StringIdImpl(5114, "Prefix for \"user defined\" properties which are used for replacements in Cache.xml. Neither key nor value can be NULL. Legal tags can be [custom-any-string] and Legal values can be any string data.");
  public static final StringId DataSerializer_COULD_NOT_DESERIALIZE_PDX_INSTANCE_WITH_STREAM_0 = new StringIdImpl(5115, "Could not deserialize PDX instance with stream {0}");
  public static final StringId DataSerializer_COULD_NOT_CREATE_AN_INSTANCE_OF_A_CLASS_0 = new StringIdImpl(5116, "Could not create an instance of a class {0}");
  public static final StringId StartupMessage_REJECTED_NEW_SYSTEM_NODE_0_BECAUSE_DISTRIBUTED_SYSTEM_ID_1_DOES_NOT_MATCH_THE_DISTRIBUTED_SYSTEM_2_IT_IS_ATTEMPTING_TO_JOIN = new StringIdImpl(5117, "Rejected new system node {0} because distributed-system-id={1} does not match the distributed system {2} it is attempting to join.");
  public static final StringId CacheXmlParser_A_0_IS_NOT_AN_INSTANCE_OF_A_PDX_SERIALIZER = new StringIdImpl(5118, "A  {0}  is not an instance of a PdxSerializer.");
  public static final StringId DistributionManager_RUNNING_IN_VMWARE_VM = new StringIdImpl(5119, "This member is running in a VMWare VM. Using physical host token {0} for redundancy zone");
  public static final StringId MBeanUtil_FAILED_WHILE_UNREGISTERING_MBEAN_WITH_OBJECTNAME_0 = new StringIdImpl(5120, "Failed while unregistering MBean with ObjectName : {0}");
  public static final StringId MBeanUtil_WHILE_UNREGISTERING_COULDNT_FIND_MBEAN_WITH_OBJECTNAME_0 = new StringIdImpl(5121, "While unregistering, could not find MBean with ObjectName : {0}");
  public static final StringId MBeanUtil_COULD_NOT_UNREGISTER_MBEAN_WITH_OBJECTNAME_0 = new StringIdImpl(5122, "Could not un-register MBean with ObjectName : {0}");
  public static final StringId AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_REQUEST_REJECTED_BY_POOL = new StringIdImpl(5123, "Rejected connection from {0} because incoming request was rejected by pool possibly due to thread exhaustion");
  public static final StringId GatewayImpl_GATEWAY_SOCKET_READ_TIMEOUT_DISABLED = new StringIdImpl(5124, "Setting the socket read timeout on a gateway is currently disabled. Please contact Pivotal support for assistance.");
  public static final StringId EXECUTE_FUNCTION_NO_HAS_RESULT_RECEIVED_EXCEPTION = new StringIdImpl(5125, "Function execution without result encountered an Exception on server.");
  public static final StringId ConnectionFactoryImpl_POOL_0_IS_NOT_AVAILABLE = new StringIdImpl(5126, "Pool {0} is not available");
  public static final StringId CreateRegionProcessor_CANNOT_CREATE_REGION_0_WITH_OFF_HEAP_EQUALS_1_BECAUSE_ANOTHER_CACHE_2_HAS_SAME_THE_REGION_WITH_OFF_HEAP_EQUALS_3 = new StringIdImpl(5128, "Cannot create region {0} with off-heap={1} because another cache ({2}) has the same region with off-heap={3}.");

  public static final StringId ConnectionTable_OUT_OF_FILE_DESCRIPTORS_USING_SHARED_CONNECTION = new StringIdImpl(5129, "This process is out of file descriptors.\nThis will hamper communications and slow down the system.\nAny conserve-sockets setting is now being ignored.\nPlease consider raising the descriptor limit.\nThis alert is only issued once per process.");
  public static final StringId DistributedRegion_INITIALIZING_REGION_0 = new StringIdImpl(5130, "Initializing region {0}");

  public static final StringId CacheXmlParser_CACHEXMLPARSERENDINDEXINDEX_CREATION_ATTRIBUTE_NOT_CORRECTLY_SPECIFIED = new StringIdImpl(5131, "CacheXmlParser::endIndex:Index creation attribute not correctly specified.");
  //OK to reuse 5132
  public static final StringId GatewayParallel_0_CREATED_1_GATEWAYS_2 = new StringIdImpl(5133, "{0}: Created {1} parallel gateways named {2}");
  public static final StringId CacheXmlParser_UNKNOWN_GATEWAY_ORDER_POLICY_0_1 = new StringIdImpl(5134, "An invalid order-policy value ({1}) was configured for gateway {0}");
  public static final StringId CacheXmlParser_INVALID_GATEWAY_ORDER_POLICY_CONCURRENCY_0 = new StringIdImpl(5135, "The \"order-policy\" attribute configured for gateway {0} is only valid when the \"concurrency-level\" attribute is also configured.");
  public static final StringId DefaultQuery_FUNCTIONCONTEXT_CANNOT_BE_NULL = new StringIdImpl(5136, "''Function Context'' cannot be null");
  public static final StringId BucketPersistenceAdvisor_ERROR_RECOVERYING_SECONDARY_BUCKET_0 = new StringIdImpl(5137, "Unable to recover secondary bucket from disk for region {0} bucket {1}");
  public static final StringId FunctionService_EXCEPTION_ON_LOCAL_NODE = new StringIdImpl(5138, "Exception occured on local node while executing Function:");
  public static final StringId AbstractIndex_WRONG_COMPARETO_IMPLEMENTATION_IN_INDEXED_OBJECT_0 = new StringIdImpl(5139, "Indexed object''s class {0} compareTo function is errorneous.");
  public static final StringId DefaultQuery_API_ONLY_FOR_PR = new StringIdImpl(5140, "This query API can only be used for Partition Region Queries.");
  public static final StringId MailManager_REQUIRED_MAILSERVER_CONFIGURATION_NOT_SPECIFIED = new StringIdImpl(5141, "Required mail server configuration is not specfied.");
  public static final StringId DiskStoreImpl_CreatedDiskStore_0_With_Id_1 = new StringIdImpl(5142, "Created disk store {0} with unique id {1}");
  public static final StringId DiskStoreImpl_RecoveredDiskStore_0_With_Id_1 = new StringIdImpl(5143, "Recovered disk store {0} with unique id {1}");
  public static final StringId PersistentMemberManager_Member_0_is_already_revoked = new StringIdImpl(5144, "The persistent member id {0} has been revoked in this distributed system. You cannot recover from disk files which have been revoked.");
  public static final StringId RevokeFailedException_Member_0_is_already_running_1 = new StringIdImpl(5145, "Member {0} is already running with persistent files matching {1}. You cannot revoke the disk store of a running member.");
  public static final StringId GatewayImpl_GATEWAY_FAILOVER_INITIATED_ADDING_0_UNPROCESSED_EVENTS = new StringIdImpl(5146, "Gateway Failover Initiated: Adding {0} unprocessed events to the queue.");
  public static final StringId GatewayImpl_GATEWAY_FAILOVER_COMPLETED = new StringIdImpl(5147, "Gateway Failover Completed");

  public static final StringId CacheXmlParser_A_0_MUST_BE_DEFINED_IN_THE_CONTEXT_OF_GATEWAY_SENDER = new StringIdImpl(5148, "A  {0}  must be defined in the context of gateway-sender.");
  public static final StringId GemFireCache_A_GATEWAYSENDER_WITH_ID_0_IS_ALREADY_DEFINED_IN_THIS_CACHE = new StringIdImpl(5149, "A GatewaySender with id  {0}  is already defined in this cache.");
  public static final StringId AttributesFactory_GATEWAY_SENDER_ID_IS_NULL = new StringIdImpl(5150, "GatewaySender id is null.");
  public static final StringId ParallelGatewaySenderImpl_STARTED__0 = new StringIdImpl(5165, "Started  {0}");
  public static final StringId RVV_LOCKING_CONFUSED = new StringIdImpl(5166, "Request from {0} to block operations found that operations are already blocked by member {1}.");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_REMOTE_DS_ID_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_2_REMOTE_DS_ID = new StringIdImpl(5167, "Cannot create Gateway Sender \"{0}\" with remote ds id \"{1}\" because another cache has the same Gateway Sender defined with remote ds id \"{2}\".");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_AS_PARALLEL_GATEWAY_SENDER_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_AS_SERIAL_GATEWAY_SENDER = new StringIdImpl(5168, "Cannot create Gateway Sender \"{0}\" as parallel gateway sender because another cache has the same sender as serial gateway sender");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_AS_SERIAL_GATEWAY_SENDER_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_AS_PARALLEL_GATEWAY_SENDER = new StringIdImpl(5169, "Cannot create Gateway Sender \"{0}\" as serial gateway sender because another cache has the same sender as parallel gateway sender");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_IS_BACTH_CONFLATION_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_IS_BATCH_CONFLATION_2 = new StringIdImpl(5170, "Cannot create Gateway Sender \"{0}\" with isBatchConflationEnabled \"{1}\" because another cache has the same Gateway Sender defined with isBatchConfaltionEnabled \"{2}\"");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_IS_PERSISTENT_ENABLED_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_IS_PERSISTENT_ENABLED_2 = new StringIdImpl(5171, "Cannot create Gateway Sender \"{0}\" with isPersistentEnabled \"{1}\" because another cache has the same Gateway Sender defined with isPersistentEnabled \"{2}\"");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_ALERT_THRESHOLD_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_ALERT_THRESHOLD_2 = new StringIdImpl(5172, "Cannot create Gateway Sender \"{0}\" with alertThreshold \"{1}\" because another cache has the same Gateway Sender defined with alertThreshold \"{2}\"");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_MANUAL_START_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_MANUAL_START_2 = new StringIdImpl(5173, "Cannot create Gateway Sender \"{0}\" with manual start \"{1}\" because another cache has the same Gateway Sender defined with manual start \"{2}\"");
  public static final StringId GatewaySenderAdvisor_GATEWAY_EVENT_FILTERS_MISMATCH = new StringIdImpl(5174, "Cannot create Gateway Sender \"{0}\" with GatewayEventFilters \"{1}\" because another cache has the same Gateway Sender defined with GatewayEventFilters \"{2}\"");
  public static final StringId GatewaySenderAdvisor_GATEWAY_TRANSPORT_FILTERS_MISMATCH = new StringIdImpl(5175, "Cannot create Gateway Sender \"{0}\" with GatewayTransportFilters \"{1}\" because another cache has the same Gateway Sender defined with GatewayTransportFilters \"{2}\"");
  public static final StringId GatewaySenderAdvisor_GATEWAY_SENDER_LISTENER_MISMATCH = new StringIdImpl(5176, "Cannot create Gateway Sender \"{0}\" with AsyncEventListeners \"{1}\" because another cache has the same Gateway Sender defined with AsyncEventListener \"{2}\"");
  public static final StringId GatewaySenderAdvisor_GATEWAY_SENDER_IS_DISK_SYNCHRONOUS_MISMATCH = new StringIdImpl(5177, "Cannot create Gateway Sender \"{0}\" with isDiskSynchronous \"{1}\" because another cache has the same Gateway Sender defined with isDiskSynchronous \"{2}\"");
  public static final StringId PartitionRegion_NON_COLOCATED_REGIONS_1_2_CANNOT_HAVE_SAME_PARALLEL_GATEWAY_SENDER_ID_2 = new StringIdImpl(5178, "Non colocated regions \"{0}\", \"{1}\" cannot have the same parallel {2} id \"{3}\" configured." );
  public static final StringId LocalRegion_GATEWAY_SENDER_0_IS_NOT_SERIAL_GATEWAY_SENDER = new StringIdImpl(5179, "Gateway Sender \"{0}\" is not Serial Gateway Sender" );
  public static final StringId LocalRegion_GATEWAY_SENDER_0_IS_NOT_PARALLEL_GATEWAY_SENDER = new StringIdImpl(5180, "Gateway Sender \"{0}\" is not Parallel Gateway Sender" );
  public static final StringId ParallelGatewaySenderImpl_NOTSTARTED_ON_ACCESSOR_NODE = new StringIdImpl(5181, "{0}  could not be started on accessor node" );
  public static final StringId GatewayReceiver_STARTED_ON_PORT = new StringIdImpl(5182, "The GatewayReceiver started on port : {0}" );
  public static final StringId GatewayReceiver_Address_Already_In_Use = new StringIdImpl(5183, "The GatewayReceiver port \"{0}\" is already in use" );
  public static final StringId GatewaySenderImpl_GATEWAY_0_CANNOT_BE_CREATED_WITH_REMOTE_SITE_ID_EQUAL_TO_THIS_SITE_ID = new StringIdImpl(5184, "GatewaySender {0} cannot be created with remote DS Id equal to this DS Id. ");

  public static final StringId AbstractDistributionConfig_REMOTE_DISTRIBUTED_SYSTEMS_NAME_0 = new StringIdImpl(5185, "A possibly empty list of locators used to find other distributed systems. Each element of the list must be a host name followed by bracketed, \"[]\", port number. Host names may be followed by a colon and a bind address used by the locator on that host.  Multiple elements must be comma seperated. Defaults to \"{0}\".");
  public static final StringId SerialGatewaySenderImpl_0__BECOMING_PRIMARY_GATEWAYSENDER = new StringIdImpl(5186, "{0} : Becoming primary gateway sender");
  public static final StringId AbstractGatewaySender_REMOTE_LOCATOR_FOR_REMOTE_SITE_0_IS_NOT_AVAILABLE_IN_LOCAL_LOCATOR_1 = new StringIdImpl(5187, "Remote locator host port information for remote site \"{0}\" is not available in local locator \"{1}\".");
  public static final StringId ParallelGatewaySenderImpl_PARALLEL_DISPATCHER_IS_NOT_YET_RUNNING = new StringIdImpl(5188, "Parallel Dispatcher is not yet running");
  public static final StringId GATEWAYSENDER_0_IS_GETTING_INITIALIZED_EVENT_1_WILL_NOT_BE_DISTRIBUTED_THROUGH_GATEWAYSENDER = new StringIdImpl(5189, "Gateway Sender {0} is getting initialized. Event {1} will bot be distributed through gateway sender");
  public static final StringId AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION = new StringIdImpl(5190, "Adding Parallel Gateway Sender {0} on distributed region is not allowed");
  public static final StringId CreateRegionProcessor_CANNOT_CREATE_REGION_0_WITH_1_GATEWAY_SENDER_IDS_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_GATEWAY_SENDER_IDS = new StringIdImpl(5191, "Cannot create Region {0} with {1} gateway sender ids because another cache has the same region defined with {2} gateway sender ids");
  public static final StringId GatewaySender_SENDER_0_IS_ALREADY_RUNNING = new StringIdImpl(5192, "Gateway Sender {0} is already running");
  public static final StringId LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2 = new StringIdImpl(5193, "Locator discovery task could not exchange locator information {0} with {1} after {2} retry attempts.");
  public static final StringId LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2_RETRYING_IN_3_MS = new StringIdImpl(5194, "Locator discovery task could not exchange locator information {0} with {1} after {2} retry attempts. Retrying in {3} ms.");
  public static final StringId LOCATOR_DISCOVERY_TASK_ENCOUNTERED_UNEXPECTED_EXCEPTION = new StringIdImpl(5195, "Locator discovery task encountred unexpected exception");
  public static final StringId LOCATOR_MEMBERSHIP_LISTENER_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_1_WIHT_2_3 = new StringIdImpl(5196, "Locator Membership listener could not exchange locator information {0}:{1} with {2}:{3}");
  public static final StringId SerialGatewaySenderImpl_GATEWAY_0_CANNOT_DEFINE_A_REMOTE_SITE_BECAUSE_AT_LEAST_ONE_LISTENER_IS_ALREADY_ADDED = new StringIdImpl(5197, "SerialGatewaySener  {0}  cannot define a remote site because at least AsyncEventListener is already added. Both listeners and remote site cannot be defined for the same gateway sender.");
  public static final StringId SerialGatewayEventCallbackDispatcher_STOPPING_THE_PROCESSOR_BECAUSE_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_PROCESSING_A_BATCH = new StringIdImpl(5198, "Stopping the processor because the following exception occurred while processing a batch:");
  public static final StringId SerialGatewayEventCallbackDispatcher__0___EXCEPTION_DURING_PROCESSING_BATCH__1_ = new StringIdImpl(5199, "{0}: Exception during processing batch {1}");
  public static final StringId GatewaySenderImpl_GATEWAY_0_CANNOT_BE_CREATED_WITH_REMOTE_SITE_ID_LESS_THAN_ZERO = new StringIdImpl(5200, "GatewaySender {0} cannot be created with remote DS Id less than 0. ");
  public static final StringId CacheXmlParser_A_0_MUST_BE_DEFINED_IN_THE_CONTEXT_OF_GATEWAYSENDER_OR_GATEWAYRECEIVER = new StringIdImpl(5201, "A  {0}  must be defined in the context of gateway-sender or gateway-receiver.");
  public static final StringId Sender_COULD_NOT_START_GATEWAYSENDER_0_BECAUSE_OF_EXCEPTION_1 = new StringIdImpl(5202, "Could not start a gateway sender {0} because of exception {1}");
  public static final StringId LOCATOR_DISCOVERY_TASK_EXCHANGED_LOCATOR_INFORMATION_0_WITH_1 = new StringIdImpl(5203, "Locator discovery task exchanged locator information {0} with {1}.");
  public static final StringId CacheCreation_WHILE_STARTING_GATEWAY_RECEIVER_0 = new StringIdImpl(5204, "While starting gateway receiver  {0}");
  public static final StringId DistributionManager_RECEIVED_NO_STARTUP_RESPONSES_BUT_OTHER_MEMBERS_EXIST_MULTICAST_IS_NOT_RESPONSIVE = new StringIdImpl(5205, "Did not receive a startup response but other members exist.  Multicast does not seem to be working.");
  public static final StringId REGION_VERSION_ROLLOVER_DETECTED = new StringIdImpl(5206, "Region version rollover has been detected.  Persistent stores cannot handle rollover and must be reset");
  public static final StringId PartitionedRegion_FOR_REGION_0_ColocatedWith_1_SHOULD_NOT_BE_CHANGED_Previous_Configured_2 = new StringIdImpl(5151, "For partition region \"{0}\", Cannot change colocated-with to \"{1}\" because there is persistent data with different colocation. Previous configured value is \"{2}\".");
  public static final StringId Oplog_FAILED_RECORDING_RVV_BECAUSE_OF_0 = new StringIdImpl(5152, "Failed in persisting the garbage collection of entries because of: {0}");
  public static final StringId CacheServerLauncher_LAUNCH_IN_PROGRESS_0 = new StringIdImpl(5153, "The server is still starting. {0} seconds have elapsed since the last log message: \n {1}");

  public static final StringId CacheServerLauncher_CREATE_STATUS_EXCEPTION_0 = new StringIdImpl(5207, "The cacheserver status file could not be recreated due to the following exception: {0}");

  public static final StringId Snapshot_EXPORT_BEGIN_0 = new StringIdImpl(5154, "Exporting region {0}");
  public static final StringId Snapshot_EXPORT_END_0_1_2_3 = new StringIdImpl(5155, "Snapshot export of {0} entries ({1} bytes) in region {2} to file {3} is complete");
  public static final StringId Snapshot_IMPORT_BEGIN_0 = new StringIdImpl(5156, "Importing region {0}");
  public static final StringId Snapshot_IMPORT_END_0_1_2_3 = new StringIdImpl(5157, "Snapshot import of {0} entries ({1} bytes) in region {2} from file {3} is complete");
  public static final StringId Snapshot_UNABLE_TO_CREATE_DIR_0 = new StringIdImpl(5158, "Unable to create snapshot directory {0}");
  public static final StringId Snapshot_NO_SNAPSHOT_FILES_FOUND_0 = new StringIdImpl(5159, "No snapshot files found in {0}");
  public static final StringId Snapshot_UNSUPPORTED_SNAPSHOT_VERSION_0 = new StringIdImpl(5160, "Unsupported snapshot version: {0}");
  public static final StringId Snapshot_COULD_NOT_FIND_REGION_0_1 = new StringIdImpl(5161, "Could not find region {0}. Ensure that the region is created prior to importing the snapshot file {1}.");
  public static final StringId Snapshot_UNRECOGNIZED_FILE_TYPE_0 = new StringIdImpl(5162, "Unrecognized snapshot file type: {0}");
  public static final StringId Snapshot_UNRECOGNIZED_FILE_VERSION_0 = new StringIdImpl(5163, "Unrecognized snapshot file version: {0}");
  public static final StringId Snapshot_PDX_CONFLICT_0_1 = new StringIdImpl(5164, "Detected conflicting PDX types during import:\n{0}\n{1}\nSnapshot data containing PDX types must be imported into an empty cache with no pre-existing type definitions. Allow the import to complete prior to inserting additional data into the cache.");

  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_DISPATCHER_THREAD_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_DISPATCHER_THREAD_2 = new StringIdImpl(5208, "Cannot create Gateway Sender \"{0}\" with dispatcherThread \"{1}\" because another cache has the same Gateway Sender defined with dispatcherThread \"{2}\"");
  public static final StringId GatewaySenderAdvisor_CANNOT_CREATE_GATEWAYSENDER_0_WITH_ORDER_POLICY_1_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_SENDER_WITH_ORDER_POLICY_2 = new StringIdImpl(5209, "Cannot create Gateway Sender \"{0}\" with orderPolicy \"{1}\" because another cache has the same Gateway Sender defined with orderPolicy \"{2}\"");


  public static final StringId SerialGatewaySender_INVALID_GATEWAY_SENDER_ORDER_POLICY_CONCURRENCY_0 = new StringIdImpl(5210, "The \"order-policy\" configured for gateway sender {0} is valid only when the \"dispatcher-threads\" are more than 1.");

  public static final StringId SerialGatewaySender_UNKNOWN_GATEWAY_ORDER_POLICY_0_1 = new StringIdImpl(5211, "An invalid order-policy value ({1}) was configured for gateway sender {0}");

  public static final StringId CommandServiceManager_COULD_NOT_FIND__0__LIB_NEEDED_FOR_CLI_GFSH = new StringIdImpl(5212, "Could not find {0} library which is needed for CLI/gfsh in classpath. Internal support for CLI & gfsh is not enabled. Note: For convenience, absolute path of \"gfsh-dependencies.jar\" from \"lib\" directory of GemFire product distribution can be included in CLASSPATH of an application.");

  public static final StringId AttributesFactory_ADD_ASYNC_EVENT_LISTENER_PARAMETER_WAS_NULL = new StringIdImpl(5213, "AsyncEventListener parameter is null");

  public static final StringId CacheXmlParser_A_0_IS_NOT_AN_INSTANCE_OF_A_ASYNCEVENTLISTENER = new StringIdImpl(5214, "A  {0}  is not an instance of a AsyncEventListener");
  public static final StringId CacheXmlParser_A_0_MUST_BE_DEFINED_IN_THE_CONTEXT_OF_ASYNCEVENTQUEUE = new StringIdImpl(5215, "A  {0}  must be defined in the context of async-event-queue.");

  public static final StringId AttributesFactory_ASYNC_EVENT_QUEUE_ID_0_IS_ALREADY_ADDED = new StringIdImpl(5216, "async-event-queue-id {0} is already added");
  public static final StringId AsyncEventQueue_ASYNC_EVENT_LISTENER_CANNOT_BE_NULL = new StringIdImpl(5217, "AsyncEventListener cannot be null");

  public static final StringId CreateRegionProcessor_CANNOT_CREATE_REGION_0_WITH_1_ASYNC_EVENT_IDS_BECAUSE_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_ASYNC_EVENT_IDS = new StringIdImpl(5218, "Cannot create Region {0} with {1} async event ids because another cache has the same region defined with {2} async event ids");

  public static final StringId ParallelGatewaySenderImpl_STARTUP_POLICY_CAN_NOT_BE_SET_FOR_PARALLEL_DISTRIBUTION_POLICY = new StringIdImpl(5219, "Startup Policy can not be set for \"parallel\" distribution policy.");
  public static final StringId GatewaySenderImpl_NULL_CANNNOT_BE_ADDED_TO_GATEWAY_EVENT_FILTER_LIST = new StringIdImpl(5220, "null value can not be added to gateway-event-filters list");
  public static final StringId NULL_CANNNOT_BE_ADDED_TO_GATEWAY_STREAM_FILTER_LIST = new StringIdImpl(5221, "null value can not be added to gateway-stream-filters list");;
  public static final StringId AbstractGatewaySender_LOCATOR_SHOULD_BE_CONFIGURED_BEFORE_STARTING_GATEWAY_SENDER = new StringIdImpl(5222, "Locators must be configured before starting gateway-sender.");
  public static final StringId AttributesFactory_GATEWAY_SENDER_ID_0_IS_ALREADY_ADDED = new StringIdImpl(5223, "gateway-sender-id {0} is already added");
  // ok to reuse 5224
  public static final StringId GatewayEventProcessor_EVENT_0_IS_NOT_DISPATCHED = new StringIdImpl(5225, "event {0} is not dispacthed");
  public static final StringId LOCATOR_0_IS_NOT_SERVER_LOCATOR = new StringIdImpl(5226, "Locator {0} is not Server Locator.");
  public static final StringId AbstractGatewaySender_SENDER_0_IS_NOT_ABLE_TO_CONNECT_TO_LOCAL_LOCATOR_1 = new StringIdImpl(5227, "GatewaySender {0} is not able to connect to local locator {1}");
  public static final StringId AbstractGatewaySender_SENDER_0_COULD_NOT_GET_REMOTE_LOCATOR_INFORMATION_FOR_SITE_1 = new StringIdImpl(5228, "GatewaySender \"{0}\" could not get remote locator information for remote site \"{1}\".");
  public static final StringId GatewaySenderQueue_Directory_0_COULD_NOT_BE_CREATED = new StringIdImpl(5229, "Directory : {0} could not be created.");
  public static final StringId GatewaySender_PAUSED__0 = new StringIdImpl(5230, "Paused {0}");
  public static final StringId GatewaySender_RESUMED__0 = new StringIdImpl(5231, "Resumed {0}");
  public static final StringId GatewaySender_GATEWAY_0_IS_NOT_CLOSING_CLEANLY_FORCING_CANCELLATION = new StringIdImpl(5232, "GatewaySender <{0}> is not closing cleanly; forcing cancellation.");

  public static final StringId PersistenceAdvisorImpl_PERSISTENT_VIEW = new StringIdImpl(5233, "The following persistent member has gone offline for region {0}:\n{1}\nRemaining participating members for the region include:\n{2}");

  public static final StringId DefaultQuery_A_QUERY_ON_A_PARTITIONED_REGION_0_MAY_NOT_REFERENCE_ANY_OTHER_NON_COLOCATED_PARTITIONED_REGION_1 = new StringIdImpl(5234, "A query on a Partitioned Region ( {0} ) may not reference any other region except Co-located Partitioned Region. PR region (1) is not collocated with other PR region in the query.");
  public static final StringId CreatePersistentRegionProcessor_WAITING_FOR_ONLINE_BUCKET_MEMBERS = new StringIdImpl(5235, "Region {0} (and any colocated sub-regions) has potentially stale data.  Buckets {1} are waiting for another online member to recover the latest data.\nMy persistent id is:{2}\nOnline members with potentially new data:\n{3}\nUse the \"gemfire list-missing-disk-stores\" command to see all disk stores that are being waited on by other members.");

  // Localized Strings for the AbstractLauncher, Locator and Server Launcher classes
  public static final StringId Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE = new StringIdImpl(5236, "The Attach API classes could not be found on the classpath.  Please include JDK tools.jar on the classpath or add the JDK tools.jar to the jre/lib/ext directory.");
  public static final StringId Launcher_Builder_GEMFIRE_PROPERTIES_NOT_FOUND_ERROR_MESSAGE = new StringIdImpl(5237, "The specified GemFire properties configuration file ({0}) could not be found.");
  public static final StringId Launcher_Builder_INVALID_PORT_ERROR_MESSAGE = new StringIdImpl(5238, "The port on which the {0} will listen must be between 1 and 65535 inclusive.");
  public static final StringId Launcher_Builder_MEMBER_NAME_ERROR_MESSAGE = new StringIdImpl(5239, "The {0} member name must be specified.");
  public static final StringId Launcher_Builder_MEMBER_NAME_VALIDATION_ERROR_MESSAGE = new StringIdImpl(5240, "The member name of the {0} must be provided as an argument to the launcher, or a path to gemfire.properties must be specified, which assumes the {0} member name will be set using the \"name\" property.");
  public static final StringId Launcher_Builder_PARSE_COMMAND_LINE_ARGUMENT_ERROR_MESSAGE = new StringIdImpl(5241, "An error occurred while parsing command-line arguments for the {0}: {1}");
  public static final StringId Launcher_Builder_PID_ERROR_MESSAGE = new StringIdImpl(5242, "A process ID (PID) must be a non-negative integer value.");
  public static final StringId Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE = new StringIdImpl(5243, "The hostname/IP address to which the {0} will be bound is unknown.");
  public static final StringId Launcher_Builder_WORKING_DIRECTORY_NOT_FOUND_ERROR_MESSAGE = new StringIdImpl(5244, "The working directory for the {0} could not be found.");
  public static final StringId Launcher_Builder_WORKING_DIRECTORY_OPTION_NOT_VALID_ERROR_MESSAGE = new StringIdImpl(5245, "Specifying the --dir option is not valid when starting a {0} with the {0}Launcher.");
  public static final StringId Launcher_Command_START_IO_ERROR_MESSAGE = new StringIdImpl(5246, "An IO error occurred while starting a {0} in {1} on {2}: {3}");
  public static final StringId Launcher_Command_START_SERVICE_ALREADY_RUNNING_ERROR_MESSAGE = new StringIdImpl(5247, "A {0} is already running in {1} on {2}.");
  public static final StringId Launcher_Command_START_PID_FILE_ALREADY_EXISTS_ERROR_MESSAGE = new StringIdImpl(5248, "A PID file already exists and a {0} may be running in {1} on {2}.");
  public static final StringId Launcher_Command_START_PID_UNAVAILABLE_ERROR_MESSAGE = new StringIdImpl(5249, "The process ID could not be determined while starting {0} {1} in {2}: {3}");
  public static final StringId Launcher_ServiceStatus_STARTING_MESSAGE = new StringIdImpl(5250, "Starting {0} in {1} on {2} as {3} at {4}\nProcess ID: {5}\nGemFire Version: {6}\nJava Version: {7}\nLog File: {8}\nJVM Arguments: {9}\nClass-Path: {10}");
  public static final StringId Launcher_ServiceStatus_RUNNING_MESSAGE = new StringIdImpl(5251, "{0} in {1} on {2} as {3} is currently {4}.\nProcess ID: {5}\nUptime: {6}\nGemFire Version: {7}\nJava Version: {8}\nLog File: {9}\nJVM Arguments: {10}\nClass-Path: {11}");
  public static final StringId Launcher_ServiceStatus_STOPPED_MESSAGE = new StringIdImpl(5252, "{0} in {1} on {2} has been requested to stop.");
  public static final StringId Launcher_ServiceStatus_MESSAGE = new StringIdImpl(5253, "{0} in {1} on {2} is currently {3}.");
  public static final StringId Launcher_Status_NOT_RESPONDING = new StringIdImpl(5254, "not responding");
  public static final StringId Launcher_Status_ONLINE = new StringIdImpl(5255, "online");
  public static final StringId Launcher_Status_STARTING = new StringIdImpl(5256, "starting");
  public static final StringId Launcher_Status_STOPPED = new StringIdImpl(5257, "stopped");
  public static final StringId Launcher_Command_FAILED_TO_GET_SHARED_CONFIGURATION = new StringIdImpl(5258, "Unable to retrieve cluster configuration from the locator.");

  public static final StringId LocatorLauncher_Builder_INVALID_HOSTNAME_FOR_CLIENTS_ERROR_MESSAGE = new StringIdImpl(5260, "The hostname used by clients to connect to the Locator must have an argument if the --hostname-for-clients command-line option is specified!");
  public static final StringId LocatorLauncher_LOCATOR_LAUNCHER_HELP = new StringIdImpl(5261, "A GemFire launcher used to start, stop and determine a Locator''s status.");
  public static final StringId LocatorLauncher_START_LOCATOR_HELP = new StringIdImpl(5262, "Starts a Locator running in the current working directory listening on the default port ({0}) bound to all IP addresses available to the localhost.  The Locator must be given a member name in the GemFire cluster.  The default bind-address and port may be overridden using the corresponding command-line options.");
  public static final StringId LocatorLauncher_STATUS_LOCATOR_HELP = new StringIdImpl(5263, "Displays the status of a Locator given any combination of the bind-address[port], member name/ID, PID, or the directory in which the Locator is running.");
  public static final StringId LocatorLauncher_STOP_LOCATOR_HELP = new StringIdImpl(5264, "Stops a running Locator given a member name/ID, PID, or the directory in which the Locator is running.");
  public static final StringId LocatorLauncher_VERSION_LOCATOR_HELP = new StringIdImpl(5265, "Displays GemFire product version information.");
  public static final StringId LocatorLauncher_LOCATOR_BIND_ADDRESS_HELP = new StringIdImpl(5266, "Specifies the IP address on which to bind, or on which the Locator is bound, listening for client requests.  Defaults to all IP addresses available to the localhost.");
  public static final StringId LocatorLauncher_LOCATOR_DEBUG_HELP = new StringIdImpl(5267, "Displays verbose information during the invocation of the launcher.");
  public static final StringId LocatorLauncher_LOCATOR_DIR_HELP = new StringIdImpl(5268, "Specifies the working directory where the Locator is running.  Defaults to the current working directory.");
  public static final StringId LocatorLauncher_LOCATOR_FORCE_HELP = new StringIdImpl(5269, "Enables any existing Locator PID file to be overwritten on start.  The default is to throw an error if a PID file already exists and --force is not specified.");
  public static final StringId LocatorLauncher_LOCATOR_HOSTNAME_FOR_CLIENTS_HELP = new StringIdImpl(5270, "An option to specify the hostname or IP address to send to clients so they can connect to this Locator. The default is to use the IP address to which the Locator is bound.");
  public static final StringId LocatorLauncher_LOCATOR_MEMBER_HELP = new StringIdImpl(5271, "Identifies the Locator by member name or ID in the GemFire cluster.");
  public static final StringId LocatorLauncher_LOCATOR_PID_HELP = new StringIdImpl(5272, "Indicates the OS process ID of the running Locator.");
  public static final StringId LocatorLauncher_LOCATOR_PORT_HELP = new StringIdImpl(5273, "Specifies the port on which the Locator is listening for client requests. Defaults to {0}.");
  public static final StringId LocatorLauncher_LOCATOR_REDIRECT_OUTPUT_HELP = new StringIdImpl(5274, "An option to cause the Locator to redirect standard out and standard error to the GemFire log file.");

  public static final StringId ServerLauncher_SERVER_LAUNCHER_HELP = new StringIdImpl(5280, "A GemFire launcher used to start, stop and determine a Server''s status.\n");
  public static final StringId ServerLauncher_START_SERVER_HELP = new StringIdImpl(5281, "Starts a Server running in the current working directory listening on the default port ({0}) bound to all IP addresses available to the localhost.  The Server must be given a member name in the GemFire cluster.  The default server-bind-address and server-port may be overridden using the corresponding command-line options.");
  public static final StringId ServerLauncher_STATUS_SERVER_HELP = new StringIdImpl(5282, "Displays the status of a Server given any combination of the member name/ID, PID, or the directory in which the Server is running.");
  public static final StringId ServerLauncher_STOP_SERVER_HELP = new StringIdImpl(5283, "Stops a running Server given given a member name/ID, PID, or the directory in which the Server is running.");
  public static final StringId ServerLauncher_VERSION_SERVER_HELP = new StringIdImpl(5284, "Displays GemFire product version information.");
  public static final StringId ServerLauncher_SERVER_ASSIGN_BUCKETS_HELP = new StringIdImpl(5285, "Causes buckets to be assigned to the partitioned regions in the GemFire cache on Server start.");
  public static final StringId ServerLauncher_SERVER_BIND_ADDRESS_HELP = new StringIdImpl(5286, "Specifies the IP address on which to bind, or on which the Server is bound, listening for client requests.  Defaults to all IP addresses available to the localhost.");
  public static final StringId ServerLauncher_SERVER_DEBUG_HELP = new StringIdImpl(5287, "Displays verbose information during the invocation of the launcher.");
  public static final StringId ServerLauncher_SERVER_DIR_HELP = new StringIdImpl(5288, "Specifies the working directory where the Server is running.  Defaults to the current working directory.");
  public static final StringId ServerLauncher_SERVER_DISABLE_DEFAULT_SERVER_HELP = new StringIdImpl(5289, "Disables the addition of a default GemFire cache server.");
  public static final StringId ServerLauncher_SERVER_FORCE_HELP = new StringIdImpl(5290, "Enables any existing Server PID file to be overwritten on start.  The default is to throw an error if a PID file already exists and --force is not specified.");
  public static final StringId ServerLauncher_SERVER_MEMBER_HELP = new StringIdImpl(5291, "Identifies the Server by member name or ID in the GemFire cluster.");
  public static final StringId ServerLauncher_SERVER_PID_HELP = new StringIdImpl(5292, "Indicates the OS process ID of the running Server.");
  public static final StringId ServerLauncher_SERVER_PORT_HELP = new StringIdImpl(5293, "Specifies the port on which the Server is listening for client requests. Defaults to {0}.");
  public static final StringId ServerLauncher_SERVER_REBALANCE_HELP = new StringIdImpl(5294, "An option to cause the GemFire cache''s partitioned regions to be rebalanced on start.");
  public static final StringId ServerLauncher_SERVER_REDIRECT_OUTPUT_HELP = new StringIdImpl(5295, "An option to cause the Server to redirect standard out and standard error to the GemFire log file.");
  public static final StringId ServerLauncher_SERVER_HOSTNAME_FOR_CLIENT_HELP = new StringIdImpl(5296, "An option to specify the hostname or IP address to send to clients so they can connect to this Server. The default is to use the IP address to which the Server is bound.");

  public static final StringId PoolFactoryImpl_HOSTNAME_UNKNOWN = new StringIdImpl(5300, "Hostname is unknown: {0}. Creating pool with unknown host in case the host becomes known later.");
  public static final StringId GatewaySenderEventRemoteDispatcher_GATEWAY_SENDER_0_RECEIVED_ACK_FOR_BATCH_ID_1_OF_2_EVENTS = new StringIdImpl(5301, "Gateway Sender {0} : Received ack for batch id {1} of {2} events.");
  public static final StringId GatewaySenderEventRemoteDispatcher_GATEWAY_SENDER_0_RECEIVED_ACK_FOR_BATCH_ID_1_WITH_EXCEPTION = new StringIdImpl(5302, "Gateway Sender {0} : Received ack for batch id {1} with exception:");

  public static final StringId Region_REGION_0_HAS_1_GATEWAY_SENDER_IDS_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_GATEWAY_SENDER_IDS_FOR_REGION_ACROSS_ALL_MEMBERS_IN_DS_GATEWAY_SENDER_IDS_SHOULD_BE_SAME = new StringIdImpl(
      5303,
      "Region {0} has {1} gateway sender IDs. Another cache has same region with {2} gateway sender IDs. For region across all members, gateway sender ids should be same.");

  public static final StringId Region_REGION_0_HAS_1_ASYNC_EVENT_QUEUE_IDS_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_ASYNC_EVENT_QUEUE_IDS_FOR_REGION_ACROSS_ALL_MEMBERS_IN_DS_ASYNC_EVENT_QUEUE_IDS_SHOULD_BE_SAME = new StringIdImpl(
      5304,
      "Region {0} has {1} AsyncEvent queue IDs. Another cache has same region with {2} AsyncEvent queue IDs. For region across all members, AsyncEvent queue IDs should be same.");
  public static final StringId GatewayEventFilter_EXCEPTION_OCCURED_WHILE_HANDLING_CALL_TO_0_AFTER_ACKNOWLEDGEMENT_FOR_EVENT_1 = new StringIdImpl(5305, "Exception occured while handling call to {0}.afterAcknowledgement for event {1}:"); 
  public static final StringId GatewayReceiverImpl_USING_LOCAL_HOST = new StringIdImpl(5399, "No bind-address or hostname-for-sender is specified, Using local host ");
  public static final StringId GatewayReceiverImpl_COULD_NOT_GET_HOST_NAME = new StringIdImpl(5400, "Could not get host name");
  public static final StringId CqService_ERROR_SENDING_CQ_CONNECTION_STATUS = new StringIdImpl(5401, "Error while sending connection status to cq listeners");
  public static final StringId AbstractGatewaySender_SENDER_0_GOT_REMOTE_LOCATOR_INFORMATION_FOR_SITE_1 = new StringIdImpl(
      5402,
      "GatewaySender \"{0}\" got remote locator information for remote site \"{1}\" after {2} failures in connecting to remote site.");

  public static final StringId CreatePersistentRegionProcessor_WAITING_FOR_ONLINE_LATEST_MEMBER = new StringIdImpl(5403, "Region {0} has potentially stale data. It is waiting for another online member to recover the latest data.\nMy persistent id:\n{1}\nMembers with potentially new data:\n{2}\nUse the \"gemfire list-missing-disk-stores\" command to see all disk stores that are being waited on by other members.");
  public static final StringId AttributesFactory_CONCURRENCY_CHECKS_MUST_BE_ENABLED = new StringIdImpl(5404, "Concurrency checks cannot be disabled for regions that use persistence");
  public static final StringId PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_DISK_ACCESS_EXCEPTION = new StringIdImpl(5405, "PartitionResponse got remote DiskAccessException");
  public static final StringId CqService_UNABLE_TO_RETRIEVE_DURABLE_CQS_FOR_CLIENT_PROXY_ID = new StringIdImpl(5406, "Unable to retrieve durable CQs for client proxy id {0}");
  public static final StringId DiskInitFile_THE_INIT_FILE_0_DOES_NOT_EXIST = new StringIdImpl(5407, "The init file \"{0}\" does not exist.");
  public static final StringId DiskInitFile_IF_IT_NO_LONGER_EXISTS_DELETE_FOLLOWING_FILES_TO_CREATE_THIS_DISK_STORE_EXISTING_OPLOGS_0 = new StringIdImpl(5408, " If it no longer exists then delete the following files to be able to create this disk store. Existing oplogs are: {0}");

  public static final StringId GatewaySender_ACKREADERTHREAD_IGNORED_CANCELLATION = new StringIdImpl(5409, "AckReaderThread ignored cancellation");
  public static final StringId QueryMonitor_LOW_MEMORY_CANCELED_QUERY = new StringIdImpl(5410, "Query execution canceled due to memory threshold crossed in system, memory used: {0} bytes.");
  public static final StringId QueryMonitor_LOW_MEMORY_WHILE_GATHERING_RESULTS_FROM_PARTITION_REGION = new StringIdImpl(5411, "Query execution canceled due to low memory while gathering results from partitioned regions");
  public static final StringId IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY = new StringIdImpl(5412, "Index creation canceled due to low memory");

  public static final StringId GatewaySenderImpl_PARALLEL_GATEWAY_SENDER_0_CANNOT_BE_CREATED_WITH_ORDER_POLICY_1 = new StringIdImpl(5413, "Parallel Gateway Sender {0} can not be created with OrderPolicy {1}");
  public static final StringId GatewaySenderImpl_GATEWAY_SENDER_0_CANNOT_HAVE_DISPATCHER_THREADS_LESS_THAN_1 = new StringIdImpl(5414, "GatewaySender {0} can not be created with dispatcher threads less than 1");

  public static final StringId JGroupMembershipManager_POSSIBLE_LOSS_OF_QUORUM_DETECTED = new StringIdImpl(5415, "Possible loss of quorum due to the loss of {0} cache processes: {1}");

  public static final StringId Soplog_INVALID_MAGIC = new StringIdImpl(5416, "Invalid soplog magic: {0}");
  public static final StringId Soplog_UNRECOGNIZED_VERSION = new StringIdImpl(5417, "Unrecognized soplog file version: {0}");

  public static final StringId AbstractDiskRegion_UNABLE_TO_CLOSE_SOPLOG_SET = new StringIdImpl(5418, "Unable to close soplogs due to unexpected error.");

  public static final StringId AsyncEventQueue_UNKNOWN_ORDER_POLICY_0_1 = new StringIdImpl(5420, "An invalid order-policy value ({1}) was configured for AsyncEventQueue {0}");

  public static final StringId ProcessBatch_0_CAUGHT_EXCEPTION_PROCESSING_BATCH_UPDATE_VERSION_REQUEST_1_CONTAINING_2_EVENTS = new StringIdImpl(5421, "{0}: Caught exception processing batch update version request request {1} containing {2} events");
  public static final StringId PartitionedRegion_NO_VM_AVAILABLE_FOR_UPDATE_ENTRY_VERSION_IN_0_ATTEMPTS = new StringIdImpl(5422, "No VM available for update-version in {0} attempts.");
  public static final StringId PartitionedRegion_UPDATE_VERSION_OF_ENTRY_ON_0_FAILED = new StringIdImpl(5423, "Update version of entry on {0} failed.");

  public static final StringId UpdateEntryVersionMessage_FAILED_SENDING_0 = new StringIdImpl(5424, "Failed sending < {0} >.");
  public static final StringId UpdateVersionOperation_CACHEWRITER_SHOULD_NOT_BE_CALLED = new StringIdImpl(5425, "CacheWriter should not be called");
  public static final StringId UpdateVersionOperation_DISTRIBUTEDLOCK_SHOULD_NOT_BE_ACQUIRED = new StringIdImpl(5426, "DistributedLock should not be acquired");
  public static final StringId ProcessBatch_0_DURING_BATCH_UPDATE_VERSION_NO_ENTRY_WAS_FOUND_FOR_KEY_1 = new StringIdImpl(5427, "Entry for key {1} was not found in Region {0} during ProcessBatch for Update Entry Version");
  public static final StringId ProcessBatch_WAS_NOT_FOUND_DURING_BATCH_UPDATE_VERSION_REQUEST_0 = new StringIdImpl(5428, "Region {0} was not found during Batch Update Version request");

  public static final StringId CacheClientNotifier_COULD_NOT_CONNECT_DUE_TO_CQ_BEING_DRAINED = new StringIdImpl(5429, "CacheClientNotifier: Connection refused due to cq queue being drained from admin command, please wait...");
  public static final StringId CacheClientProxy_COULD_NOT_DRAIN_CQ_DUE_TO_RESTARTING_DURABLE_CLIENT = new StringIdImpl(5430, "CacheClientProxy: Could not drain cq {0} due to client proxy id {1} reconnecting.");
  public static final StringId CacheClientProxy_COULD_NOT_DRAIN_CQ_DUE_TO_ACTIVE_DURABLE_CLIENT = new StringIdImpl(5431, "CacheClientProxy: Could not drain cq {0} because client proxy id {1} is connected.");
  public static final StringId ParallelGatewaySenderQueue_COULD_NOT_TERMINATE_CONFLATION_THREADPOOL = new StringIdImpl(5432, "Conflation thread pool did not terminate for the GatewaySender : {0}");

  public static final StringId NOT_QUEUING_AS_USERPR_IS_NOT_YET_CONFIGURED = new StringIdImpl(5433, "GatewaySender: Not queuing the event {0}, as the region for which this event originated is not yet configured in the GatewaySender");

  public static final StringId TCPConduit_EXCEPTION_PARSING_TCPPORTRANGESTART = new StringIdImpl(5434, "Exception parsing membership-port-range start port.");
  public static final StringId TCPConduit_EXCEPTION_PARSING_TCPPORTRANGEEND = new StringIdImpl(5435, "Exception parsing membership-port-range end port.");
  public static final StringId TCPConduit_UNABLE_TO_FIND_FREE_PORT = new StringIdImpl(5436, "Unable to find a free port in the membership-port-range");
  public static final StringId AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_DIFF_CAN_NOT_BE_LESS_THAN_2 = new StringIdImpl(5437, "Could not set \"{0}\" to \"{1}\" because a minimum of \"{2}\" values are required in the range.");

  public static final StringId Snapshot_INVALID_EXPORT_FILE = new StringIdImpl(5438, "File is invalid or is a directory: {0}");
  public static final StringId Snapshot_INVALID_IMPORT_FILE = new StringIdImpl(5439, "File does not exist or is a directory: {0}");

  public static final StringId LocalRegion_REGION_IS_BEING_DESTROYED_WAITING_FOR_PARALLEL_QUEUE_TO_DRAIN = new StringIdImpl(5440, "Region is being destroyed. Waiting for paralle queue to drain.");
  public static final StringId PartitionedRegion_GATEWAYSENDER_0_IS_PAUSED_RESUME_IT_BEFORE_DESTROYING_USER_REGION_1 = new StringIdImpl(5441, "GatewaySender {0} is paused. Resume it before destroying region {1}.");
  public static final StringId PartitionedRegion_GATEWAYSENDERS_0_ARE_PAUSED_RESUME_THEM_BEFORE_DESTROYING_USER_REGION_1 = new StringIdImpl(5442, "GatewaySenders {0} are paused. Resume them before destroying region {1}.");

  public static final StringId GatewaySender_COULD_NOT_DESTROY_SENDER_AS_IT_IS_STILL_IN_USE = new StringIdImpl(5443, "The GatewaySender {0} could not be destroyed as it is still used by region(s).");
  public static final StringId AbstractGatewaySender_REGION_0_UNDERLYING_GATEWAYSENDER_1_IS_ALREADY_DESTROYED = new StringIdImpl(5444, "Region {0} that underlies the GatewaySender {1} is already destroyed.");
  public static final StringId AsyncEventQueue_0_CANNOT_HAVE_DISPATCHER_THREADS_LESS_THAN_1 = new StringIdImpl(5445, "AsyncEventQueue {0} can not be created with dispatcher threads less than 1");
  public static final StringId AsyncEventQueue_INVALID_ORDER_POLICY_CONCURRENCY_0 = new StringIdImpl(5446, "The \"order-policy\" configured for AsyncEventQueue {0} is valid only when the \"dispatcher-threads\" are more than 1.");
  public static final StringId AsyncEventQueue_0_CANNOT_BE_CREATED_WITH_ORDER_POLICY_1 = new StringIdImpl(5447, "AsyncEventQueue {0} can not be created with OrderPolicy {1} when it is set parallel");
  public static final StringId GatewaySender_0_CAUGHT_EXCEPTION_WHILE_STOPPING_1 = new StringIdImpl(5448, "GatewaySender {0} caught exception while stopping: {1}");
  public static final StringId Oplog_DELETE_FAIL_0_1_2 = new StringIdImpl(5449,"Could not delete the file {0} {1} for disk store {2}.");

  public static final StringId PERCENTAGE_MOVE_DIRECTORY_SOURCE_NOT_DATA_STORE = new StringIdImpl(5450, "Source member does not exist or is not a data store for the partitioned region {0}: {1}");
  public static final StringId PERCENTAGE_MOVE_DIRECTORY_TARGET_NOT_DATA_STORE = new StringIdImpl(5451, "Target member does not exist or is not a data store for the partitioned region {0}: {1}");
  public static final StringId PERCENTAGE_MOVE_TARGET_SAME_AS_SOURCE = new StringIdImpl(5452, "Target member is the same as source member for the partitioned region {0}: {1}");
  
  public static final StringId GatewaySender_SEQUENCENUMBER_GENERATED_FOR_EVENT_IS_INVALID = new StringIdImpl(5453, "ERROR! The sequence number {0} generated for the bucket {1} is incorrect.");
  public static final StringId ParallelGatewaySender_ENTRYNOTFOUNDEXCEPTION_ENCOUNTERED_DURING_EVENT_REMOVAL = new StringIdImpl(5454, "WARNING! ParallelGatewaySenderQueue#remove: Got EntryNotFoundException while removing key {0} from bucket {1} for GatewaySender {2}.");
  public static final StringId ParallelGatewaySender_NULL_VALUE_FOUND_IN_BUCKET_FOR_GIVEN_KEY = new StringIdImpl(5455, "Warning! The value against key {0} in the bucket region queue with id {1} is NULL for GatewaySender {2}.");

  public static final StringId CacheXmlParser_A_0_MUST_BE_DEFINED_IN_THE_CONTEXT_OF_GATEWAY_SENDER_OR_ASYNC_EVENT_QUEUE = new StringIdImpl(5456, "A  {0}  must be defined in the context of gateway-sender or async-event-queue.");

  public static final StringId BucketAdvisor_WAITING_FOR_PRIMARY = new StringIdImpl(5457,"{0} secs have elapsed waiting for a primary for bucket {1}. Current bucket owners {2}");
  public static final StringId BucketAdvisor_WAITING_FOR_PRIMARY_DONE = new StringIdImpl(5458,"Wait for primary completed");

  public static final StringId DistributedPutAllOperation_MISSING_VERSION = new StringIdImpl(5459,"memberID cannot be null for persistent regions: {0}");

  public static final StringId Server_Ping_Failure = new StringIdImpl(5460, "Could not ping one of the following servers: {0}");
  
  public static final StringId DistributionManager_PR_META_DATA_CLEANUP_MESSAGE_PROCESSOR = new StringIdImpl(5500, "PrMetaData cleanup Message Processor ");
  public static final StringId RegionCreation_REGION_DESTROYED_DURING_INITIALIZATION = new StringIdImpl(5501, "Region was globally destroyed during cache initialization: {0}");
  public static final StringId SnappyCompressor_UNABLE_TO_LOAD_NATIVE_SNAPPY_LIBRARY = new StringIdImpl(5502, "Unable to load native Snappy library.");
  public static final StringId SnappyCompressor_UNABLE_TO_LOAD_NATIVE_SNAPPY_LIBRARY_MISSING_LIBRARY = new StringIdImpl(5503, "Unable to load native Snappy library from: {0}");
  
  /** HOPLOG STRINGS, 5505 - 5600 **/
  public static final StringId HOPLOG_REGION_CLOSE_FAILED = new StringIdImpl(5505, "IO error while trying to close region and release hdfs connection: {0}");
  public static final StringId HOPLOG_HDFS_CLIENT_CONFIG_FILE_ABSENT = new StringIdImpl(5506, "HDFS client config file does not exist: {0}");
  public static final StringId HOPLOG_IO_ERROR = new StringIdImpl(5507, "IO Exception while executing HDFS operation: {0}");
  public static final StringId HOPLOG_UNABLE_TO_DELETE_FILE = new StringIdImpl(5508, "Unable to delete file: {0}");
  public static final StringId HOPLOG_UNABLE_TO_DELETE_HDFS_DATA = new StringIdImpl(5509, "Unable to delete HDFS data while destroying region");
  public static final StringId HOPLOG_CLOSE_FAILED = new StringIdImpl(5510, "IO error while trying to close hoplog.");
  public static final StringId HOPLOG_FLUSH_FOR_BATCH_FAILED = new StringIdImpl(5511, "A batch of data could not be persisted on HDFS. It will be retried.");
  public static final StringId HOPLOG_HDFS_STORE_NOT_FOUND = new StringIdImpl(5512, "HDFS store ''{0}'' does not exist.");
  public static final StringId HOPLOG_TRYING_TO_CREATE_STANDALONE_SYSTEM = new StringIdImpl(5513, "The namenode url {0} is not valid. Please use the format hdfs://HOST:PORT");
  public static final StringId HOPLOG_DOES_NOT_USE_HDFSSTORE = new StringIdImpl(5514, "{0} does not use HDFSSTORE");
  public static final StringId HOPLOG_CONFIGURED_AS_WRITEONLY = new StringIdImpl(5515, "{0} is defined as WRITEONLY");
  public static final StringId HOPLOG_MISSING_IN_BUCKET_FORCED_CLOSED = new StringIdImpl(5516, "A hoplog file, {0}, was not found in bucket lists. Closing it now, it may impact active reads.");
  public static final StringId HOPLOG_MIN_IS_MORE_THAN_MAX = new StringIdImpl(5517, "Value of {0} is {1}. It should not be more than {2} value {3}");
  public static final StringId HOPLOG_NOT_STARTED_YET = new StringIdImpl(5518, "HDFS store is not started yet. Gemfire is running without HDFS.");
  public static final StringId HOPLOG_0_COLOCATE_WITH_REGION_1_NOT_INITIALIZED_YET = new StringIdImpl(5519, "Current region: {0} colocated with region {1} is yet initialized.");
  public static final StringId HOPLOG_SUSPEND_OF_0_FAILED_IN_1 = new StringIdImpl(5520, "Failed to suspend active {0} in {1}");
  public static final StringId HOPLOG_CLEANED_UP_BY_JANITOR = new StringIdImpl(5521, "Hoplog is cleaned up by janitor task.");
  public static final StringId HOPLOG_HDFS_UNREACHABLE = new StringIdImpl(5522, "HDFS at {0} is unreachable.");
  public static final StringId HOPLOG_MAJOR_COMPACTION_SCHEDULED_FOR_BETTER_ESTIMATE = new StringIdImpl(5523, "A major compaction has been automatically scheduled for better accuracy of count_estimate() function");
  public static final StringId HOPLOG_FAILED_TO_READ_HDFS_FILE = new StringIdImpl(5524, "Exception while reading file on HDFS: {0}");
  public static final StringId HOPLOG_HDFS_COMPACTION_ERROR = new StringIdImpl(5525, "Error while compacting files of bucket {0}");
  public static final StringId HOPLOG_HDFS_COMPACTION_OVERLOADED = new StringIdImpl(5526, "Too many pending tasks for {0}. Skipping compaction request for {1}");
  public static final StringId HOPLOG_FLUSH_OPERATION_FAILED = new StringIdImpl(5527, "IO error while trying to flush buffer and create hoplog.");
  public static final StringId HOPLOG_HOPLOG_REMOVE_FAILED = new StringIdImpl(5528, "IO error while trying to remove hoplog.");
  /** HOPLOG STRINGS, 5505 - 5600 **/

  public static final StringId PartitionAttributesImpl_CANNOT_DETERMINE_LOCAL_MAX_MEMORY_FOR_PARTITION_ATTRIBUTE_SINCE_NO_CACHE_IS_AVAILABLE_FROM_WHICH_TO_FETCH_THE_OFF_HEAP_MEMORY_ALLOCATOR = new StringIdImpl(5600, "Cannot determine local max memory for partition attribute since no cache is available from which to fetch the off-heap memory allocator");

  public static final StringId PartitionAttributesImpl_CANNOT_DETERMINE_LOCAL_MAX_MEMORY_FOR_PARTITION_ATTRIBUTE_SINCE_NO_OFF_HEAP_MEMORY_HAS_BEEN_ALLOCATED = new StringIdImpl(5601, "Cannot determine local max memory for partition attribute since no off-heap memory has been allocated");
  public static final StringId PartitionAttributesImpl_REDUCED_LOCAL_MAX_MEMORY_FOR_PARTITION_ATTRIBUTES_WHEN_SETTING_FROM_AVAILABLE_OFF_HEAP_MEMORY_SIZE = new StringIdImpl(5602, "Reduced local max memory for partition attribute when setting from available off-heap memory size");
  public static final StringId ParallelQueueRemovalMessage_QUEUEREMOVALMESSAGEPROCESSEXCEPTION_IN_PROCESSING_THE_LAST_DISPTACHED_KEY_FOR_A_SHADOWPR_THE_PROBLEM_IS_WITH_KEY__0_FOR_SHADOWPR_WITH_NAME_1 = new StringIdImpl(5603, "ParallelQueueRemovalMessage::process:Exception in processing the last disptached key for a ParallelGatewaySenderQueue''s shadowPR. The problem is with key ={0} for shadowPR with name={1}");

  public static final StringId DistributionManager_DISTRIBUTIONMANAGER_MEMBER_0_IS_1_EQUIVALENT = new StringIdImpl(5604,"Member {0} is {1}equivalent or in the same redundancy zone.");

  public static final StringId GemFireCache_INIT_CLEANUP_FAILED_FOR_REGION_0 = new StringIdImpl(5605, "Initialization failed for Region {0}");
  public static final StringId GemFireCache_ENFORCE_UNIQUE_HOST_NOT_APPLICABLE_FOR_LONER = new StringIdImpl(5606, "enforce-unique-host and redundancy-zone properties have no effect for a LonerDistributedSystem.");
  public static final StringId AttributesFactory_UNABLE_TO_CREATE_DISK_STORE_DIRECTORY_0 = new StringIdImpl(5607, "Unable to create directory : {0}");
  public static final StringId LocalRegion_A_DISKACCESSEXCEPTION_HAS_OCCURED_WHILE_WRITING_TO_THE_DISK_FOR_REGION_0_THE_CACHE_WILL_BE_CLOSED = new StringIdImpl(5608, "A DiskAccessException has occurred while writing to the disk for region {0}. The cache will be closed.");
  public static final StringId LocalRegion_A_DISKACCESSEXCEPTION_HAS_OCCURED_WHILE_WRITING_TO_THE_DISK_FOR_DISKSTORE_0_THE_CACHE_WILL_BE_CLOSED = new StringIdImpl(5609, "A DiskAccessException has occurred while writing to the disk for disk store {0}. The cache will be closed.");
  public static final StringId LocalRegion_AN_EXCEPTION_OCCURED_WHILE_CLOSING_THE_CACHE = new StringIdImpl(5610, "An Exception occurred while closing the cache.");

  public static final StringId DiskWriteAttributesFactory_DISK_USAGE_WARNING_INVALID_0 = new StringIdImpl(5611, "Disk usage warning percentage must be set to a value between 0-100.  The value {0} is invalid.");
  public static final StringId DiskWriteAttributesFactory_DISK_USAGE_CRITICAL_INVALID_0 = new StringIdImpl(5612, "Disk usage critical percentage must be set to a value between 0-100.  The value {0} is invalid.");
  public static final StringId DistributedRegion_REGION_0_ENABLE_NETWORK_PARTITION_WARNING = new StringIdImpl(5832, "Creating persistent region {0}, but enable-network-partition-detection is set to false. Running with network partition detection disabled can lead to an unrecoverable system in the event of a network split.");

  public static final StringId DiskStoreMonitor_LOG_DISK_NORMAL = new StringIdImpl(5613, "The disk volume {0} for log files has returned to normal usage levels and is {1} full.");
  public static final StringId DiskStoreMonitor_LOG_DISK_WARNING = new StringIdImpl(5614, "The disk volume {0} for log files has exceeded the warning usage threshold and is {1} full.");

  public static final StringId DiskStoreMonitor_DISK_WARNING = new StringIdImpl(5616, "The disk volume {0} for disk store {1} has exceeded the warning usage threshold and is {2} full");
  public static final StringId DiskStoreMonitor_DISK_CRITICAL = new StringIdImpl(5617, "The disk volume {0} for disk store {1} has exceeded the critical usage threshold and is {2} full");
  public static final StringId DiskStoreMonitor_DISK_NORMAL = new StringIdImpl(5618, "The disk volume {0} for disk store {1} has returned to normal usage levels and is {2} full");
  
  public static final StringId DiskStoreMonitor_ERR = new StringIdImpl(5619, "The DiskStore Monitor has encountered an error");
  public static final StringId DiskStoreMonitor_ThreadGroup = new StringIdImpl(5620, "DiskStoreMonitorss");

  public static final StringId GatewayImpl_GATEWAY_0_HAS_BEEN_REBALANCED = new StringIdImpl(5621, "GatewaySender {0} has been rebalanced");

  public static final StringId OffHeapMemoryMonitor_NO_OFF_HEAP_MEMORY_HAS_BEEN_CONFIGURED = new StringIdImpl(5622, "No off-heap memory has been configured.");

  public static final StringId Oplog_Close_Failed = new StringIdImpl(5640, "Failed to close file {0}");
  public static final StringId Oplog_PreAllocate_Failure = new StringIdImpl(5641, "Could not pre-allocate file {0} with size={1}");
  public static final StringId Oplog_PreAllocate_Failure_Init = new StringIdImpl(5642, "Could not create and pre grow file in dir {0} with size={1}");
  
  public static final StringId InternalInstantiator_REGISTERED = new StringIdImpl(5650, "Instantiator registered with id {0} class {1}");
  public static final StringId InternalInstantiator_REGISTERED_HOLDER = new StringIdImpl(5651, "Instantiator registered with holder id {0} class {1}");
  public static final StringId RegisterInstantiators_BAD_CLIENT = new StringIdImpl(5652, "Client {0} failed to register instantiators: {1}");
  public static final StringId GatewayReceiver_EXCEPTION_WHILE_PROCESSING_BATCH = new StringIdImpl(5653, "Exception occurred while processing a batch on the receiver running on DistributedSystem with Id: {0}, DistributedMember on which the receiver is running: {1}");

  public static final StringId DiskStoreAttributesCreation_DISK_USAGE_WARN_ARE_NOT_THE_SAME = new StringIdImpl(5660, "Disk usage warning percentages of disk store {0} are not the same");
  public static final StringId DiskStoreAttributesCreation_DISK_USAGE_CRITICAL_ARE_NOT_THE_SAME = new StringIdImpl(5661, "Disk usage critical percentages of disk store {0} are not the same");

  public static final StringId MEMSCALE_JVM_INCOMPATIBLE_WITH_OFF_HEAP = new StringIdImpl(5662,"Your Java virtual machine is incompatible with off-heap memory.  Please refer to {0} documentation for suggested JVMs.");
  public static final StringId MEMSCALE_EVICTION_INIT_FAIL = new StringIdImpl(5663,"Cannot initialize the off-heap evictor.  There is no off-heap memory available for eviction.");


  // If the text is changed for this StringId, do the same in ConnectionPoolImplJUnitTest.java
  public static final StringId QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE = new StringIdImpl(5700, "Could not find any server to create primary client queue on. Number of excluded servers is {0} and exception is {1}.");
  // If the text is changed for this StringId, do the same in ConnectionPoolImplJUnitTest.java
  public static final StringId QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_REDUNDANT_CLIENT_QUEUE = new StringIdImpl(5701, "Could not find any server to create redundant client queue on. Number of excluded servers is {0} and exception is {1}.");
  public static final StringId QueueManagerImpl_SUBSCRIPTION_ENDPOINT_CRASHED_SCHEDULING_RECOVERY = new StringIdImpl(5702, "{0} subscription endpoint {1} crashed. Scheduling recovery.");
  public static final StringId QueueManagerImpl_CACHE_CLIENT_UPDATER_FOR_ON_ENDPOINT_EXITING_SCHEDULING_RECOVERY = new StringIdImpl(5703, "Cache client updater for {0} on endpoint {1} exiting. Scheduling recovery.");
  //SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover
  public static final StringId QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER = new StringIdImpl(5704, "SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover.");
  public static final StringId QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_REDUNDANT_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER = new StringIdImpl(5705, "SubscriptionManager redundancy satisfier - redundant endpoint has been lost. Attempting to recover.");
  public static final StringId DiskStoreImpl_FATAL_ERROR_ON_FLUSH = new StringIdImpl(5706,"Fatal error from asynchronous flusher thread");
  public static final StringId AbstractGatewaySender_META_REGION_CREATION_EXCEPTION_0 = new StringIdImpl(5707, "{0}: Caught the following exception attempting to create gateway event id index metadata region:");
  public static final StringId AbstractGatewaySender_FAILED_TO_LOCK_META_REGION_0 = new StringIdImpl(5708, "{0}: Failed to lock gateway event id index metadata region");

  public static final StringId GatewayReceiver_PDX_CONFIGURATION = new StringIdImpl(5709, "This gateway receiver has received a PDX type from {0} that does match the existing PDX type. This gateway receiver will not process any more events, in order to prevent receiving objects which may not be deserializable.");
  public static final StringId Gateway_CONFIGURED_SOCKET_READ_TIMEOUT_TOO_LOW = new StringIdImpl(5710, "{0} cannot configure socket read timeout of {1} milliseconds because it is less than the minimum of {2} milliseconds. The default will be used instead.");
  public static final StringId Gateway_OBSOLETE_SYSTEM_POPERTY = new StringIdImpl(5711, "Obsolete java system property named {0} was set to control {1}. This property is no longer supported. Please use the GemFire API instead.");
  public static final StringId GatewayReceiver_EXCEPTION_WHILE_STARTING_GATEWAY_RECEIVER = new StringIdImpl(5712,"Exception occured while starting gateway receiver");
  public static final StringId GatewayReceiver_IS_NOT_RUNNING = new StringIdImpl(5713,"Gateway Receiver is not running");
  public static final StringId GatewayReceiver_IS_ALREADY_RUNNING = new StringIdImpl(5714,"Gateway Receiver is already running");
  public static final StringId ParallelGatewaySenderQueue_NON_PERSISTENT_GATEWAY_SENDER_0_CAN_NOT_BE_ATTACHED_TO_PERSISTENT_REGION_1 = new StringIdImpl(5715,"Non persistent gateway sender {0} can not be attached to persistent region {1}");
  public static final StringId ParallelAsyncEventQueue_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1 = new StringIdImpl(5716,"Parallel Async Event Queue {0} can not be used with replicated region {1}");
  public static final StringId ParallelGatewaySender_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1 = new StringIdImpl(5717,"Parallel gateway sender {0} can not be used with replicated region {1}");

  public static final StringId HDFSSTORE_IS_USED_IN_NONHDFS_REGION = new StringIdImpl(5808, "Only regions with HDFS_PARTITION or HDFS_PERSISTENT_PARTITION data policies can specify a HDFS Store");
  public static final StringId EVICTORSERVICE_CAUGHT_EXCEPTION_0 = new StringIdImpl(5809, "Evictor Service caught following exception : {0}");
  public static final StringId HDFSSTORE_IS_USED_IN_REPLICATED_TABLE = new StringIdImpl(5810, "HDFS Store cannot be used for REPLICATED TABLE");
  public static final StringId HDFS_USER_IS_SAME_AS_GF_USER = new StringIdImpl(5811, "Gemfire user is the same as HDFS user, may cause security risks: {0}");
  public static final StringId GF_KERBEROS_KEYTAB_FILE_ABSENT = new StringIdImpl(5812, "Gemfire kerberos keytab file is missing: {0}");
  public static final StringId GF_KERBEROS_NAMENODE_PRINCIPAL_UNDEF = new StringIdImpl(5813, "Namenode principal must be configured when using kerberos authentication");
  public static final StringId GF_KERBEROS_KEYTAB_UNDEF = new StringIdImpl(5814, "Gemfire kerberos keytab file is not configured");
  public static final StringId GF_KERBEROS_PRINCIPAL_UNDEF = new StringIdImpl(5815, "Gemfire kerberos principal is not configured, kerberos authentication will not be invoked");

  
  public static final StringId GemFireCacheImpl_REST_SERVER_ON_PORT_0_IS_SHUTTING_DOWN = new StringIdImpl(6500, "Rest Server on port {0} is shutting down");
  public static final StringId PartitionedRegion_QUERY_TRACE_LOCAL_NODE_LOG = new StringIdImpl(6501, "  Local {0} took {1}ms and returned {2} results; {3}");
  public static final StringId PartitionedRegion_QUERY_TRACE_REMOTE_NODE_LOG = new StringIdImpl(6502, "  Remote {0} took {1}ms and returned {2} results; {3}");
  public static final StringId PartitionedRegion_QUERY_TRACE_LOG = new StringIdImpl(6503, "Trace Info for Query: {0}");

  public static final StringId Region_RemoveAll_Applied_PartialKeys_At_Server_0 = new StringIdImpl(6504, "Region {0} removeAll at server applied partial keys due to exception.");
  public static final StringId Region_RemoveAll_Applied_PartialKeys_0_1 = new StringIdImpl(6505, "Region {0} removeAll: {1}");

  public static final StringId InternalDistributedSystem_QUORUM_OF_MEMBERS_CONTACTED = new StringIdImpl(6506, "quorum check passed - now attempting multicast discovery");
  public static final StringId DefaultQuery_ORDER_BY_ATTRIBS_NOT_PRESENT_IN_PROJ = new StringIdImpl(6507, "Query contains atleast one order by field which is not present in projected fields.");
  public static final StringId DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY = new StringIdImpl(6508, "Query contains projected column not present in group by clause");
  public static final StringId DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ = new StringIdImpl(6509, "Query contains group by columns not present in projected fields");

  // 6508 - 6597 free
  public static final StringId CqQueryImpl_CQ_NOT_SUPPORTED_FOR_REPLICATE_WITH_LOCAL_DESTROY = new StringIdImpl(6598, "CQ is not supported for replicated region: {0} with eviction action: {1}");

  public static final StringId AbstractDistributionConfig_LOCATOR_WAIT_TIME_NAME_0 = new StringIdImpl(6599, "The amount of time, in seconds, to wait for a locator to be available before throwing an exception during startup.  The default is {0}.");
  public static final StringId CliLegacyMessage_ERROR = new StringIdImpl(6600, "Error processing request {0}.");
  
  public static final StringId AbstractDistributionConfig_MEMCACHED_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1 = new StringIdImpl(6601, "The memcached-bind-address \"{0}\" is not a valid address for this machine.  These are the valid addresses for this machine: {1}");
  public static final StringId GemFireCacheImpl_STARTING_GEMFIRE_MEMCACHED_SERVER_ON_BIND_ADDRESS_0_PORT_1_FOR_2_PROTOCOL = new StringIdImpl(6602, "Starting GemFireMemcachedServer on bind address {0} on port {1} for {2} protocol");

  public static final StringId PersistenceAdvisorImpl_RETRYING_GII = new StringIdImpl(6603, "GII failed from all sources, but members are still online. Retrying the GII.");

  public static final StringId MinimumSystemRequirements_NOT_MET = new StringIdImpl(6604, "Minimum system requirements not met. Unexpected behavior may result in additional errors.");
  public static final StringId MinimumSystemRequirements_JAVA_VERSION = new StringIdImpl(6605, "Java version older than {0}.");

  /**JGroups strings, messageId 15000-90000 **/
  
  /** Testing strings, messageId 90000-99999 **/
  /** These are simple messages for testing, translated with Babelfish. **/
  public static final StringId TESTING_THIS_IS_A_TEST_MESSAGE = new StringIdImpl(90000, "This is a test message.");
  public static final StringId TESTING_THIS_MESSAGE_HAS_0_MEMBERS = new StringIdImpl(90001, "Please ignore: This message has {0} members.");
  public static final StringId OBJECT_PREFIX = new StringIdImpl(90002, "Object_");
  public static final StringId REGION_PREFIX = new StringIdImpl(90003, "Region_");
  public static final StringId LISTENER_PREFIX = new StringIdImpl(90004, "Listener_");
  
  public static final StringId DistributedRegion_INITIALIZING_REGION_COMPLETED_0 = new StringIdImpl(90005, "Initialization of region {0} completed");
}

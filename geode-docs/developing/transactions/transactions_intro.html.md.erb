---
title: Adherence to ACID Promises
---

<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<a id="ACID"></a>

This section introduces <%=vars.product_name%> transactions.
<%=vars.product_name%> offers an API for client applications that do transactional work.
While the implementation of the API does not provide
applications a rigid adherence to all the ACID properties of transactions,
it handles many situations.

<%=vars.product_name%>'s implementation of transactions chooses speed
over the slow,
locking methods of a traditional database.


<%=vars.product_name%> transaction semantics do not offer
the identical Atomicity-Consistency-Isolation-Durability (ACID) semantics
of a traditional relational database.
This <%=vars.product_name%> implementation choice results in
much higher transaction performance without sacrificing ACID promises.
<%=vars.product_name%> transactions do not adhere to ACID constraints
by default,
but they can be configured for ACID support.

### <a id="transaction_semantics__section_8362ACD06C784B5BBB0B7E986F760169" class="no-quick-link"></a>Atomicity

Atomicity is “all or nothing” behavior: a transaction completes successfully only when all of the operations it contains complete successfully. If problems occur during a transaction, perhaps due to other transactions with overlapping changes, the transaction cannot successfully complete until the problems are resolved.

<%=vars.product_name%> transactions provide atomicity and realize speed by using a reservation system, instead of using the traditional relational database technique of a two-phase locking of rows. The reservation prevents other, intersecting transactions from completing, allowing the commit to check for conflicts and to reserve resources in an all-or-nothing fashion prior to making changes to the data. After all changes have been made, locally and remotely, the reservation is released. With the reservation system, an intersecting transaction is simply discarded. The serialization of obtaining locks is avoided.

### <a id="transaction_semantics__section_7C287DA4A5134780B3199CE074E3F890" class="no-quick-link"></a>Consistency

Consistency requires that data written within a transaction must observe the key and value constraints established for the affected region. Note that validity of the transaction is the responsibility of the application.

### <a id="transaction_semantics__section_126A24EC499D4CF39AE766A0B526A9A5" class="no-quick-link"></a>Isolation

Isolation assures that operations will see either the pre-transaction state
or the post-transaction state,
but not the transitional state that occurs while a transaction is in progress.
Write operations in a transaction are always confirmed to ensure that stale
values are not written.
<%=vars.product_name%>'s performance focus results in a default configuration
that does not enforce read isolation.
Transactions have repeatable read isolation,
so once the committed value is read for a given key,
it always returns that same value.
If a transaction write, such as put or invalidate,
deletes a value for a key that has already been read,
subsequent reads return the transactional reference.

See [Mixing Transactions with Multi-threaded Applications](design_considerations.html#transactions-multithreaded) for how multi-threaded applications interact with transactions.

### <a id="transaction_semantics__section_F092E368724945BCBF8E5DCB36B97EB4" class="no-quick-link"></a>Durability

Relational databases provide durability by using disk storage for
recovery and transaction logging.
<%=vars.product_name%> is optimized for performance
and does not support on-disk durability for transactions.

See [Allowing Transactions to Work on Persistent Regions](design_considerations.html#transactions-persistence)
for how to allow a transaction that operates on a persistent region
in a non-durable way.

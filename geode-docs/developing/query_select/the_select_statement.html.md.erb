---
title:  SELECT Statement
---

<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

The SELECT statement allows you to filter data from the collection of object(s) returned by a WHERE search operation. The projection list is either specified as \* or as a comma delimited list of expressions.

For \*, the interim results of the WHERE clause are returned from the query.

**Examples:**

Query all objects from the region using \*. Returns the Collection of portfolios (The exampleRegion contains Portfolio as values).

``` pre
SELECT * FROM /exampleRegion
```

Query secIds from positions. Returns the Collection of secIds from the positions of active portfolios:

``` pre
SELECT secId FROM /exampleRegion, positions.values TYPE Position 
WHERE status = 'active'
```

Returns a Collection of struct&lt;type: String, positions: map&gt; for the active portfolios. The second field of the struct is a Map ( jav.utils.Map ) object, which contains the positions map as the value:

``` pre
SELECT "type", positions FROM /exampleRegion 
WHERE status = 'active'
```

Returns a Collection of struct&lt;portfolios: Portfolio, values: Position&gt; for the active portfolios:

``` pre
SELECT * FROM /exampleRegion, positions.values 
TYPE Position WHERE status = 'active'
```

Returns a Collection of struct&lt;pflo: Portfolio, posn: Position&gt; for the active portfolios:

``` pre
SELECT * FROM /exampleRegion portfolio, positions positions 
TYPE Position WHERE portfolio.status = 'active'
```

## <a id="concept_85AE7D6B1E2941ED8BD2A8310A81753E__section_1B7762EC686A4808B1D12E8851954E82" class="no-quick-link"></a>SELECT Statement Results

The result of a SELECT statement is either UNDEFINED or is a Collection that implements the [SelectResults](/releases/latest/javadoc/org/apache/geode/cache/query/SelectResults.html) interface.

The SelectResults returned from the SELECT statement is either:

1.  A collection of objects, returned for these two cases:
    -   When only one expression is specified by the projection list and that expression is not explicitly specified using the fieldname:expression syntax
    -   When the SELECT list is \* and a single collection is specified in the FROM clause

2.  A collection of Structs that contains the objects

When a struct is returned, the name of each field in the struct is determined following this order of preference:

1.  If a field is specified explicitly using the fieldname:expression syntax, the fieldname is used.
2.  If the SELECT projection list is \* and an explicit iterator expression is used in the FROM clause, the iterator variable name is used as the field name.
3.  If the field is associated with a region or attribute path, the last attribute name in the path is used.
4.  If names cannot be decided based on these rules, arbitrary unique names are generated by the query processor.

## <a id="concept_85AE7D6B1E2941ED8BD2A8310A81753E__section_972EE73A6F3E4427B6A99DB4EDF5860D" class="no-quick-link"></a>DISTINCT

Use the DISTINCT keyword if you want to limit the results set to unique rows. Note that in the current version of <%=vars.product_name%> you are no longer required to use the DISTINCT keyword in your SELECT statement.

``` pre
SELECT DISTINCT * FROM /exampleRegion
```

**Note:**
If you are using DISTINCT queries, you must implement the equals and hashCode methods for the objects that you query.

## <a id="concept_85AE7D6B1E2941ED8BD2A8310A81753E__section_25D7055B33EC47B19B1B70264B39212F" class="no-quick-link"></a>LIMIT

You can use the LIMIT keyword at the end of the query string to limit the number of values returned.

For example, this query returns at most 10 values:

``` pre
SELECT * FROM /exampleRegion LIMIT 10
```

## <a id="concept_85AE7D6B1E2941ED8BD2A8310A81753E__section_D9DF0F785CA94EF8B367C3326CC12990" class="no-quick-link"></a>ORDER BY

You can order your query results in ascending or descending order by using the ORDER BY clause. You must use DISTINCT when you write ORDER BY queries.

``` pre
SELECT DISTINCT * FROM /exampleRegion WHERE ID < 101 ORDER BY ID
```

The following query sorts the results in ascending order:

``` pre
SELECT DISTINCT * FROM /exampleRegion WHERE ID < 101 ORDER BY ID asc
```

The following query sorts the results in descending order:

``` pre
SELECT DISTINCT * FROM /exampleRegion WHERE ID < 101 ORDER BY ID desc
```

**Note:**
If you are using ORDER BY queries, you must implement the equals and hashCode methods for the objects that you query.

## <a id="select_groupBy" class="no-quick-link"></a>GROUP BY

You can collect data across multiple entries and group the results by one or more columns through the usage of the GROUP BY statement.
It's important to note some facts about the usage of the statement:

* It can group results by one or more fields.
* It returns a single record / entry per group.
* It must always be placed before the ORDER BY clause, if any.
* It can be used in conjunction with other aggregate functions: AVG, COUNT, MIN, MAX and SUM.
* It groups records using the selected fields if and only if the fields have identical data across entries.
* It is required, whenever an aggregate function is used within a query with other selected fields, to use GROUP BY.
* If there are no other aggregate functions within the query, all fields included within a GROUP BY clause must also be part of the original projection list, and all fields included within the projection list must also be part of the GROUP BY clause.

The following are example GROUP BY queries.

``` pre
SELECT ID, MAX(e.sales)
FROM /employees e
GROUP BY ID
```

``` pre
SELECT pf.shortID, pf.status
FROM /portfolio pf
GROUP BY pf.shortID, pf.status
```

``` pre
SELECT pf.status, MIN(pf.ID), MAX(pf.ID), COUNT(pf.ID), AVG(pf.ID), SUM(pf.ID)
FROM /portfolio pf
GROUP BY pf.status
```

## <a id="concept_85AE7D6B1E2941ED8BD2A8310A81753E__section_69DCAD624E9640028BC86FD67649DEB2" class="no-quick-link"></a>Preset Query Functions

<%=vars.product_name%> provides several built-in functions for evaluating or filtering data returned from a query. They include the following:

<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ELEMENT(expr)</td>
<td>Extracts a single element from a collection or array. This function throws a <code class="ph codeph">FunctionDomainException</code> if the argument is not a collection or array with exactly one element.</td>
<td><pre class="pre codeblock"><code>ELEMENT(SELECT DISTINCT * 
 FROM /exampleRegion 
 WHERE id = &#39;XYZ-1&#39;).status = &#39;active&#39;</code></pre></td>
</tr>
<tr class="even">
<td>IS_DEFINED(expr)</td>
<td>Returns TRUE if the expression does not evaluate to <a href="../query_additional/literals.html#literals__section_undefined">UNDEFINED</a>.  Inequality queries include undefined values in their query results. With the IS_DEFINED function, you can limit results to only those elements with defined values.</td>
<td><pre class="pre codeblock"><code>IS_DEFINED(SELECT DISTINCT * 
FROM /exampleRegion p 
WHERE p.status = &#39;active&#39;)</code></pre></td>
</tr>
<tr class="odd">
<td>IS_UNDEFINED (expr)</td>
<td>Returns TRUE if the expression evaluates to <a href="../query_additional/literals.html#literals__section_undefined">UNDEFINED</a>. With the exception of inequality queries, most queries do not include undefined values in their query results. The IS_UNDEFINED function allows undefined values to be included, so you can identify elements with undefined values.</td>
<td><pre class="pre codeblock"><code>SELECT DISTINCT * 
FROM /exampleRegion p 
WHERE IS_UNDEFINED(p.status)</code></pre></td>
</tr>
<tr class="even">
<td>NVL(expr1, expr2)</td>
<td>Returns expr2 if expr1 is null. The expressions can be query parameters (bind arguments), path expressions, or literals.</td>
<td> </td>
</tr>
<tr class="odd">
<td>TO_DATE(date_str, format_str)</td>
<td>Returns a Java Data class object. The arguments must be String S with date_str representing the date and format_str representing the format used by date_str. The format_str you provide is parsed using java.text.SimpleDateFormat.</td>
<td> </td>
</tr>
</tbody>
</table>

## <a id="select_min" class="no-quick-link"></a>MIN

The MIN keyword returns the minimum or smallest value from the selected expression. The expression itself must always evaluate to `java.lang.Comparable`. The MIN statement returns the actual type of the selected element as its result. 

The following are example MIN queries that return region entries (the entries implement the `java.lang.Comparable` interface).

``` pre
SELECT MIN(pf)
FROM /exampleRegion pf
```

``` pre
SELECT MIN(pf)
FROM /exampleRegion
pf WHERE pf.ID > 0
```

``` pre
SELECT MIN(pf)
FROM /exampleRegion pf
WHERE pf.ID > 10 LIMIT 50
```

``` pre
SELECT MIN(pf) 
FROM /exampleRegion pf 
WHERE pf.ID > 0 AND pf.status LIKE 'act%'
```

The following MIN query returns the lowest entry ID that matches the query's selection criteria.

``` pre
SELECT MIN(pf.ID)
FROM /exampleRegion pf, pf.positions.values pos
WHERE pf.ID > 0 AND pos.secId = 'IBM'
```

The following MIN query returns the lowest positive ID grouped by status.

``` pre
SELECT pf.status, MIN(pf.ID)
FROM /exampleRegion pf
WHERE pf.ID > 0
GROUP BY pf.status
```

## <a id="select_max" class="no-quick-link"></a>MAX

The MAX keyword returns the maximum or highest value from the selected expression. The expression itself must always evaluate to `java.lang.Comparable`. The MAX statement returns the type of the selected element as its result. 

The following are example MAX queries that return region entries (the entries implement the `java.lang.Comparable` interface).

``` pre
SELECT MAX(pf)
FROM /exampleRegion pf
```

``` pre
SELECT MAX(pf)
FROM /exampleRegion
pf WHERE pf.ID > 0
```

``` pre
SELECT MAX(pf)
FROM /exampleRegion pf
WHERE pf.ID > 10 LIMIT 50
```

``` pre
SELECT MAX(pf) 
FROM /exampleRegion pf 
WHERE pf.ID > 0 AND pf.status LIKE 'act%'
```

The following MAX query returns the highest entry ID that matches the query's selection criteria.

``` pre
SELECT MAX(pf.ID)
FROM /exampleRegion pf, pf.positions.values pos
WHERE pf.ID > 0 AND pos.secId = 'IBM'
```

The following MAX query returns the highest positive IDs grouped by status.

``` pre
SELECT pf.status, MAX(pf.ID)
FROM /exampleRegion pf
WHERE pf.ID > 0
GROUP BY pf.status
```

## <a id="select_count" class="no-quick-link"></a>COUNT

The COUNT keyword returns the number of results that match the query selection conditions specified in the WHERE clause. Using COUNT allows you to determine the size of a results set. The COUNT statement always returns an integer as its result.

The following queries are example COUNT queries that return region entries:

``` pre
SELECT COUNT(*)
FROM /exampleRegion
```

``` pre
SELECT COUNT(*)
FROM /exampleRegion
WHERE ID > 0
```

``` pre
SELECT COUNT(*
FROM /exampleRegion
WHERE ID > 0 LIMIT 50
```

``` pre
SELECT COUNT(*)
FROM /exampleRegion 
WHERE ID > 0 AND status LIKE 'act%'
```

``` pre
SELECT COUNT(*)
FROM /exampleRegion 
WHERE ID IN SET(1,2,3,4,5)
```

The following COUNT query returns the total number of StructTypes that match the query's selection criteria.

``` pre
SELECT COUNT(*) 
FROM /exampleRegion p, p.positions.values pos 
WHERE p.ID > 0 AND pos.secId 'IBM'
```

The following COUNT query uses the DISTINCT keyword and eliminates duplicates from the number of results.

``` pre
SELECT DISTINCT COUNT(*)
FROM /exampleRegion p, p.positions.values pos
WHERE p.ID > 0 OR p.status = 'active' OR pos.secId = 'IBM'
```

## <a id="select_sum" class="no-quick-link"></a>SUM

The SUM keyword returns the summation of all results that match the query selection conditions specified in the WHERE clause. Using SUM allows you to aggregate specific numeric values within a results set.
For partitioned regions, each node's buckets compute a sum over that node and return the result to the coordinator node executing the query, which then aggregates the sums across all nodes.

The SUM function where the DISTINCT modifier is applied to the expression returns the summation over the set of unique (distinct) values.
For partitioned regions, the distinct values in a node's buckets are returned to the coordinator node, which can then calculate the sum over the values that are unique across nodes, after eliminating duplicate values that come from separate nodes.

The SUM statement always returns a `java.lang.Number` as its result, and the actual expression used to calculate the aggregation should also be an instance of `java.lang.Number`.  

The following are example SUM queries that return the summation of the entries ID.

``` pre
SELECT SUM(ID)
FROM /exampleRegion
```

``` pre
SELECT SUM(ID)
FROM /exampleRegion
WHERE ID > 0
```

``` pre
SELECT SUM(ID)
FROM /exampleRegion
WHERE ID > 0 LIMIT 50
```

``` pre
SELECT SUM(ID)
FROM /exampleRegion 
WHERE ID > 0 AND status LIKE 'act%'
```

``` pre
SELECT SUM(ID)
FROM /exampleRegion 
WHERE ID IN SET(1,2,3,4,5)
```

The following SUM query returns the total summation of positive IDs grouped by status.

``` pre
SELECT pf.status, SUM(pf.ID) 
FROM /exampleRegion pf
WHERE pf.ID > 0
GROUP BY pf.status
```

The following SUM query uses the DISTINCT keyword and eliminates duplicates from the aggregation.

``` pre
SELECT SUM(DISTINCT pf.ID)
FROM /exampleRegion pf, pf.positions.values pos
WHERE pf.ID > 0 OR pf.status = 'active' OR pos.secId = 'IBM'
```

The following SUM query returns the total aggregation of positive IDs grouped by status and sorted by the aggregation result in descending order.

``` pre
SELECT pf.status, SUM(pf.ID) as sm 
FROM /exampleRegion pf
WHERE pf.ID > 0
GROUP BY pf.status
ORDER BY sm DESC
```

## <a id="select_avg" class="no-quick-link"></a>AVG

The AVG keyword returns the arithmetic mean of the set formed by the selected expression.
For partitioned regions, each node's buckets provide both a sum and the number of elements to the node executing the query (coordinator), such that a correct average may be computed.

The AVG keyword where the DISTINCT modifier is applied to the expression returns the arithmetic mean of the set of unique (distinct) values.
For partitioned regions, the distinct values in a node's buckets are returned to the coordinator node, which can then calculate the average over the values that are unique across nodes, after eliminating duplicate values that come from separate nodes.

The AVG statement always returns a `java.lang.Number` as its result, and the actual expression used to calculate the aggregation should also be an instance of `java.lang.Number`.

The following are example AVG queries that calculate the average of the entries ID.

``` pre
SELECT AVG(ID)
FROM /exampleRegion
```

``` pre
SELECT AVG(ID)
FROM /exampleRegion
WHERE ID > 0
```

``` pre
SELECT AVG(ID)
FROM /exampleRegion
WHERE ID > 0 LIMIT 50
```

``` pre
SELECT AVG(ID)
FROM /exampleRegion 
WHERE ID > 0 AND status LIKE 'act%'
```

``` pre
SELECT AVG(ID)
FROM /exampleRegion 
WHERE ID IN SET(1,2,3,4,5)
```

The following AVG query returns the average of positive IDs grouped by status.

``` pre
SELECT pf.status, AVG(pf.ID) 
FROM /exampleRegion pf
WHERE pf.ID > 0
GROUP BY pf.status
```

The following AVG query uses the DISTINCT keyword and eliminates duplicates from the aggregation.

``` pre
SELECT AVG(DISTINCT pf.ID)
FROM /exampleRegion pf, pf.positions.values pos
WHERE pf.ID > 0 OR pf.status = 'active' OR pos.secId = 'IBM'
```

The following AVG query returns the average of positive IDs grouped by status and sorted by the calculation result in descending order.

``` pre
SELECT pf.status, AVG(pf.ID) as sm 
FROM /exampleRegion pf
WHERE pf.ID > 0
GROUP BY pf.status
ORDER BY sm DESC
```

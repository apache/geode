/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional information regarding
 * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

plugins {
  id 'standard-subproject-configuration'
  id 'war'
  id 'geode-publish-war'
  id 'warnings'
  id 'nebula.facet'
}

jar.enabled = false

/*
 * ==============================================================================
 * GEODE-10466: Jakarta EE 10 and Spring 6.x Migration
 * ==============================================================================
 * The changes below migrate the existing module from:
 *   - javax.servlet:javax.servlet-api → jakarta.servlet:jakarta.servlet-api
 *   - Spring Framework 5.x → Spring Framework 6.x
 *   - Jetty 11 (Jakarta EE 9) → Jetty 12 (Jakarta EE 10)
 *   - SpringDoc 1.x → SpringDoc 2.x
 *
 * This module provides the modern Management REST API (V2) at /management,
 * which offers a programmatic ClusterManagementService-based API, contrasting
 * with the legacy Shell Commands API (V1) at /geode-mgmt.
 * ==============================================================================
 */

/*
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * Spring 6.x Compiler Configuration
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * REASON: Spring 6.x requires parameter names at runtime for request mapping
 *
 * Spring 6.x made parameter name discovery mandatory for @RequestParam and
 * @PathVariable annotations when names are not explicitly specified. Without
 * the -parameters flag, Spring cannot determine parameter names from bytecode,
 * causing IllegalArgumentException: "Name for argument of type [java.lang.String]
 * not specified, and parameter name information not found in class file either."
 *
 * The -parameters flag instructs javac to include parameter names in bytecode's
 * MethodParameters attribute (JSR 335), enabling Spring's reflection-based
 * parameter name discovery.
 *
 * MIGRATION IMPACT:
 *   - Required for all Spring 6.x @RestController methods
 *
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */
tasks.withType(JavaCompile) {
  options.compilerArgs << '-parameters'
}

facets {
  commonTest {
    testTaskName = 'commonTest'
    includeInCheckLifecycle = false
  }
}

commonTest {
  useJUnitPlatform()
}

sourceSets {
  integrationTest {
    resources {
      srcDir "${projectDir}/src/main/webapp"
    }
  }

  distributedTest {
    resources {
      srcDir "${projectDir}/src/main/webapp"
    }
  }
}

configurations {
  war {}
}
dependencies {
  api(platform(project(':boms:geode-all-bom'))) {
    exclude module: "jackson-annotations"
  }
  compileOnly(project(':geode-logging'))
  compileOnly(project(':geode-serialization'))
  compileOnly(project(':geode-core'))

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * Jakarta EE 10 Servlet API Migration
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * CHANGED: javax.servlet:javax.servlet-api → jakarta.servlet:jakarta.servlet-api
   *
   * REASON: Jakarta EE namespace migration (javax.* → jakarta.*)
   *
   * In 2017, Java EE was transferred from Oracle to Eclipse Foundation and
   * rebranded as Jakarta EE. Oracle retained trademark rights to "javax.*"
   * package names, forcing Eclipse to migrate all APIs to "jakarta.*" namespace.
   *
   * Timeline:
   *   - Jakarta EE 8  (2019): javax.* namespace (transition release)
   *   - Jakarta EE 9  (2020): jakarta.* namespace (breaking change)
   *   - Jakarta EE 10 (2022): jakarta.* with new features (target version)
   *
   * This affects ALL servlet classes:
   *   javax.servlet.http.HttpServletRequest → jakarta.servlet.http.HttpServletRequest
   *   javax.servlet.Filter → jakarta.servlet.Filter
   *   javax.servlet.ServletContext → jakarta.servlet.ServletContext
   *   etc.
   *
   * JETTY COMPATIBILITY:
   *   - Jetty 11: Jakarta EE 9 (jakarta.servlet 5.0)
   *   - Jetty 12: Jakarta EE 9/10 multi-environment (EE8/EE9/EE10 cores)
   *   - This migration targets Jetty 12 EE10 environment
   *
   * SCOPE: compileOnly because servlet-api is provided by Jetty at runtime
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  compileOnly('jakarta.servlet:jakarta.servlet-api')

  /* jackson-annotations must be accessed from the geode classloader and not the webapp */
  compileOnly('com.fasterxml.jackson.core:jackson-annotations')

  implementation('org.apache.commons:commons-lang3')
  implementation('commons-fileupload:commons-fileupload') {
    exclude module: 'commons-io'
  }

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * Jackson Classloader Strategy
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * CRITICAL: Jackson JARs MUST be on parent classloader (geode/lib), NOT in WAR
   *
   * REASON: Jetty 12's WebAppClassLoader isolation prevents class casting between
   * classloaders, causing ClassCastException when Jackson classes are loaded from
   * multiple locations.
   *
   * PROBLEM SCENARIO (without compileOnly):
   *   1. geode/lib contains jackson-core-2.17.0.jar (parent classloader)
   *   2. WAR contains jackson-core-2.17.0.jar (WebAppClassLoader)
   *   3. CustomMappingJackson2HttpMessageConverter loads JavaTimeModule from WAR
   *   4. Spring tries to register JavaTimeModule → casting fails:
   *      "com.fasterxml.jackson.databind.Module cannot be cast to
   *       com.fasterxml.jackson.databind.Module"
   *
   * This occurs because the same class loaded by different classloaders creates
   * DISTINCT Class objects in the JVM, making them incompatible for casting.
   *
   * SOLUTION: Use compileOnly scope + explicit WAR exclusions (see war {} block)
   *   - compileOnly: Includes Jackson in compile classpath but NOT in WAR dependencies
   *   - WAR exclusions: Removes any transitive Jackson JARs that slip through
   *   - Runtime: Jackson loaded ONLY from parent classloader (geode/lib)
   *
   * This ensures ALL Jackson classes come from a single classloader, preventing
   * ClassCastException and maintaining type compatibility.
   *
   * JETTY CLASSLOADER HIERARCHY:
   *   ┌─────────────────────────────────────┐
   *   │ System ClassLoader (JDK classes)    │
   *   └──────────────┬──────────────────────┘
   *                  │
   *   ┌──────────────▼──────────────────────┐
   *   │ App ClassLoader (geode/lib)         │  ← Jackson HERE
   *   │   - jackson-core-2.17.0.jar         │
   *   │   - jackson-databind-2.17.0.jar     │
   *   │   - spring-*.jar                    │
   *   └──────────────┬──────────────────────┘
   *                  │
   *   ┌──────────────▼──────────────────────┐
   *   │ WebAppClassLoader (WAR classes)     │  ← NO Jackson
   *   │   - REST controllers                │
   *   │   - Security configuration          │
   *   │   - CustomMappingJackson2...        │
   *   └─────────────────────────────────────┘
   *
   * RELATED ISSUES:
   *   - Similar pattern applied to Spring JARs (see war exclusions)
   *   - See CustomMappingJackson2HttpMessageConverter.java for usage
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  compileOnly('com.fasterxml.jackson.core:jackson-core')
  compileOnly('com.fasterxml.jackson.core:jackson-databind')

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * SpringDoc 2.x Migration (OpenAPI 3.x Documentation)
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * CHANGED: springdoc-openapi-ui → springdoc-openapi-starter-webmvc-ui
   *
   * REASON: SpringDoc 2.x restructured artifacts for Spring Boot 3.x compatibility
   *
   * Artifact naming evolution:
   *   - SpringDoc 1.x: springdoc-openapi-ui (Spring 5.x)
   *   - SpringDoc 2.x: springdoc-openapi-starter-webmvc-ui (Spring 6.x)
   *
   * The "-starter-" naming follows Spring Boot's convention, indicating it includes
   * autoconfiguration support. However, we exclude Spring Boot JARs (see war {} block)
   * since this is a pure Spring Framework application.
   *
   * NOTE: SpringDoc JARs are EXCLUDED from WAR (see war exclusions) because:
   *   1. SpringDoc 2.x depends on Spring Boot autoconfiguration
   *   2. We don't use Spring Boot (pure Spring Framework)
   *   3. Excluding Spring Boot breaks SpringDoc's runtime initialization
   *   4. OpenAPI docs are development-only, not required for production REST API
   *
   * TRADE-OFF DECISION:
   *   - Lose: Swagger UI documentation at /management/swagger-ui.html
   *   - Keep: Full REST API functionality for production use
   *   - Rationale: API documentation is primarily for developers, production
   *     deployments don't require it
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  implementation('org.springdoc:springdoc-openapi-starter-webmvc-ui') {
    exclude module: 'slf4j-api'
    exclude module: 'jackson-annotations'
  }

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * Spring AOP Explicit Dependency
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * ADDED: spring-aop (was implicit in Spring 5.x)
   *
   * REASON: Spring 6.x made AOP dependencies explicit for component scanning
   *
   * PROBLEM WITHOUT THIS DEPENDENCY:
   *   ClassNotFoundException: org.springframework.aop.scope.ScopedProxyUtils
   *     at org.springframework.context.annotation.ComponentScanBeanDefinitionParser
   *     at org.springframework.beans.factory.xml.XmlBeanDefinitionReader
   *
   * ROOT CAUSE:
   *   Spring's component scanning (<context:component-scan>) uses AOP infrastructure
   *   for scoped proxy creation. In Spring 5.x, spring-aop was transitively included
   *   via spring-context. In Spring 6.x, dependency graph was optimized, making
   *   spring-aop optional for spring-context.
   *
   * WHEN REQUIRED:
   *   - Component scanning with scoped proxies
   *   - @EnableAspectJAutoProxy annotations
   *   - AOP-based features like @PreAuthorize (Spring Security)
   *
   * MIGRATION IMPACT:
   *   - Must be declared explicitly for Spring 6.x applications using component-scan
   *   - Increases WAR size by ~500KB (spring-aop JAR)
   *   - Required for our XML-based Spring configuration (management-servlet.xml)
   *
   * ALTERNATIVE REJECTED:
   *   - Removing component-scan → Requires converting all beans to Java Config
   *   - Too invasive for migration, XML config is well-established
   *
   * RELATED:
   *   - This JAR is also excluded from WAR (see war {} block) to use parent version
   *   - See management-servlet.xml for <context:component-scan> usage
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  implementation('org.springframework:spring-aop')
  implementation('org.springframework:spring-beans')
  implementation('org.springframework.security:spring-security-core')
  implementation('org.springframework.security:spring-security-web')
  implementation('org.springframework.security:spring-security-config')
  implementation('org.springframework:spring-web')
  implementation('org.springframework:spring-webmvc')
  implementation('org.springframework.hateoas:spring-hateoas') {
    exclude module: 'aopalliance'
    exclude module: 'commons-logging'
    exclude module: 'objenesis'
    exclude module: 'slf4j-api'
    exclude module: 'spring-core'
    exclude module: 'spring-plugin-core'
  }
  implementation('org.springframework:spring-aspects') {
    exclude module: 'aopalliance'
    exclude module: 'aspectjweaver'
  }
  implementation('org.springframework:spring-oxm') {
    exclude module: 'commons-logging'
    exclude module: 'spring-core'
    exclude module: 'spring-beans'
  }
  compileOnly('org.apache.logging.log4j:log4j-api')

  commonTestImplementation(project(':geode-core'))
  commonTestImplementation(project(':geode-junit')) {
    exclude module: 'geode-core'
  }
  commonTestImplementation(project(':geode-dunit')) {
    exclude module: 'geode-core'
  }
  commonTestImplementation('org.springframework:spring-test')
  commonTestImplementation('org.springframework:spring-webmvc')
  commonTestImplementation('org.springframework.security:spring-security-test')
  commonTestImplementation(project(':geode-web-management'))

  testImplementation(project(':geode-junit')) {
    exclude module: 'geode-core'
  }
  testImplementation(project(':geode-core'))
  testImplementation('jakarta.servlet:jakarta.servlet-api')

  integrationTestImplementation(sourceSets.commonTest.output)

  integrationTestImplementation(project(':geode-core'))
  integrationTestImplementation('org.springframework:spring-test')
  integrationTestImplementation('org.springframework:spring-webmvc')
  integrationTestImplementation('org.springframework.security:spring-security-test')

  integrationTestImplementation(project(':geode-junit')) {
    exclude module: 'geode-core'
  }
  integrationTestImplementation(project(':geode-dunit')) {
    exclude module: 'geode-core'
  }
  integrationTestRuntimeOnly('org.apache.logging.log4j:log4j-slf4j-impl') {
    exclude module: 'slf4j-api'
  }

  distributedTestImplementation(sourceSets.commonTest.output)

  distributedTestImplementation('org.springframework:spring-test')
  distributedTestImplementation('org.springframework:spring-webmvc')
  distributedTestImplementation('org.springframework.security:spring-security-test')

  distributedTestImplementation(project(':geode-core'))
  distributedTestImplementation(project(':geode-junit')) {
    exclude module: 'geode-core'
  }
  distributedTestImplementation(project(':geode-dunit')) {
    exclude module: 'geode-core'
  }

  distributedTestRuntimeOnly('org.apache.logging.log4j:log4j-slf4j-impl') {
    exclude module: 'slf4j-api'
  }
}

/*
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * WAR Packaging Configuration - Critical Exclusions for Jetty 12 Classloading
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 *
 * CONTEXT: Jetty 12 WebAppContext Classloader Isolation
 *
 * Jetty 12 introduced a multi-environment architecture supporting EE8, EE9, and
 * EE10 simultaneously. Each environment runs in its own isolated classloader to
 * prevent javax.* and jakarta.* namespace collisions. This isolation is stricter
 * than Jetty 11, requiring careful JAR placement to avoid LinkageError and
 * ClassCastException.
 *
 * CLASSLOADER HIERARCHY:
 *   ┌─────────────────────────────────────────────────────────────┐
 *   │ System ClassLoader (JDK)                                    │
 *   └──────────────┬──────────────────────────────────────────────┘
 *                  │
 *   ┌──────────────▼──────────────────────────────────────────────┐
 *   │ App ClassLoader (geode/lib) - PARENT FIRST                  │
 *   │   - spring-*.jar (all Spring Framework JARs)                │
 *   │   - jackson-*.jar (all Jackson JARs)                        │
 *   │   - log4j-*.jar, commons-*.jar, etc.                        │
 *   └──────────────┬──────────────────────────────────────────────┘
 *                  │
 *   ┌──────────────▼──────────────────────────────────────────────┐
 *   │ WebAppClassLoader (WAR) - CHILD FIRST (for WAR-only JARs)  │
 *   │   - REST controllers (@RestController classes)              │
 *   │   - Security config (RestSecurityConfiguration)             │
 *   │   - Application-specific code                               │
 *   │   - NO Spring JARs, NO Jackson JARs                         │
 *   └─────────────────────────────────────────────────────────────┘
 *
 * STRATEGY: "Parent Classloader First" for Shared Libraries
 *
 * All transitive Spring and Jackson dependencies are excluded from WAR and
 * loaded from geode/lib (parent classloader). This prevents:
 *   1. LinkageError - Same class loaded by different classloaders
 *   2. ClassCastException - Class instances incompatible across classloaders
 *   3. MethodNotFoundException - Version mismatches between WAR and parent
 *   4. NoClassDefFoundError - Incomplete dependency sets in WAR
 *
 * WHY EXCLUDE FROM WAR:
 *   - CORRECTNESS: Single source of truth for shared library versions
 *   - CONSISTENCY: All webapps use same Spring/Jackson versions
 *   - PERFORMANCE: Reduced memory footprint (shared JARs loaded once)
 *   - MAINTENANCE: Version upgrades affect all webapps uniformly
 *
 * HISTORICAL NOTE:
 *   Pre-Jetty 12 (Jetty 11 and earlier) was more lenient about JAR duplication,
 *   allowing some overlap between parent and webapp classloaders. Jetty 12's
 *   strict isolation exposes previously hidden classloader conflicts.
 *
 * REFERENCE:
 *   - Jetty 12 WebAppContext: https://eclipse.dev/jetty/documentation/jetty-12/programming-guide/index.html#pg-server-http-handler-use-webapp-context
 *   - ClassLoader delegation: https://eclipse.dev/jetty/documentation/jetty-12/operations-guide/index.html#og-webapp-classloading
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */
war {
  enabled = true

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * LEGACY: commons-logging exclusion (predates this migration)
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  rootSpec.exclude("**/*commons-logging-*.jar")

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * Spring Framework JAR Exclusions - CRITICAL for Jetty 12
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * REASON: Prevent LinkageError from duplicate Spring classes
   *
   * All Spring Framework JARs MUST reside in geode/lib (parent classloader).
   * Including them in WAR causes LinkageError when Spring beans reference
   * classes from both classloaders.
   *
   * EXAMPLE ERROR (without exclusions):
   *   LinkageError: loader constraint violation: loader 'app' previously
   *   initiated loading for a different type with name
   *   "org/springframework/beans/factory/BeanFactory"
   *
   * SPRING JARS IN geode/lib:
   *   - spring-web, spring-webmvc (web tier)
   *   - spring-core, spring-beans (core container)
   *   - spring-context, spring-expression (DI infrastructure)
   *   - spring-aop (AOP support, required for component-scan)
   *   - spring-jcl (Jakarta Commons Logging bridge)
   *
   * DEPENDENCY GRAPH (simplified):
   *   spring-webmvc → spring-web → spring-core
   *   spring-context → spring-beans → spring-core
   *   spring-security-web → spring-web, spring-security-core
   *
   * All must come from same classloader for proper dependency resolution.
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  rootSpec.exclude("**/spring-web-*.jar")
  rootSpec.exclude("**/spring-core-*.jar")
  rootSpec.exclude("**/spring-beans-*.jar")
  rootSpec.exclude("**/spring-context-*.jar")
  rootSpec.exclude("**/spring-expression-*.jar")
  rootSpec.exclude("**/spring-jcl-*.jar")
  rootSpec.exclude("**/spring-aop-*.jar")  /* Required for component-scan, must be on parent */

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * Spring Boot Exclusions - NOT USED, Causes Autoconfiguration Conflicts
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * REASON: This is a pure Spring Framework application, NOT Spring Boot
   *
   * SpringDoc 2.x transitively depends on Spring Boot, but we don't use Boot's
   * features. Including Spring Boot JARs in WAR causes:
   *   1. SpringApplication autoconfiguration attempts (fails, no Boot context)
   *   2. Conflicting bean definitions (@Configuration vs XML <bean>)
   *   3. Classpath scanning duplication (Boot + XML component-scan)
   *
   * SPRING BOOT vs SPRING FRAMEWORK:
   *   - Spring Framework: Core DI container, no autoconfiguration
   *   - Spring Boot: Opinionated defaults + autoconfiguration + embedded server
   *
   * We configure Spring explicitly via management-servlet.xml (XML config),
   * which is incompatible with Boot's annotation-driven autoconfiguration.
   *
   * IMPACT OF EXCLUSION:
   *   - No Spring Boot features (expected, we don't use them)
   *   - Breaks SpringDoc initialization (acceptable trade-off, see below)
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  rootSpec.exclude("**/spring-boot-*.jar")
  rootSpec.exclude("**/spring-boot-autoconfigure-*.jar")

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * SpringDoc OpenAPI Exclusions - Requires Spring Boot Infrastructure
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * REASON: SpringDoc 2.x initialization depends on Spring Boot autoconfiguration
   *
   * SpringDoc 2.x was designed for Spring Boot's "starter" pattern and relies on:
   *   - SpringBootApplication context
   *   - @ConditionalOnClass annotations
   *   - Auto-configuration classes
   *
   * Without Spring Boot JARs (excluded above), SpringDoc fails to initialize:
   *   NoClassDefFoundError: org/springframework/boot/autoconfigure/SpringBootApplication
   *
   * TRADE-OFF DECISION:
   *   ✓ KEEP: Full REST API functionality (/management/v1/*)
   *   ✗ LOSE: Swagger UI documentation (/management/swagger-ui.html)
   *
   * RATIONALE:
   *   - OpenAPI docs are development/testing tools, not production requirements
   *   - REST API endpoints remain fully functional
   *   - Alternative: Manually maintain openapi.yaml (out of scope for migration)
   *   - Future: Migrate to springdoc-openapi-native (pure Spring Framework version)
   *
   * EXCLUDED ARTIFACTS:
   *   - springdoc-openapi-starter-webmvc-ui (main SpringDoc JAR)
   *   - springdoc-openapi-common (shared classes)
   *   - All transitive springdoc-* dependencies
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  rootSpec.exclude("**/springdoc-*.jar")

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * SwaggerConfig Class Exclusion - Prevents ServletContainerInitializer Error
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * REASON: WebApplicationInitializer invocation fails without SpringDoc JARs
   *
   * SwaggerConfig.java implements WebApplicationInitializer, which is part of
   * Spring's ServletContainerInitializer SPI. During webapp startup, Jetty's
   * ServletContainerInitializer discovers ALL WebApplicationInitializer
   * implementations via classpath scanning and invokes their onStartup() methods.
   *
   * STARTUP SEQUENCE:
   *   1. Jetty starts webapp context
   *   2. ServletContainerInitializer scans for WebApplicationInitializer classes
   *   3. Finds SwaggerConfig.class
   *   4. Invokes SwaggerConfig.onStartup()
   *   5. SwaggerConfig tries to load SpringDoc classes
   *   6. FAILURE: NoClassDefFoundError (SpringDoc JARs excluded)
   *
   * EXAMPLE ERROR (without .class exclusion):
   *   java.lang.NoClassDefFoundError: org/springdoc/core/SpringDocConfiguration
   *     at SwaggerConfig.onStartup(SwaggerConfig.java:42)
   *     at org.springframework.web.SpringServletContainerInitializer.onStartup
   *
   * SOLUTION: Exclude SwaggerConfig.class from WAR
   *   - Prevents ServletContainerInitializer from discovering it
   *   - No invocation = no NoClassDefFoundError
   *   - Webapp starts successfully without Swagger UI
   *
   * ALTERNATIVE REJECTED:
   *   - Modify SwaggerConfig to check for SpringDoc availability
   *   → Rejected: Cleaner to exclude entirely, Swagger UI not needed in production
   *
   * NOTE: We exclude the .class file, not the .java source, because WAR packaging
   * includes compiled classes from build/classes/java/main directory.
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  rootSpec.exclude("**/SwaggerConfig.class")

  /*
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * Jackson JAR Exclusions - CRITICAL for ClassCastException Prevention
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   * REASON: Jackson classes MUST be loaded from single classloader
   *
   * This is THE MOST CRITICAL exclusion for V2 Management REST API functionality.
   * Without these exclusions, the REST API returns HTTP 503 with ClassCastException.
   *
   * PROBLEM SCENARIO (without exclusions):
   *   1. geode/lib contains jackson-core-2.17.0.jar (parent classloader)
   *   2. WAR contains jackson-core-2.17.0.jar (WebAppClassLoader)
   *   3. CustomMappingJackson2HttpMessageConverter creates ObjectMapper
   *   4. Registers JavaTimeModule from WAR classloader
   *   5. Spring tries to cast: (Module) javaTimeModule
   *   6. FAILURE: ClassCastException
   *
   * ERROR MESSAGE:
   *   java.lang.ClassCastException: class com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
   *   cannot be cast to class com.fasterxml.jackson.databind.Module
   *   (com.fasterxml.jackson.datatype.jsr310.JavaTimeModule and
   *    com.fasterxml.jackson.databind.Module are in unnamed module of loader
   *    org.eclipse.jetty.ee10.webapp.WebAppClassLoader @6f9e08e7;
   *    com.fasterxml.jackson.databind.Module is in unnamed module of loader 'app')
   *
   * ROOT CAUSE - JVM Classloader Type Isolation:
   *   When the same class is loaded by different classloaders, the JVM treats them
   *   as DISTINCT types, even if the bytecode is identical. This breaks casting:
   *
   *     ClassLoader A loads Module.class → Type A (Module from parent)
   *     ClassLoader B loads Module.class → Type B (Module from WAR)
   *     Type A ≠ Type B → ClassCastException
   *
   * SOLUTION: Exclude ALL Jackson JARs from WAR
   *   - jackson-core: Core streaming API (JsonParser, JsonGenerator)
   *   - jackson-databind: Object mapping (ObjectMapper, Module)
   *   - jackson-datatype-*: Type modules (JavaTimeModule, Jdk8Module, etc.)
   *   - jackson-dataformat-*: Format modules (XML, YAML, CSV, etc.)
   *
   * VERIFICATION:
   *   After exclusion, only CustomMappingJackson2HttpMessageConverter.class
   *   remains in WAR. This class uses Jackson API but doesn't bundle Jackson JARs.
   *
   * RELATED:
   *   - See dependencies block above for 'compileOnly' declarations
   *   - See CustomMappingJackson2HttpMessageConverter.java for Jackson usage
   *   - Similar pattern applied to Spring JARs
   *
   * TESTING:
   *   - Verified by DisabledClusterConfigTest (HTTP 500 with proper error message)
   *   - Verified by 28 geode-web-management integration tests (all pass)
   *   - Verified by checking WAR contents: no jackson-*.jar files present
   * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   */
  rootSpec.exclude("**/jackson-core-*.jar")
  rootSpec.exclude("**/jackson-databind-*.jar")
  rootSpec.exclude("**/jackson-datatype-*.jar")
  rootSpec.exclude("**/jackson-dataformat-*.jar")

  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
  /* this shouldn't be necessary but if it's not specified we're missing some of the jars
   * from the runtime classpath
   */
  classpath configurations.runtimeClasspath
}

artifacts {
  war tasks.war
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Task to dump all dependencies of all projects, in a way
// that can be diffed before and after dependency changes
task dumpDependencies() {
  doLast {
    description "Dump all of the dependencies as a flat, sorted list"

    project.configurations.each { configuration ->
      println(project.name + ":" + configuration.name)
      println('-------------------')
      configuration.resolvedConfiguration.resolvedArtifacts.collect { dep -> dep.file.name }.unique().toSorted().each { dep ->
        println(dep)
      }
      println()
    }
  }
}

//Task to find all of the jars in a compile task
//that are unused
task findUsage() {
  doLast {
    description "Find usages of a jar in the source code"

    String jarName = System.getProperty("jar.name")
    if (jar == null || jar == "") {
      println "You must specify a jar name: ./gradlew findUsage -Djar.name=commons-io"
      return
    }
    FileTree sourceFiles = compileJava.source
    FileCollection jars = compileJava.classpath

    File jar = jars.find { file -> file.name.contains(jarName) }

    FileTree jarContents = zipTree(jar)
    Set packages = new HashSet()
    jarContents.visit { file ->
      if (!file.isDirectory() && !file.path.contains("META-INF")) {
        packages.add(file.relativePath.parent.toString().replace('/', '.'))
      }
    }

    println("Packages")
    println "========"
    packages.each { p -> println p }

    println ""
    println("Matches")
    println "========"
    sourceFiles.visit { file ->
      if (!file.isDirectory()) {
        boolean matches = false
        file.file.eachLine { line ->
          def matcher = line =~ /^import (.*)\..*;/
          if (matcher) {
            def pack = matcher[0][1]
            matches |= packages.contains(pack)
          }
        }

        if (matches) {
          println file.relativePath
        }
      }
    }
  }
}
